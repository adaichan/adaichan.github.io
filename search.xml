<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用正则汇总</title>
      <link href="/2021/10/10/50.chang-yong-zheng-ze-hui-zong/"/>
      <url>/2021/10/10/50.chang-yong-zheng-ze-hui-zong/</url>
      
        <content type="html"><![CDATA[<p><strong>一、校验数字的表达式</strong></p><p>数字：^[0-9]*$</p><p>n位的数字：^d{n}$</p><p>至少n位的数字：^d{n,}$</p><p>m-n位的数字：^d{m,n}$</p><p>零和非零开头的数字：^(0|[1-9][0-9]*)$</p><p>非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$</p><p>7位整数5位小数（此正则@<em>keyup</em>.native事件时按小数点会报错，@blue则可以顺利验证）：/(^([0-9]{1,7})?(.[0-9]{1,5})?$)|(^(0){1}$)|(^[0-9].<a href="%5B0-9%5D">0-9</a>?$)/</p><p>7位整数5位小数：/^\d{0,7}(.\d{0,5})?$/</p><p>非零，7位整数5位小数：/^\d{1,7}(.\d{0,5})?$/</p><p>非负整数，最多8位：/^(0|+?[1-9][0-9]{0,7})$/</p><p>非负整数，最多6位：/^([1-9][0-9]{0,5}|0)$/</p><p>整数，最多4位：/^(-?[1-9][0-9]{0,3})$/</p><p>自然数，最多5位：/^(0|+?[1-9][0-9]{0,4})$/</p><p>非中文：/^[^\u4e00-\u9fa5]*$/</p><p>非0开头，最多6位的正整数：^[1-9][0-9]{0,5}$</p><p>7 带1-2位小数的正数或负数：^(-)?d+(.d{1,2})?$</p><p>8 正数、负数、和小数：^(-|+)?d+(.d+)?$</p><p>9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</p><p>10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</p><p>11 非零的正整数：^[1-9]d*$ 或 ^([1-9][0-9]<em>){1,3}$ 或 ^+?[1-9][0-9]</em>$</p><p>12 非零的负整数：^-[1-9][]0-9”<em>$ 或 ^-[1-9]d</em>$</p><pre><code></code></pre><p>14 非正整数：^-[1-9]d*|0$ 或 ^((-d+)|(0+))$</p><p>15 非负浮点数：^d+(.d+)?$ 或 ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$</p><p>16 非正浮点数：^((-d+(.d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$</p><p>17 正浮点数：^[1-9]d*.d*|0.d*[1-9]d*$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>))$</p><p>18 负浮点数：^-([1-9]d*.d*|0.d*[1-9]d*)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>)))$</p><p>19 浮点数：^(-?d+)(.d+)?$ 或 ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$</p><p><strong>二、校验字符的表达式</strong></p><p>1 汉字：^[u4e00-u9fa5]{0,}$</p><p>2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</p><p>3 长度为3-20的所有字符：^.{3,20}$</p><p>4 由26个英文字母组成的字符串：^[A-Za-z]+$</p><p>5 由26个大写英文字母组成的字符串：^[A-Z]+$</p><p>6 由26个小写英文字母组成的字符串：^[a-z]+$</p><p>7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</p><p>8 由数字、26个英文字母或者下划线组成的字符串：^w+$ 或 ^w{3,20}$</p><p>9 中文、英文、数字包括下划线：^[u4E00-u9FA5A-Za-z0-9_]+$</p><p>10 中文、英文、数字但不包括下划线等符号：^[u4E00-u9FA5A-Za-z0-9]+$ 或 ^[u4E00-u9FA5A-Za-z0-9]{2,20}$</p><p>11 可以输入含有^%&amp;’,;=?$”等字符：[^%&amp;’,;=?$x22]+</p><p>12 禁止输入含有<del>的字符：[^</del>x22]+</p><p><strong>三、特殊需求表达式</strong></p><p>1 Email地址：[a-zA-Z0-9]+([-_.][A-Za-zd]+)*@([a-zA-Z0-9]+[-.])+[A-Za-zd]{2,5}$</p><p>2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</p><p>3 InternetURL：[a-zA-z]+://[^s]* 或 ^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$</p><p>4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])d{8}$</p><p>通配电话号：^\s***(?:+?(\d{1,3}))?[-. (]<em><strong>(\d{3})[-. )]</strong></em>(\d{3})[-. ]***(\d{4})(?: <em><strong>x(\d+))?\s</strong></em>$</p><p><img src="C:\Users\13226\AppData\Roaming\Typora\typora-user-images\image-20220801111521659.png" alt="image-20220801111521659"></p><p>5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((d{3,4}-)|d{3.4}-)?d{7,8}$  </p><p>6 国内电话号码(0511-4405222、021-87888822)：d{3}-d{8}|d{4}-d{7}</p><p>7 身份证号(15位、18位数字)：^d{15}|d{18}$</p><p>8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</p><p>9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p><p>10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]w{5,17}$</p><p>11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.<em>d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$  </p><p>12 日期格式：^d{4}-d{1,2}-d{1,2}</p><p>13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p><p>14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$  </p><p>15 钱的输入格式：</p><p>16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$  </p><p>17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$  </p><p>18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$  </p><p>19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$  </p><p>20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$  </p><p>21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$  </p><p>22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$  </p><p>23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$  </p><p>24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</p><p>25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+.[x|X][m|M][l|L]$</p><p>26 中文字符的正则表达式：[u4e00-u9fa5]</p><p>27 双字节字符：[^x00-xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</p><p>28 空白行的正则表达式： s* (可以用来删除空白行)</p><p>29 HTML标记的正则表达式：&lt;(S*?)[^&gt;]<em>&gt;.</em>?&lt;/1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</p><p>30 首尾空白字符的正则表达式：^s*|s*$或(^s*)|(s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</p><p>31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)</p><p>32 中国邮政编码：[1-9]d{5}(?!d) (中国邮政编码为6位数字)</p><p>33 端口号： /^([0-9]|[1-9]\d|[1-9]\d{2}|[1-9]\d{3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$/</p><p>34 IP地址：/^((25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d))).){3}(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))$/g</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用正则汇总</title>
      <link href="/2021/10/10/51-excel-dao-chu/"/>
      <url>/2021/10/10/51-excel-dao-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、使用插件"><a href="#一、使用插件" class="headerlink" title="一、使用插件"></a>一、使用插件</h3><p>像excel.js、xlsx.js、js-export-excel这类插件都可以轻松实现</p><pre class="line-numbers language-js"><code class="language-js">npm install js<span class="token operator">-</span><span class="token keyword">export</span><span class="token operator">-</span>excel <span class="token comment" spellcheck="true">// 或者</span>yarn add js<span class="token operator">-</span><span class="token keyword">export</span><span class="token operator">-</span>excel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> ExportJsonExcel <span class="token keyword">from</span> <span class="token string">'js-export-excel'</span><span class="token comment" spellcheck="true">// 模拟数据</span><span class="token keyword">const</span> tableItemConfig <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">{</span> label<span class="token punctuation">:</span> <span class="token string">'序号'</span><span class="token punctuation">,</span> prop<span class="token punctuation">:</span> <span class="token string">'index'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> label<span class="token punctuation">:</span> <span class="token string">'物料编码'</span><span class="token punctuation">,</span> prop<span class="token punctuation">:</span> <span class="token string">'materialCode'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> label<span class="token punctuation">:</span> <span class="token string">'物料名称'</span><span class="token punctuation">,</span> prop<span class="token punctuation">:</span> <span class="token string">'materialName'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> label<span class="token punctuation">:</span> <span class="token string">'规格型号'</span><span class="token punctuation">,</span> prop<span class="token punctuation">:</span> <span class="token string">'specification'</span><span class="token punctuation">,</span> width<span class="token punctuation">:</span> <span class="token number">150</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token keyword">const</span> arrayData <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>materialCode<span class="token punctuation">:</span><span class="token number">10086</span><span class="token punctuation">,</span>materialName<span class="token punctuation">:</span><span class="token string">'篮球'</span><span class="token punctuation">,</span>specification<span class="token punctuation">:</span><span class="token string">'20*20*20'</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 使用</span><span class="token keyword">const</span> option<span class="token punctuation">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> any<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>option<span class="token punctuation">.</span>fileName <span class="token operator">=</span> <span class="token string">'文件名'</span>option<span class="token punctuation">.</span>datas <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        sheetData<span class="token punctuation">:</span> arrayData<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 数组数据</span>        sheetName<span class="token punctuation">:</span> <span class="token string">'表格名'</span><span class="token punctuation">,</span>        sheetFilter<span class="token punctuation">:</span> tableItemConfig<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token operator">></span> i<span class="token punctuation">.</span>prop<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 字段prop</span>        sheetHeader<span class="token punctuation">:</span> tableItemConfig<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token operator">></span> i<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 字段中文</span>        columnWidths<span class="token punctuation">:</span> tableItemConfig<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>width <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>width <span class="token operator">/</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 列宽</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token keyword">const</span> toExcel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExportJsonExcel</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span>toExcel<span class="token punctuation">.</span><span class="token function">saveExcel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、接口返回"><a href="#二、接口返回" class="headerlink" title="二、接口返回"></a>二、接口返回</h3><p>接口加工好返回，用a标签下载就行</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> downloadFile <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">:</span> any<span class="token punctuation">,</span> fileName<span class="token punctuation">:</span> any<span class="token punctuation">,</span> fileSuffix<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> fileTypeMime <span class="token operator">=</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// 文件 mime 类型，移动端必传，否则下载不成功；pc端可传可不传</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>    fileSuffix <span class="token comment" spellcheck="true">// 获取后缀对应的 mime</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">'png'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/png'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'doc'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/msword'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'docx'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.openxmlformats-officedocument.wordprocessingml.document'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'jpg'</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token string">'jpeg'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/jpeg'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'gif'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/gif'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'svg'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/svg+xml'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'tif'</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token string">'tiff'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/tiff'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'txt'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'text/plain'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'ppt'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.ms-powerpoint'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'pptx'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.openxmlformats-officedocument.presentationml.presentation'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'xls'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.ms-excel'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'xlsx'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'zip'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/zip'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'7z'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/x-7z-compressed'</span>      <span class="token keyword">break</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> blob <span class="token operator">=</span> window<span class="token punctuation">.</span>URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>    <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      type<span class="token punctuation">:</span> fileTypeMime<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span>  <span class="token keyword">const</span> link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>  link<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>  link<span class="token punctuation">.</span>href <span class="token operator">=</span> blob  link<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'download'</span><span class="token punctuation">,</span> fileName<span class="token punctuation">)</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span>  link<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//下载完成移除元素</span>  window<span class="token punctuation">.</span>URL<span class="token punctuation">.</span><span class="token function">revokeObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//释放掉 blob 对象</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//临时表数据下载</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">downloadFiles</span><span class="token punctuation">(</span>configCode<span class="token punctuation">:</span> string<span class="token punctuation">,</span> query<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`/wms/wms-account/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>configCode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/download`</span></span><span class="token punctuation">,</span>    method<span class="token punctuation">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>    params<span class="token punctuation">:</span> query<span class="token punctuation">,</span>    responseType<span class="token punctuation">:</span> <span class="token string">'blob'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> fileName <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">decodeURI</span><span class="token punctuation">(</span>      res<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'content-disposition'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>        res<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'content-disposition'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'filename='</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">9</span>      <span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">const</span> fileSuffix <span class="token operator">=</span> fileName<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>fileName<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fileName<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token function">downloadFile</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">,</span> fileName<span class="token punctuation">,</span> fileSuffix<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、WebWorker"><a href="#三、WebWorker" class="headerlink" title="三、WebWorker"></a>三、WebWorker</h3><p>​    其实第一种办法简单方便，试了下我三年前的联想轻薄本10w条数据用脚本开销1.5s-3s完全可以接受。如果数据量确实很大而且需要进一步处理比如日期或其他字段的format会增加开销可以试下WebWorker。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 RGB 整理</title>
      <link href="/2021/10/09/49.chang-yong-rgb-zheng-li/"/>
      <url>/2021/10/09/49.chang-yong-rgb-zheng-li/</url>
      
        <content type="html"><![CDATA[<p>常用护眼色代码与RGB值</p><p>常见的一些保护眼睛的颜色（可根据喜好设置）：</p><table><thead><tr><th><strong>颜色</strong></th><th><strong>代码</strong></th><th><strong>RGB值</strong></th></tr></thead><tbody><tr><td>银河白</td><td>#FFFFFF</td><td>RGB(255, 255, 255)</td></tr><tr><td>杏仁黄</td><td>#FAF9DE</td><td>RGB(250,249,222)</td></tr><tr><td>秋叶褐</td><td>#FFF2E2</td><td>RGB(255,242,226)</td></tr><tr><td>胭脂红</td><td>#FDE6E0</td><td>RGB(253,230,224)</td></tr><tr><td>青草绿</td><td>#E3EDCD</td><td>RGB(227,237,205)</td></tr><tr><td>海天蓝</td><td>#DCE2F1</td><td>RGB(220,226,241)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PS去水印</title>
      <link href="/2021/10/09/48.ps-qu-shui-yin/"/>
      <url>/2021/10/09/48.ps-qu-shui-yin/</url>
      
        <content type="html"><![CDATA[<p>在我们的日常工作当中，经常会遇到一些图片需要去水印，有时候还真是一件比较苦逼的事情；另外面对不同的图片水印，处理方法也不一样，下面就分享几种常见的去水印方法。</p><h2 id="一、仿制图章工具"><a href="#一、仿制图章工具" class="headerlink" title="一、仿制图章工具"></a>一、仿制图章工具</h2><p>选取仿制图章工具，按住Alt键，在无文字区域点击相似的色彩或图案，然后在有水印区域拖动鼠标覆盖有水印的区域；仿制图章工具的大小根据水印的大小去灵活设置，提高去水印效率。</p><h2 id="二、修补工具"><a href="#二、修补工具" class="headerlink" title="二、修补工具"></a>二、修补工具</h2><p>在使用修补工具前，首先要确定图片的背景色彩或图案较一致；具体操作为：先选取修补工具，然后要将去水印的区域用鼠标拖着圈住，开始向背景色彩相似的地方左移或右移修补，大道去水印的效果。</p><h2 id="三、复制叠加"><a href="#三、复制叠加" class="headerlink" title="三、复制叠加"></a>三、复制叠加</h2><p>当背景色彩或图案与要取水印的区域一致时，可采用此方法；首先用矩形工具框选一个选区；</p><p>然后Ctrl+J复制选取图层；</p><p>点击移动工具，开始向有水印的地方移动所选的区域，同时按住Alt键，就会不断重复复制图层，达到复制叠加的效果。</p><h2 id="四、污点修复画笔工具"><a href="#四、污点修复画笔工具" class="headerlink" title="四、污点修复画笔工具"></a>四、污点修复画笔工具</h2><p>点击污点修复画笔工具，根据图片水印或要处理的污点大小，适当选择修复工具大小，然后在图片水印处进行涂抹处理，达到去水印效果。</p><h2 id="五、背景色填充"><a href="#五、背景色填充" class="headerlink" title="五、背景色填充"></a>五、背景色填充</h2><p>此种方法适用于图片背景色与主体分明，要去除水印的地方与背景色彩或图案基本一致才能达到预期去水印效果；具体操作为：点击前景色或背景色，用吸管吸取图片背景色彩或图案颜色，设置颜色代码；</p><p>利用矩形选框工具框选水印区域，然后进行颜色填充覆盖水印区域。</p><h2 id="六、橡皮檫"><a href="#六、橡皮檫" class="headerlink" title="六、橡皮檫"></a>六、橡皮檫</h2><p>此种方法也是常用的，属于最简单的，就不详细介绍，适合图片背景是纯白色的。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项论文范文汇总（十大管理）</title>
      <link href="/2021/10/08/47.gao-xiang-lun-wen-fan-wen-hui-zong-shi-da-guan-li/"/>
      <url>/2021/10/08/47.gao-xiang-lun-wen-fan-wen-hui-zong-shi-da-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="一、整体管理"><a href="#一、整体管理" class="headerlink" title="一、整体管理"></a>一、整体管理</h2><p><strong>摘要</strong></p><p>2017年5月，我参加了XXX移动展示平台项目的开发，担任本项目的项目经理。 该项目投资800万，建设工期是一年，该项目展示平台定位XXXXXXXXXXXX服务平台， 该项目在2018年9月通过验收。本文结合作者的实践，以此项目为例， 讨论项目整体管理 ，包括制定项目章程、制定项目管理计划、指导和管理项目执行、监控项目工作、整体变更控制、结束项目。</p><p><strong>正文</strong></p><p>2017年5月，我担任了XXX移动展示平台项目的开发项目的项目经理。 该项目采用了Java语言开发，数据库采用oracle 10g，用到了中间件，采用架构，应用服务器采用了linux。本项目已于2018年9顺利通过验收，赢得了客户的好评。</p><p>由于本项目的顺利上线涉及到业务的考核，因此在本项目中，整体管理就显得尤为重要。这一点在于工期紧、业务复杂、范围涉及面广、项目干系人众多等特点于一身的XXX博物馆数字化移动展示平台项目中得到了充分验证。本文将讨论整体管理相关的问题。其一、制定项目章程;其二、制定项目管理计划;其三：指导和管理项目执行;其四：项目监控;其五：整体变更控制;其六：项目收尾。下面将分别从六个方面进行论述。</p><p><strong>制定项目章程</strong></p><p>项目章程是实施项目开发的前提和确定项目开发什么产品的依据，根据项目建设的需要，项目发起人发布了项目章程，正式宣布了项目的启动，章程指定我为项目经理，为我以后合理地运用各方面资源进行项目管理与建设提供了授权，由于项目的规模比较大、工期较紧，我们根据合同、项目工作说明书等过程资产确认了另外3名项目经理。我作为总经理统一协调。</p><p><strong>制定项目管理计划</strong></p><p>俗话说的好“磨刀不误砍柴工”，在实施项目开发之前，做好应有的准备工作是很有必要的。完备的计划是项目实施的根本前提。为此我组织召开了“项目工作计划的会议”，会议邀请了各团队的项目经理、业务专家和技术专家。</p><p>在制定范围控制管理计划进行WBS分解的时候，我发现由于涉及的人员较多，各人的知识水平也参差不齐，信息尚不够明确。因此我们决定采用滚动波式计划。对于即将开展的活动进行详细的分析和计划。对于后期的活动尽量粗略的估计，避免出现大范围的变更。</p><p>在制定进度控制计划的历时估算时，我有过许多类似管理的项目的经验。我采用基于公司项目历史绩效数据库，代码行(LOC)估算法和三点估算法相结合的估算方法。比如，在第一期建设中，调研分析，详细设计，试点运行几项任务。我们都可以查看公司的历史绩效数据库，对比以前开发过的类似项目，再结合个人经验进行估算，难度不大，而系统的研发，测试工期则不是很好把握。在估算时，我们采用分别估算系统的每个模块然后再汇总的方法。对每个模块的估算，我们使用代码行估算法和三点估算法相结合的方法，通过一个乐观估算A，一个悲观估算B和一个最可能估算M。三次估算后，利用PERT公式[(4M+A+B)/6]取整，最后得出项目研发测试大致需要11个月。</p><p>在制定质量控制管理计划的时候我们发现客户的有些要求与相关的法律法规相冲突。为此我及时通知了客户与客户进行了沟通，最后我们修改了相关的质量标准。使项目的质量得到了保证。</p><p>在制定人力资源计划的时候为了保证有充足的资源去完成项目。团队的所有项目经理、相关业务专家和技术专家经过讨论决定采用自下而上的方式进行估算，最后将所有的资源进行汇总。</p><p><strong>指导和管理项目执行</strong></p><p>“懂业务的不懂技术，懂技术的不懂业务”，在这种情况下项目的风险很大，一但开发人员没有理解业务去开发，将导致严重的返工，最终影响项目进度。因此在开发的时候我要求每个开发的具体功能必须要求项目经理组织相关干系人对开发人员进行交底，避免返工的发生。开发在这一阶段在每完成一个里程碑式的可交付物时我都会邀请客户来进行确认签字，保证了我们开发产品的有效性，减少了无谓的变更。</p><p><strong>监督和控制项目工作</strong></p><p>在项目执行的过程中总会遇到各种各样的问题。那么怎样才能预防和控制问题的发生呢？我以日志、周报及周例会的方式，随时了解项目进度，适时进行调整和动态控制。以项目进度开发表为依据，让每位项目组成员知道自己所承担的任务时间表，使其根据所承担的任务制定出自己的详细工作计划，并提交给俺老孙进行审阅。</p><p>日志是了解每个项目组成员工作情况的很好的方式，我要求每个项目组成员每周对自己的工作都要进行详细的记录，并提交给我，进行审阅，如果发现项目关键任务延期，或者在技术层面和业务层面出现一般性的开发难度，在询问清楚原因后，以“当周事当周清”的原则，我就会安排加班解决当日遗留问题，绝不将本周遗留问题拖至第二周解决。除非发生重大需求变更或遇到重大的开发技术难度时，才会延期进行解决。这样可以做到随时了解项目进度，随时解决项目中出现的问题。</p><p>每周末我会根据所有项目组成员在日志中体现出来的任务完成情况，后续开发计划和遇到的问题编写每周的周报，在下周一的早晨，以周例会形式向甲方的项目负责人进行汇报，并于甲方的项目负责人和该行业业务骨干人员对上周工作进行确认、总结，对上周工作的进展情况做出结论，并决定是否调整这周的进度计划。</p><p><strong>整体变更控制</strong></p><p>项目开发的过程中客户的需求经常会有变更。为了防止频繁的变更对项目进度等带来的不利影响。项目的初期我们成立了由客户方、开发方和监理方组成项目控制委员会CCB。客户或者开发方每个需要的变更都要经CCB的批准才能执行。当变更不可避免的时候，我们必须要严格的按照提交变更申请，变更影响分析，CCB审核，变更的执行，变更的验证，变更的发布的变更控制流程。</p><p><strong>项目收尾</strong></p><p>经过项目全体人员的共同努力，2018年10月顺利通过了专家组的验收，赢得了用户的好评。项目通过验收后，我们还专门组织全体团队成员召开了项目总结大会，对项目中取得的成绩予以肯定，分析总结项目建设过程中采用了哪些好的做法，仍存在的不足，对成绩优异的团队成员予以表彰，最后将项目总结会记录提交公司更新过程资产，为以后的项目建设收集宝贵的资料。同时我们还对项目实施了合同收尾，解决所有尚未了结的事项，进行项目结算关闭项目合同，确保建设方对软件产品满意，公司能够顺利地收到项目资金。</p><p>经过项目全体人员的共同努力，XXX博物馆数字化移动展示平台项目于2018年10月顺利通过了验收，赢得了专家组的好评。系统上线至今运行良好。回顾项目的整体管理工作的过程中，项目的成功从某方面得益于我成功的整体管理。在该项目的整体管理中，我总结出几点经验：</p><p>(1)认真的进行调研，充分的了解用户的需求以及项目涉及的范围;</p><p>(2)树立正确的思想，采取适合的方法，遵循一定的程序，严格的按照整体管理的要求编制管理计划、指导并监控项目工作，做好项目中的变更工作并做好收尾;</p><p>(3)建立问题管理机制，对各阶段的问题进行记录和跟踪，并将每个问题落实到具体负责人;</p><p>(4)建立变更管理机制，严格按照变更管理流程进行变更管理。一个成功而高效的项目开发必须要有一个能统筹管理和善于沟通的项目经理。特别是作为大型项目经理我们主要工作就是平衡各种资源的利用，使其达到最佳的效率。怎样才能达到这个最佳。这是我在今后的工作中需要长期实践和摸索的内容。</p><p>本项目的成功得益于我成功的整体管理。当然，在本项目中，还有一些不足之处，比如：在项目实施过程中，由于开发小组有1名成员因为自身原因突然离职，导致项目的团队建设出现了一下小问题。不过，经过我后期的纠偏，并没有对项目产生什么影响，在后续的学习和工作中，我将不断的充电学习，和同行进行交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的贡献。</p><h2 id="二、范围管理"><a href="#二、范围管理" class="headerlink" title="二、范围管理"></a>二、范围管理</h2><h3 id="2-1-范文一"><a href="#2-1-范文一" class="headerlink" title="2.1 范文一"></a>2.1 范文一</h3><p><strong>摘要</strong></p><p>在2017年2月，我参与了钦州市住房公积金管理中心“互联网+公积金”信息系统的建设，在项目中担任项目经理职务。该项目作为钦州市重大科技创新项目，受到了自治区住建厅及钦州市人民政府的高度重视。该系统是钦州市第一个入驻钦州市政务华为云的应用系统，应用服务器、数据库、存储设备全部部署在华为云。系统面向中心职工、缴存单位、缴存职工、开发商服务，总共包含了11个服务渠道、36个子系统模块，主要实现业务办理、信息查询、信息发布、互动交流等服务功能。总投资638万，项目工期为一年。建成后，广大群众纷纷表示公积金服务有了质的的提升，钦州公积金中心也因此收到上级表彰，单位绩效首次进入优秀行列。本文结合作者的经验就项目管理的需求管理和范围管理作了翔实的论述，并就项目过程中采取的措施、方法作了介绍。最后，列举了该项目范围管理的一些不足之处。</p><p><strong>正文</strong></p><p>一、项目概述</p><p>近年来，我国住房公积金规模快速增长，业务种类日趋丰富，缴存单位和缴存职工对住房公积金的服务的要求不断提高，钦州市公积金信息化服务工作滞后，业务办理渠道少、标准不统一、服务效率低等问题突出。国务院也大力推进网上政务服务，做到“最多跑一次”，争取做到“办事一次不用跑”。钦州市也成为了全国“智慧城市”试点城市，全面推广“互联网+行业”。为此，钦州市住房公积金管理中心“互联网+公积金”信息系统项目于2016年11月正式立项，12月先后通过了市发改委、市财政局的审批，并在2017年1月通过公开招标。我公司顺利中标，并委派我为该项目经理。</p><p>该项目总投资为838万，项目工期为一年。建设内容包括网站、个人网厅、单位网厅、开发商网厅、手机APP、短信、微信、微博、自助终端、热线电话、支付宝城市服务、微信城市服务等11个服务渠道、归集业务、提取业务、贷款业务、资金业务、稽核业务、办公OA、综合管理、安全保障、服务监管、住房资金管理、移动审批等等36个模块，基本覆盖公积金中心的所有业务。为此，我们组建了项目型组织的团体，包括项目经理1名，项目经理助理1名，系统架构师1名，系统设计师3名，网络工程师1人，程序开发工程师4名，实施工程师4名，数据分析师2名，测试工程师2名，安全工程师2名，质量保证人员（QA）2人，文档配置人员2人,共25人。其软硬件全部部署在华为云，为了安全，采取三层网络架构模式，分为核心层、业务层、缓冲层，每一层之间都部署有下一代防火墙设备。核心层主要是部署数据库服务器及网络存储设备，只允许业务层服务器访问，业务层主要是部署各模块服务器及接口服务器，缓冲层主要部署互联网服务器。服务器绝大多数是采用linux操作系统，有部分接口服务器使用windows，数据库采用的oracle，采用b/s模式，便于系统快速升级及部署。在大家的共同努力下，该项目于2018年2月按时完成，顺利通过专家组验收，在试运行阶段，收到了广大缴存职工的一致表扬，网上办理业务一下子提高到了70%以上，解决了职工排长队办理业务的老大难问题，中心全体职工表示非常满意，给公司发来了感谢信。</p><p>该项目涉及渠道多、模块多、干系人也多，如果不做好范围管理，极容易出现范围不明确，项目范围蔓延，进而影响工期，造成成本超支，甚至造成质量下降，偏离了原定项目目标，影响整个项目发展和团队成员的积极性。成功的项目范围管理不仅要让项目管理和执行人员知道为达到预期目标需要完成那些具体工作，还要确认项目相关各分在每项工作中清晰的分工界面和责任。详细的分工不但有利于项目实施中的变更管理和推进项目发展，减少责任不清的事情发生，也有利于项目结束和范围确认时能够清晰的判断范围是否完成。所以一定要按照范围管理的各个过程要求严格执行，防止出现需求没有经过评审就实施、需求反复无常、需求没人跟踪等现象出现。为此我在范围管理方面，按照制定范围管理计划、收集需求、定义范围、创建工作分解结构wbs、确认范围、控制范围。</p><p>一、合理规划项目范围管理</p><p>范围管理计划是项目管理计划中的子计划，它关注的是项目范围的管理。在本项目中，我们充分利用了以往项目的积累的组织过程资产-表格、模板、标准，通过组织专家和各项目成员开会的形式共同制定了适合本项目的范围管理计划。包括如何准备详细的范围说明书、如何创建wbs,如何对交互物进行确认，明确了范围控制中所要做的事项。主要原则包括：严格控制变更来源，对一般项目干系人提出的变更需求，应进行记录，但通常不当场解决；重要干系人提出来的需求，即使需要尽快答复，也要通过项目变更委员会讨论是否执行；需变更的事项，必须上报项目经理，不允许私自答应客户的变更；对于需要执行的变更要及时录入配置管理系统。有了范围管理计划，给项目的范围管理指明了方向，提供了方法。</p><p>二、采取不同的途径收集需求</p><p>收集需求是为了实现项目目的而确定、记录并管理干系人的需求和需求的过程。在调研需求过程中，我们依据干系人登记册，范围管理计划等，采用的访谈、会议和原型展示、群体创新技术、群体决策技术、问卷调查相结合的需求调研方法。将需求人员轮流派到各个业务科室进行跟班学习，与一些业务人员深入交流，了解他们业务流程、工作中存在的问题、以及对新系统的建议和意见，且结束后都要总结成调研报告给我，我会不定时组织系统分析人员开会，共同讨论及研究调研的情况，会后现成总的需求调研报告等需求文件，并制定需求跟踪矩阵，作为系统设计的依据，充分的需求收集为后续定义和管理项目范围奠定了基础。</p><p>三、定义范围，明确责任分工。</p><p>定义范围是制定项目和产品详细描述的过程，明确所收集的需求哪些将包含在项目范围内，哪些将排除在项目范围外，从而明确项目的边界。在范围定义时，依据项目范围管理计划、项目章程以及在收集需求中得到的需求文件、开展产品分析工作，通过产品分析确保交付产品与需求中所设定的一致。只有定义范围做好了，才不出现范围蔓延的情况。项目组通过聘请及召集了项目相关方开研讨会等形式，对项目范围做了更进一步的明确，最后制定了项目范围说明书，并得到了甲方负责人及分管领导的认可。项目不断推进，会产生更多的需求，做好项目范围的定义保证项目做的是项目内的工作，防止责任不清。</p><p>四、创建工作分解结构，落实责任到每个人身上</p><p>创建工作分解结构是面向可交付物层次的分解，详细描述了项目所要完成的工作。Wbs的最低层元素是能够被评估、安排进度及被跟踪的。它是组织管理工作的主要依据。我们借鉴了以往同类项目的工作分解模板，并结合当前项目做了改进，考虑到项目要实现的功能比较多，对分解的详细程度，制订了一套分解技术。在各层次上都保证项目的完整性；一个动作单元只从属于一个上层工作单元；相同层次的工作包应有相同的性质；工作单元应便于进行进度和成本的控制；工作包一般不大于80小时；采用滚动规划，不求一次把所有工作包都分解出来。据此我们的wbs分成四层，第一层是按照子系统及服务渠道来划分，包括了多个子系统及多个服务渠道；第二层是按定义需求、设计、编码、测试、验收等生命周期来划分的；第三层是对第二层的进一步细化，比如定义需求又分为需求调研、需求分析、需求定义、需求验证等；第四层是对第三层的进一步细分，比如需求调研又分成客户现场访谈、会议、建立模型等。对于wbs中工作单元的细节信息，我们在wbs字典中加以描述。Wbs分解是一项很重要的工作，在这个过程中我们发现《项目范围说明书》中存在的几处不明确的内容，通过wbs分解而得到明确。Wbs分解工作完成后，项目基准也就随之确定了。</p><p>五、确认范围</p><p>确认范围是项目干系人正式验收已完成的项目可交付成果的过程，通过确认范围过程，使验收过程具有客观性，同时用过验收每个可交付成果，提高最终项目产品获得验收的可能性。项目可交付成果、子功能被开发处理之后，我们项目组内部先对其进行了评审和测试，通过后，把这些成果交付给用户，和用户一起按需求跟踪矩阵、质量标准等要求进行确认范围。由于该项目范围广、功能点多，我们找客户进行局部确认范围的频次较高，在里程碑点一般举行较为正式的会议，非里程碑点一遍通过当面交流的方式，虽然这样做增加了不少工作量，但对于最后一次性通过竣工验收非常有利。在确认范围时，对于局部确认范围，我们主要是邀请客户方参与评审和测试；对于不满足的需求，根据实际情况推荐纠正措施或提出变更申请，在修改完成后统一要进行回归测试。对于全局确认范围，主要是由客户方邀请的第三方进行评审。</p><p>六、控制范围</p><p>范围控制的核心是范围的变更控制，即影响发生变更的因素，保证所有被请求的变更按照项目整体变更控制处理，并对范围实际变更时进行管理。为此我们将引起范围变更的因素分为五类：一是客户对项目、项目产品或服务的要求发生变化；二是项目外部环境发生变化；三是项目范围计划的编制不周密、不详细有遗漏或错误；四是项目实施组织本身发生变化；五是市场上出现或设计人员提出了新技术、新手段或新方案。为这五中范围变更的因素都准备了相应的预案，以应对变更。</p><p>通过需求跟踪矩阵、需求文件，对范围进行偏差分析，确保已通过范围变更请求得到处理，在本项目管理过程中，我们经历了多次范围变更的处理，比如涉及展现数据的种类和方式，之前在详细的范围说明书中我们确定信息推送主要是通过短信渠道，但客户提出应该增加手机APP、微信公众号渠道，对于这个范围的变更，评估了项目的影响，主要是进度和成本方面，经过ccb评审通过后，对进度计划和成本计划进行了相应的调整，后续工作按修改后的计划进行。项目张有一些需求如图表展现样式、查询交互方式，我们维持了原有的实现方式，事实证明，我们的设计符合大多数人的视觉美感好操作习惯，因此避免了不必要的变更。</p><p>由于在项目过程中进行了有效的范围管理，经过各方一年的努力，项目最终顺利通过验收，如期成功上线，项目各项功能运行良好，得到各方的一致认可，我也通过本项目积累了丰富的经验。但由于项目的复杂性和独特性，本项目在执行过程中也有不足之处。</p><p>如在项目之处范围变更的控制管理及审批过程不够明确。范围变更没有进行有效的控制。解决方案为对项目组成员进行变更控制管理的培训，学习变更控制系统及审批流程。通过培训，使项目成员以项目范围基准为衡量标准，超出范围外的要求按流程提交申请。避免了未审批就执行的现象发生。其次，建立了变更控制办公室。经批准后方可执行。通过审批流程的学习和项目变更控制办公室的建立，提高了对变更的有效管理，为项目顺利验收奠定了基础。</p><p>范围作为衡量项目是否成功的重要维度，为使项目成功，有效的范围管理至关重要，他有助于降低成本，保证进度，是一个成功项目必不可少的一环。项目范围管理方式多样，对于具体项目应该认真分析项目的特点，寻找适合项目管理方法。在今后的工作中，我将进一步加强项目管理知识理论学习，认真分析自身不足，查找原因，努力改进，更好的服务于项目管理工作。</p><h3 id="2-2-范文二"><a href="#2-2-范文二" class="headerlink" title="2.2 范文二"></a>2.2 范文二</h3><p><strong>摘要</strong></p><p>2015年10月，我作为项目项目经理参与了某省某设备集团有限公司信息综合应用平台建设项目，该项目总投资800万人民币，建设工期为14个月，该项目包含了领导驾驶舱、人力资源管理子系统、固定资产管理子系统、财务辅助角色系统，物资辅助决策系统、文件管理系统，由于该集团公司刚完成园区迁移，涉及到较多方面的工作，给项目的建设带来不少麻烦，但是在我和我的团队的努力下，该项目与2016年12月通过了业主方的验收，赢得了用户的好评。本文将结合作者的实际经验，讨论信息系统项目建设过程中范围管理的重要性，主要从一下几个方面进行阐述：范围管理计划的编制，范围定义，创建工作分解结构，范围确认和范围控制。（好像少了一个收集需求）</p><p><strong>正文</strong></p><p>2015年10月，我作为项目经理参加了某省某设备集团有限公司集团网建设与信息综合应用平台建设项目，该项目总投资800万人民币，建设工期14个月，通过该项目的建设，为该集团公司搭建起了战略和执行之间桥梁，已超强的执行力保证战略目标得以快速实现，实现了管理从艺术到科学的进化，以科学的管理体系而非个人能力来驾驭相关组织，也让管理变的简单而高效，以简单致胜的思想来解决管理上的根本问题。该系统为领导办公决策提供了基础数据支撑，为集团工作流程的管理提供了依据，平台通过信息传递，使企业领导层得以在第一时间批阅各式文件，调阅最新的动态数据，监督计划执行、项目进展，并依据此下达决策和指令；为目标管理和项目管理提供了工具，企业的工作能力和工作效率与进展紧密相关，管理良好的企业需要有其定义完善的关键业务流程，来促使业务条理清晰的进行，平台提供了项目协作功能，可以随时了解项目进展和各协作部门的进度及状况； 提高了各成员单位的信息化水平，加速了知识型企业的转型，文件管理把分散在员工手中，或者散落在各单位对企业员工功过有帮助的信息资料、方法和理论知识等分类沉淀在系统中，供给所有员工共享使用，也可以设定角色来控制权限。该系统采用了JAVA语言开发，数据库采用Oracle 11g，服务器为IBM 3850 X5，操作系统为Windows Server2008R2，利用B/S架构，采用 weblogic 11g。</p><p>由于本项目的顺利上线设计到业务的考核，因此，在本项目中，系统的范围管理尤为重要，在本项目中，我作为项目经理除了对其余领域进行克制恪守的管理外，特别对范围管理从如下几个方面进行了管理。</p><p>一、制定范围管理计划</p><p>作为一名合格的管理制，做任何事情之前都应该事先做好计划，好的计划，是成功实施项目的基础，有些人认为为做项目范围计划而花费太多的时间，不如把他们用于执行的工作上，项目将会更好更快的完成，我认为这是一个错误的理解，通过省略范围管理计划制定，虽然在短时间内能够节约一定的时间，但从长期来看，常常会因为缺乏管理计划的指导而使得范围定义不清，导致范围蔓延，以至于项目无法按时完工。</p><p>因此，在该项目汇总，我非常的重视项目范围管理计划的制定，在正式做计划之前，我先查找了公司<strong>组织过程资产</strong>，找出制定范围管理计划的模板，再结合以往的项目经验，制定了一份初步的<strong>项目管理计划</strong>，然后再召集项目团队成员进行讨论修改完善，最后在全员的参与下，最终完成了一份详细的、科学地范围管理计划，用于知道项目如何定义、分解以及核实和控制范围。</p><p>二、范围定义</p><p>一个成功项目，应该做且只做成功完成该项目所必须的工作，为了保证这一点，就需要在项目前期明确项目的范围。在项目的早期阶段，我带领我的项目团队，到了客户现场收集需要，我组织了客户的运营部门、质量管理部门、IT部门以及我的需求团队，召开了需要讨论会，共同商讨项目范围（<strong>引导式研讨会</strong>）。在收集需求的时候，客户有时候对需要描述的不是很清楚，造成了双方对需要的理解有歧义，甚至有时候客户自己对其需求也不是很清楚，只有一个模糊的概念，针对这种情况，我采用了<strong>原型法</strong>将收集到的需要做成了模型，然后供给客户参考确认（<strong>原型法是收集需求里的</strong>），以此来消除彼此之间的歧义，充分挖掘客户的需求，并基于团队自身的经验对客户进行引导、细化，将其模糊的概念明确化。</p><p>三、创建工作分解结构</p><p>基于项目范围说明书，我和我的团队成员开始对项目范围进行分解，以形成该项目的WBS，在分解过程，我按照以下原则进行分解：</p><p>在各层次上保持项目的完整性，我将该项目设计的需求调研、系统设计、开发、测试等完整的模块都一一列出，避免遗漏必要的组成部分。</p><p>一个工作单元只属于上层单元。比如对于该项目的数据库设计，我就只将其归入系统设计单元中，避免出现交叉从属问题。</p><p>相同层次的工作单元应具有相同的性质，比如我在创建WBS的时候，会把设计类的工作比如原型设计、数据库设计等放在同一层的。</p><p>工作包按照8/80原则进行分解，并制定具体的负责人，同时制作WBS字典，对工作包做具体描述。</p><p>工作单元应该能分开不同的责任人和不同的工作内容，对于项目中的每一个工作包，我都指定了唯一的负责人和起负责的内容。</p><p>便于项目管理进行计划和控制的管理需要，对于该项目的每一个工作包，我都对其进行编号，并与组织机构图和成本控制点深度融合，便于日后的管理。</p><p>四、范围确认</p><p>范围确认并不是一件容易的事情，在与客户的沟通上，我们希望客户能够尽快确认以便我们尽快展开后续的工作，而客户可能认为自己并没有看到什么具体的系统，无法确认，针对这种情况，我们在提交相关文档给客户相关干系人以后，重点对客户的IT部门人员进行沟通培训，详细介绍系统的设计，然后通过他们再去和客户的业务部门沟通，这样即有利于专业技术人员之间的沟通，也有益于客户内部业务人员对系统范围的认可，同时在与客户的业务部门沟通的时候，我重点强调范围确认虽然是正式的，但是也并不意味着范围就是铁板一块，不能再做修改的，只需要走标准的变更流程，只需要CCB审批通过，都可以进行变更，这样就消除了客户的顾虑，便于快速、高效的完成范围确认。</p><p>五、范围控制</p><p>范围控制就是在监督项目的范围状态，管理范围基础变更的过程，因此在项目中， 我定期组织相关项目干系人召开项目状态审查会，审查项目的范围，通过对照项目范围说明书，查找范围偏差，并作出分析，严格杜绝一切项目蔓延，对已经发生的蔓延进行纠偏。例如在一次项目审查会上，我发现系统管理功能中增加了登录情况分析在线时长的分析功能，在查阅了系统变更记录之后，我并没有发现有类似的变更记录，于是我对照责任矩阵，找到了负责这个模块开发的负责人员A，A告诉我说增加这个功能是因为甲方信息中心的主任提出的，他觉得这个功能比较简单，于是就直接给添加上了，针对这个事情，我首先强调了范围基准，以及变更流程的重要性，然后针对这个功能，我要求相关人员提交了正式的变更，走正常的变更流程。</p><p>作为项目经理的我深知，项目的范围不是一经确认就不可以更改的，项目干系人处于项目利益以及各种情况考虑， 总会有一些需求变更，管理这些变更，就需要我在对项目进行规划的时候，就制定好变更控制流程，以及成立一个变更控制委员会，因此我的团队很早就制订了变更控制流程：1、提交变更申请，2、变更的影响分析，3、提交CCB审批，4、变更实施，5、通知相关项目干系人，6、跟踪变更对系统的影响。有了这些流程和CCB的控制，使得项目需求变更得以良性发展。</p><p>经过我们团队14个月的努力，本项目终于在2016年12月，通过了业主方的组织的验收，达到了项目的预期的目的，得到了业主的一致好评，本项目的成功得益于我成功的范围管理。当然在本项目中也还是有一些小小的不足，由于项目组中有两名成员因为自身的原因突然离职，导致项目的团队建设出现了一些小问题，不过由于从一开始就设置了AB角，所以并没有造成特别严重的后果，经过后期的纠偏，并没有对项目产生影响，在以后的学习和工作中，我将不断的充电和学习，和同行进行交流，提升自己的业务和管理水平，力争为我国的信息化建设做出自己的努力。</p><h3 id="2-3-范文三"><a href="#2-3-范文三" class="headerlink" title="2.3 范文三"></a>2.3 范文三</h3><p><strong>摘要</strong>：</p><p>2017年3月本人参与了某软件科技有限公司的一个地税项目，此项目为某地方税务局安全管控系统，包含了基于B/S架构的四个子系统和C/S架构的客户端，其中子系统分别为权限系统，资产系统，安全管理系统和终端防护系统，而客户端需要安装于每一台用于税务局内网的所有操作系统中，以便于对所有地税办公的PC机器进行全面的管控。我在这个历时一年半的中大型项目中担任项目经理一职。2018年9月，该项目顺利通过了甲方的验收，获得一致好评。本文以此项目为例，结合本人的实际经验，讨论了项目范围管理在项目建设中的重要性，论述了编制范围管理计划、范围定义、创建工作分解结构、范围确认和范围控制等过程对范围管理工作的积极意义。</p><p><strong>正文</strong>：</p><p>随着社会的不断进步，信息化及信息化管理成为现代社会的主流，但也面临着安全方面的隐患，基于信息的安全性问题，让我司与某地方税务局有了合作的机会，此项目为期一年半，13个市，106个县级单位，分别安装了服务端，客户端数量超2万个，收到地方税务局领导的高度重视，所以范围管理就显得尤为重要。由于项目业务复杂，范围涉及面广，项目干系人众多等特点，因此良好的范围管理是保证项目按要求完成的重要保障。项目范围管理是指对项目包括什么与不包括什么进行定义并控制的过程，这个过程用于确保项目组和项目干系人对作为项目结果的项目产品，以及生产这些产品所用到的过程有一个共同的理解，做好范围管理，对明确需求，管理好需求变更有着重要的意义。本文结合作者的实际，分别从范围规划、范围定义、创建WBS、范围确认、范围控制方面进行了论述。</p><p>一、制定范围管理计划。项目是计划出来的，因此，在做任何事情之前必然先计划后为之，制定出好计划，是成功实施项目的基础，有些人认为做项目范围计划是在浪费时间，不如把他们用来执行工作，项目将会更快，更好地完成。我认为这个想法是错误的，通过省略范围管理计划制定，虽然能短暂时间内节省一定的时间，但是长期内常常会因为缺乏管理计划指导而使范围定义不清，范围蔓延，以至于无法完成项目。因此，我在该项目中，特别注重项目的范围管理计划的制定，在正式制定计划之前，我先查找了公司<strong>组织过程资产</strong>，找出制定范围管理计划的模板，再结合公司以往的项目管理的经验，制定出一份初步的范围计划，然后召集项目组成员和项目干系人，对计划进行修改和完善，在全体参与下，最终完成了一份详细、科学的管理计划，用于指导项目如何定义、分解以及核实和控制范围。</p><p>二、范围定义。懂技术的不懂业务，懂业务的不懂技术，因此，只有将需求搞清楚，才能从业务到需求进行准确的表述和形成可靠的依据，一个成功的项目，应该做且只做成功完成项目所需的全部工作，为了这一点，就需要在项目前期制定一个明确的项目范围，在项目的早期阶段，我带领我的团队，进驻到客户现场进行研讨，查看了他们的业务手册，现场观摩了业务操作，进行了业务交流，但是由于对信息化的认知不同，有的客户对需求描述不是很清楚，造成了双方对需求的理解有歧义，有的干系人甚至对自己的需求都不清楚，只有一个模糊的概念，针对这些现象，我采用<strong>原型法</strong>，根据已获取的需求，再加上以往项目的成果，定制了一个产品demo，演示已获得的需求功能。在客户和团队的共同努力下，终于完成了项目的范围定义工作，通过初步的项目范围说明书，我们和甲方的相关负责人开展了<strong>引导式研讨会</strong>。在会议上，我作为项目经理，向项目干系人，就项目的目标、范围、范围管理计划及各部门需要的模块进行集中的讨论与定义，最终<strong>形成了详细的范围说明书</strong>，并双方签字认可。</p><p>三、创建WBS。只有将项目分解，才可以进行分工，才可以进行绩效考核。因此，我根据项目目标，制作出了工作分解结构，利用公司在其他项目上整理出的WBS模板，结合我们在需求分析阶段的体会，我召集公司相关领域的专家和所有的项目干系人，开了一个研讨会，最终决定把项目的可交付物作为WBS分解结构的第一层内容，按照项目功能的模块划分工作组，参照8/80小时原则，以一个较粗的力度进行项目的控制，具体活动的控制权下放到工作组的组长手上，充分放权，调用他们的积极性，同时，有些模块功能复杂，需要分解更多层才能达到工作包的层次，因此我采用滚动式计划的方法，将近期需要完成的工作分的细一点，远期的工作相对分的粗一些。例如，在数据机房综合布线某块，我们将程序开发设计作为近期要完成的功能，综合布线工作作为远期的工作，最后我们将<strong>项目的范围说明书</strong>，WBS和WBS词典装订成册，形成项目范围管理基线。</p><p>四、范围确认。范围确认是项目干系人正式接受已完成项目的交付物，项目范围确认是很困难的事情，客户总是认为什么都没有看到，怎么能进行确认呢，出现客户范围确认不配合的情况。而我们希望客户尽快确认，以便于开展下面的工作，我们通过和客户进行很好的沟通，尤其是和监管中心机房主任多次沟通，告诉他们虽然项目范围确认是正式的，但这并不意味着项目的范围就一成不变，不能再修改了，只是无论是现在更改范围还是将来要更改范围，都会引起项目的时间、进度和资源的变化，为了防止客户认为自己什么也没有看到这种情况，范围确认始终贯穿项目始终。在WBS确定后，我建立了多个里程碑，每一个里程碑都是重要的节点，我邀请项目干系人参加阶段评审会，重点对客户一线操作人员进行沟通和讲解，详细介绍系统的设计原理，让他们站在使用者角度思考问题，然后向甲方业务部门作出需求讲解，这样既有利于专业人员之间的沟通，也有利于客户业务部门对系统范围的认可和信任，虽然变更不可避免，但是，只要按照变更流程走，且审批通过，都可以进行变更，这样就消除了客户的顾虑，便于快速、高效地完成项目确认。</p><p>五、范围控制。范围控制就是监督项目范围状态，管理范围基础变更的过程，因此，在项目中，我定期召开项目状态评审会，审查项目的范围，找出项目偏差，并做分析，严格杜绝一切的范围蔓延及镀金。了，例如，在一次阶段评审会议上，我发现项目某个功能模块中，程序员正在加载一个语音识别算法，但是这个在合同中根本没有，我又查询了项目的系统变更日志，未找到类似的变更记录，于是便问清缘由，原来是甲方机房主任提出的需求，没有经过变更，直接跟我们的程序员提出的需求，这个根本不符合变更流程，于是，我找到了甲方的机房主任，并提出了异议，并说明这样会影响项目的进度，经过和甲方机房主任的商量，决定将次需求作为补充，走变更流程，在二期开发中进行实现，经过事后，我开会专门强调了变更控制的重要性，需求变更一定要走流程，一定要进行分析，审核，批次才可以，不能擅自改动。</p><p>经过我们团队不懈努力，历时18个月，本项目终于于2018年9月份通过了监管中心组织的第三方专家验收，实现了地方税务局全面管控的目标。本项目的成果，得益于我对项目中的范围管理，当然，在本项目中可能还有一些不足之处，比如，在实施项目中，由于连续大雨，客户机比预定的晚到了两天，导致进度有小的影响，不过，经过我的后期纠偏，并没有对项目产生影响。在后续的工作和学习中，我将不断地充电学习，和同行交流，提升自己的业务和管理水平，不断进步。</p><h3 id="2-4-范文四"><a href="#2-4-范文四" class="headerlink" title="2.4 范文四"></a>2.4 范文四</h3><p><strong>摘要</strong></p><p>2017年3月至2018年3月，我作为项目经理参与了xx银行管理会计系统(SCM)项目的建设。项目金额600万元，工期12个月，要求以金融核算业务为主线，建设与业务相适应的新一代管理会计系统。</p><p>由于本项目具有与多个系统集成、需求不尽相同的特点，因此范围管理对项目的成功至关重要。本文结合作者实践，运用科学管理知识，集思广益，合理规划范围管理;使用访谈和原型法，准确获取用户需求;使用产品分析技术，清晰定义项目范围;滚动规划，为项目范围建立WBS视图;通过群体决策技术，及时与客户确认项目成果，有效降低项目风险;持续监控项目范围状态，维护范围基准，杜绝范围蔓延。由此，我深刻体会到范围管理在项目管理过程中的重要地位。</p><p><strong>正文</strong></p><p>随着xx银行提出按照”三个标准”(标准流程、标准数据、标准财务语言)与”三个集中”(集中核算、集中预算、集中支付)的原则，实现财务工作在统一规范、信息准确、风险控制、高效运作、管理提升方面的实质改进，甲方现有管理会计系统已经难以满足信息收集、信息处理与会计核算等方面的要求。基于甲方业务的统一规划，我公司于2017年3月承建了xx银行管理会计系统(SCM)项目的建设，要求以金融核算业务为主线，建设与业务相适应的新一代管理会计系统，项目金额600万元，工期12个月，涵盖企业报表、总账、报销管理、固定资产、费用预算、增值税管理6个模块，涉及信息部、财务部等6个业务部门、9家集成供应商等众多干系人，还涉及与甲方的中间业务平台、主数据(MDM))、ERP等9个管理系统进行集成，形成一体化平台。系统采用B/S架构，开发语言为JAVA，数据库使用MYSQL。我作为承建方项目经理，全面负责项目管理工作。我的团队成员包括需求分析3人、开发8人、测试4人、实施3人，质量保证1人。</p><p>本项目的特点是∶</p><p>1.需集成系统较多，需要与甲方、各系统集成供应商保持紧密联系，完成系统集成开发和联调任务;</p><p>2.涉及用户范围广，业务关系复杂，需求也不尽相同。基于以上项目特点，我认为范围管理对本项目的成功至关重要。</p><p>项目范围管理是确保项目做且只做所需的全部工作，以成功完成项目。范围管理过程包括∶</p><p>1.<strong>规划范围管理，依据项目章程，使用专题会技术，编制《范围管理计划》和《需求管理计划》</strong>;</p><p>2.<strong>收集需求，依据需求管理计划，使用访谈和原型法，编制《需求说明书》</strong>;</p><p>3.<strong>定义范围，依据需求说明书，使用产品分析技术，定义范围边界，制定《项目范围说明书》</strong>;</p><p>4.<strong>创建WBS，依据项目范围说明书，使用滚动式规划，将可交付成果分解成易于管理的工作包，创建WBS和WBS词典</strong>;</p><p>5.<strong>确认范围，依据项目管理计划，使用检查和群体决策技术，获得客户对可交付成果的正式验收</strong>;</p><p>6.<strong>控制范围，依据项目管理计划，使用偏差分析技术，维护范围基准，杜绝范围蔓延</strong>。</p><p>下面阐述本项目的管理实践。</p><p>1.集思广益，合理规划范围管理。</p><p>凡事预则立，不预则废，好的计划为有效管理项目范围提供指南。在SCM项目初期，我召开专题会，与团队成员、甲方各业务部门负责人、集成供应商一起充分讨论项目中的范围管理过程，定义了交付物验收流程、WBS分解方式、收集需求所采用的方法等内容。根据会议结果，我编制了《xx银行SCM项目范围管理计划》和《xx银行SCM项目需求管理计划》并通过评审。</p><p>2.善于引导，加强互动，获取用户明确需求。</p><p>明确且无歧义的需求是项目建设的基础。在SCM项目中，我带领团队通过用户访谈等方式，开展需求收集与分析工作。通过访谈，我发现甲方领导非常关注SCM系统与9个管理系统集成，形成一体化平台，但在如何集成才能满足需求方面，具有很多不确定性。为此，我带领团队与各集成供应商一起，使用原型法搭建Demo演示环境，模拟用户集成操作场景，与用户一起找到真正痛点，提炼用户实际需求，整理后形成《xx银行SCM项目需求说明书》并通过评审。</p><p>3.详细描述项目产品，清晰定义项目边界。</p><p>只有清晰定义项目边界，才能有效管理范围。我带领项目团队，依据《需求说明书》和搭建好的Demo原型，使用产品分析技术，模拟生产环境进行工作，进一步将用户需求转换为系统所需功能，定义出系统业务方案。另外，我们对SCM系统不实现哪些功能、不提交哪些文档也进行了明确说明。我将上述内容记录到《xx银行SCM项目范围说明书》中，甲方项目经理和分管领导进行了签字确认。4.滚动规划，渐进明细，灵活分解WBS。</p><p>只有将目标进行分解，才能进行有效的管理。在SCM项目中，我带领项目团队首先确定WBS基于可交付物进行分解，采用4层架构，之后采用分解技术，将SCM系统6个主模块作为第1层，22个业务模块作为第2层，业务模块的各个子功能作为第3层，第4层则是对第3层的进一步细分。期间使用滚动式规划的方法，将近期需要完成的工作(如主数据管理、档案管理)分解的细一些，远期的工作(如审批流、人员库)分解的粗一些。最后，我们将项目的范围说明书、WBS和WBS词典提交评审，通过后正式发布，形成项目范围基准。5.及时确认阶段成果，有效降低项目风险。</p><p>范围确认是项目干系人正式接受已完成项目交付物的过程，对于降低项目风险，确保项目受控有着重要作用。在SCM项目中，我使用检查和群体决策技术，在每个阶段结束时与相关干系人召开阶段评审会，各方共同对本阶段的工作内容和交付物进行评审，并对关键文档进行确认定版，评审过程产生的意见都会形成正式书面记录，并请甲方项目经理签字确认，最终完成本阶段的验收工作。6.持续监控项目范围，杜绝范围蔓延。</p><p>要有效控制项目范围，就需要持续监督，及时发现、处理偏差，维护范围基准，杜绝范围蔓延。SCM项目进入测试阶段后，科技部主任提出，由于业务原因，需要将原本部署在小型机中的SCM系统迁移到新搭建的虚拟集群上。我将此需求己录为变更请求，并召集团队使用偏差分析技术，全面评估变更影响。借助需求追踪矩阵，我们确定迁移工作不在范围基准内，而实现此需求需要增加5个人天的工作量。虽然可以将工作安排在非关键路径上，不会影响总体进度，但成本增加不可避免。基于分析结果，我制定了变更方案，通过论证后提交CCB审批。审批通过后，公司与客户签署了补充协议，我更新了项目基准和项目计划，项目得以顺利进行。</p><p>最终，SCM项目于2017年12月按期上线，2018年3月终验，甲方领导特意发来感谢信，对我方的工作予以肯定。项目的成功在很大程度上得益于我进行了有效的项目范围管理。回顾项目，我深刻体会到，要想有效管理项目范围，应该做到∶①集思广益，合理规划范围管理;②使用访谈和原型法，准确定义用户需求;③使用产品分析技术，清晰定义项目范围;④滚动规划，灵活分解，为项目范围建立WBS视图;⑤及时与客户确认项目成果，有效降低项目风险;⑥持续监控项目范围，维护范围基准，杜绝范围蔓延。只有全局审视项目，综合考虑各方面因素，才是项目成功的法宝，这也是我需要不断学习和实践的地方。</p><h2 id="三、进度管理"><a href="#三、进度管理" class="headerlink" title="三、进度管理"></a>三、进度管理</h2><h3 id="3-1-范文一"><a href="#3-1-范文一" class="headerlink" title="3.1 范文一"></a>3.1 范文一</h3><p><strong>摘要：</strong></p><p>2018年8月，我作为项目经理，参与了xx省某沿海城市港口散货码头信息化系统项目的建设工作，该项目总投资890万，建设工期为1年。通过该项目的建设，实现了港口现场管理信息化的扩展，提高了港口装卸效率，减少了工作中人为因素的影响，各部门之间步调一致，简化了工作程序。在充分调研国内外散杂货理货业务最新作业模式的基础上，结合港口的实际情况，实现码头现场电子理货生产作业。该项目于2019年9月，通过了业主方的验收，赢得了用户的好评。本文结合作者的实际经验，以该项目为例，讨论了信息系统项目建设过程中的进度管理，主要从如下几个方面进行了阐述∶规划进度管理、定义活动、排列活动顺序、估算活动资源、估算活动持续时间、制定进度计划、控制进度。</p><p><strong>正文∶</strong></p><p>2018年8月，我作为项目经理，参与了国内某港口散货码头信息化系统项目的建设工作，该项目总投资890万，建设工期为1年。通过该项目的建设，实现了港口现场管理信息化的扩展，提高了港口装卸效率，减少了工作中人为因素的影响，各部门之间步调一致，简化了工作程序。在充分调研国内外散杂货理货业务最新作业模式的基础上，结合港口的实际情况，实现码头现场电子理货生产作业。该项目建设分三部分∶散货装卸管理系统改造部分、无线理货系统部分、其他部分。散货装卸管理系统包括调度管理，商务管理，理货管理，库场港存管理，统计系统等几个主要模块，负责装卸现场的作业计划，调度，管理，统计分析等工作;无线理货系统部分是这次项目建设的主要工作，实现模式∶电子理货系统通过中间层服务，获取作业任务和配工调度信息，并以内存数据库形式存储。现场使用手持终端，完成现场的业务操作，通过多线程运行，利用4G网络(未来支持扩展5G网络)自动上传到电子理货中间层，同时将理货指令中行驶指示传递到倒运车辆GPS终端设备，指示倒运司机前往指定目的地，并且同步其他相关指令到理货其他环节如计量、外理等系统中并执行指令完整性校验;其他部分包括计量系统及各系统之间接口等，根据理货指令，独立执行计量后信息自动传送到中间服务层。</p><p>由于该项目的顺利上线涉及到业务考核，因此，在本项目组中进度管理尤为重要，在本项目中，我作为项目经理除了对其余管理领域进行克制恪守的管理外，特别对进度管理从如下几个方面进行了管理。</p><p><strong>一、规划进度管理</strong></p><p>作为项目经理的我深知规划进度管理的重要性，在项目初期，我和我的团队，通过现场走访港口的装卸人员，了解了他们对该信息系统的一些看法，并多次召集甲方的IT 部门，监控部门，现场调度部门的主要负责人及管理人员一起，通过会议、专家判断，制定了进度管理计划，进度管理计划规定了该项目进度的模型、准确度、计量单位等。保证了实施过程中的进度控制。</p><p><strong>二、定义活动</strong></p><p>定义活动是为识别和记录为完成项目可交付成果而采取的具体行动的过程。在进度管理计划、范围基准的指导下，开始着手定义活动。我和项目组成员，本着谁负责谁分解的原则，对 WBS 项目近期要完成的工作进行分解，得到可以具体要完成的活动，然后汇总成文档，即活动清单。采用滚动式规划的方法，随着项目的进展，项目活动清单也逐步清晰完善。</p><p><strong>三、排列活动顺序</strong></p><p>有了活动清单，通过紧前关系绘图法，确定依赖关系，提前量与滞后量等工具与技术，制定出了项目进度网络图。在这一过程中最关键的就是确定各个活动之间的相互关系，能并列的则并列，不能并列的要确定活动之间前后依赖关系和约束关系，有了合理的活动网络图，才能制定出合理的进度计划。例如，在本项目中，无线理货系统 WEB部分与GPS终端部分的模块小组所进行的活动既相互独立有相互依赖，因而可以并行进行，但在某些时间点上又存在约束关系，一些在手机上实现的功能要等 WEB系统完成后才能进行，我们经过几次反复调整之后才得到较为合理的网络图。</p><p><strong>四、估算活动资源</strong></p><p>估算活动资源是估算执行各项活动所需材料、人员、设备或用品的种类或数量的过程我们主要是通过专家判断和历史项目类比的方法进行的。对于活动清单中的活动，我们组织项目组内有经验的人员参考公司以往项目的数据，先对其工作量进行估算，再根据总工期依据项目网络图中的相互依赖关系，并考虑风险因素，倒推出活动需要的时间，再根据人员的劳动生产率，计算出活动需要的资源数量。</p><p><strong>五、估算活动持续时间</strong></p><p>估算活动持续时间是根据资源估算的结果，估算完成单项活动所需的工期。根据我们项目实践经验，它与活动资源估算常常是结合在一起进行的，在进行估算的时候，需要综合考虑时间的限制和资源的限制，平衡好活动的资源需求和时间要求。比如，当时间要求已确定的时候，就要更多考虑的资源的需求;当资源是给定的时候，就要估算时间需求;当二者都是限定的时候，就要考虑赶工等方法，以保证时间要求。所以，活动需要的时间和活动需要的资源是相互依赖的关系，需要在实践中根据实际情况灵活加以考虑。当然，在活动的工作量和资源都确定的情况下，活动需要的时间仍然存在不确定性，我们一般通过活动历时的三点估算法进行估计，以求得尽量符合实际的活动历时。</p><p><strong>六、制定进度计划</strong></p><p>制定进度计划是分析活动顺序、持续时间、资源需求和进度制约因素，创建项目进度模型的过程。我们知道，进度安排的准确程度可能比成本估计的准确程度更重要。在本项目中，如何制定一个符合实际、切实可行的进度计划是我感觉困难的问题，通过有效运用资源平衡以及模拟技术，较好地解决了问题。在前期项目进度管理的基础上，我们综合分析项目活动顺序、持续时间、资源需求、制约因素等，利用蒙特卡罗模拟技术对项目的总工期进行了反复的模拟，对不同方案下的关键路径进行反复比较，通过资源平衡以及提前量与滞后量等方法的综合运用，最终确定了最优的时间进度计划方案。然后据此利用 Project 软件制作了一份项目活动起止时间表，绘制了项目进度甘特图，同时绘制了项目进度模拟的正态分布图，标出了95%的置信区间。时间表和甘特图就成为了该项目的进度基准。</p><p><strong>七、控制进度</strong></p><p>控制进度是监督项目活动状态、更新项目进展、管理进度基准变更，以实现计划的过程。在本项目中，对进度进行有效控制是我感觉困难的又一个问题，通过不折不扣地运用前人总结出来的看起来很繁琐的需要日复一日重复做的工作一一跟踪甘特图法和挣值分析法，较好地解决了该问题。我要求每个小组内部所有成员，每日下班前将工作完成情况汇报给本小组负责人，由小组负责人整理出当日小组的整体工作完成情况，画出跟踪甘特图(在原计划甘特图横线下方画出实际进展的横线)，并邮件发送给我，我每日进行跟踪。每周我们召开一次周例会，各小组汇报本周工作进展，也用跟踪甘特图进行展示。每两周我们进行一次挣值分析，将PV(计划值)、AC(实际值)和 EV(挣值)绘制成”S曲线”，并根据PV、AC和 EV及其它相关信息进行项目偏差分析和趋势分析，根据偏差情况及时采取相应的进度控制措施。本项目我们采用过的进度控制措施有加班、调整人力资源、实施技能培训和选用更高效的技术等。当然，如果确属计划制定不够合理，我们会通过变更控制流程申请对进度基线的变更，以保证进度基线始终对进度的控制具有指导作用，本项目我们共计进行了二次进度基线的变更。另外，对于一些重要的里程碑或阶段，我们都会根据项目当前的绩效，对完工时间进行预测，并写入绩效报告中及时通知干系人，以利于获取他们的支持。由此可见，进度控制也并不难，难的是日复一日地坚持做。</p><p>经过我们团队的不懈努力，历时1年，本项目终于于2019年9月，通过了业主方组织的验收，实现了港口现场管理信息化的扩展，提高了港口装卸效率，减少了工作中人为因素的影响，各部门之间步调一致，简化了工作程序。得到了业主的好评。本项目的成功，得益于我的进度管理。当然，在本项目中，还有一些不足处，比如，在项目的实施过程中，对用户提出的部分变更，未与客户确认即进行了变更，不过，经过我后期的纠偏，并没有多项目产生什么影响。在后续的工作和学习中，我将不断的充电和学习，和同行进行交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的努力。</p><h3 id="3-2-范文二"><a href="#3-2-范文二" class="headerlink" title="3.2 范文二"></a>3.2 范文二</h3><p><strong>摘要：</strong></p><p>2018 年 12 月，我负责了广东省某电力企业“基于 VR 的电力作业仿真培训系统”的项目建设，<strong>担任项目经理一职</strong>。电力作业技能培训是电力人员上岗前确保安全和保证质量的关键一环，由于传统的电力作业技能培训不可避免的遇到资金不足、场地有限、实验器材损耗严重等因素，往往得不到良好的效果。因此，企业需要一套基于 VR 的电力作业仿真培训系统。<strong>项目总投资 100 万元，总工期为 6 个月</strong>，该项目于 2019 年 6 月一次性通过了客户的验收，并受到了客户领导和公司高层的一致好评。由于该项目具有工期紧，任务重，技术复杂</p><p>等特点，所以在项目建设过程中进度管理显得尤为重要，是项目成功的重要保障。具体来说，我主要<strong>从规划进度管理、定义与排序活动、估算资源与历时、制定进度计划、控制进度及解决资源冲突</strong>几个方面来做好进度管理工作。</p><p><strong>正文：</strong></p><p>2018 年 12 月，我负责了河南省某电力企业“基于 VR 的电力作业仿真培训系统”的项目建设，担任项目经理一职。作业技能培训是电力人员上岗前确保安全和质量的关键一环， 由于传统的电力作业技能培训不可避免的遇到资金不足、场地有限、实验器材损耗严重等种种因素，实施起来具有一定的难度，往往得不到良好的效果。为了解决上述问题，电力企业需要一套基于虚拟现实技术(VR)的沉浸式电力作业仿真培训系统，模拟现实中遇到的各种场景以及突发事件，对电力人员进行仿真培训。项目总投资 100 万元，总工期为 6 个月，要求2019 年 6 月全面竣工并投入使用。</p><p>该项目主要包括两部分：一是基于云的后端系统，主要功能是用户账户管理和内容存储； 二是培训子系统，主要包括以下几个部分：中控软件、VR 头盔、安卓手机、安卓平板、大屏幕等。中控软件所需电脑采用 win10 操作系统，安装有 Apache 网络服务器，能控制所有安卓设备的行为并监控其状态；中控软件控制安卓设备做以下事情：控制播放视频、图片、幻灯片、从云端同步内容。所有安卓设备采用安卓 4.4 及以上版本。中控电脑和所有安卓设备在同一 WiFi 网络当中。</p><p>由于该项目具有工期紧，任务重，技术复杂等特点，所以在项目建设过程中进度管理显得尤为重要，是项目成功的重要保障。具体来说，我主要从规划进度管理、定义与排序活动、估算资源与历时、制定进度计划、控制进度及解决资源冲突几个方面来做好整体管理工作。</p><p><strong>一、规划进度管理</strong></p><p>规划进度管理是为实施项目进度管理制定政策、程序，并形成文档化的项目进度管理计划的过程，为管理、执行和控制项目进度提供指南和方向。结合本项目的内部、外部环境特点以及公司以往项目的执行情况，在项目计划阶段，本人组织召开了<strong>会议</strong>，邀请了行业<strong>专家</strong>与曾经做过类似项目的项目经理参加，经过专家们的判断分析，并结合该项目经理的经验分享，最终制定了符合本项目实际情况的<strong>进度管理计划</strong>。</p><p><strong>二、定义与排序活动</strong></p><p>定义活动是制定进度计划的基础。为了保证分解的活动能够全面覆盖项目范围，本人<strong>将范围管理确定的 WBS 工作包分解成一个个具体的活动</strong>。本人组织召开了会议，会议邀请了业务专家和技术专家参与。会议上，业务专家首先介绍业务流程以及应该包括的操作步骤; 其次，技术专家对业务专家的分析进行业务活动分解，形成活动文档清单;最后，依据业务活动之间存在的依赖关系，对业务功能进行优先级排序，并绘制出活动进度网络图 PDM。通过业务专家和技术专家全面、准确的分解，定义了项目的所有活动以及逻辑顺序，也让团队成员对业务流程有了进一步的理解。</p><p><strong>三、估算资源与历时</strong></p><p>业务活动分解完成后，为保证有充足的资源和时间去完成，本人组织召开了会议，会议邀请了业务专家和技术专家参与。业务专家和技术专家对每一层的每一个具体的工作活动提出了所需要的资源，并采用自下而上的方式进行估算，最后将所有资源进行了汇总。</p><p>在活动资源估算完成后，对每个活动进行历时估算。业务专家和技术专家对每一个具体的工作活动进行判断，并结合公司曾经做过的类似项目，综合估算了持续时间，此外还一起讨论了每一个工作活动可能遇到的风险情况，如果活动存在潜在的风险，则将该活动历时加上10%的应急储备时间作为活动的总活动历时。例如:“中控软件与安卓设备的内容实时同步展示”活动，是此项目中最为核心也是最为困难的工作，业务专家和技术专家估算完成此 活动为 10 个工作日，此时统计该活动的历时为 10+10*10%=11 个工作日．</p><p><strong>四、制定进度计划</strong></p><p>根据活动历时汇总得出的结果，有可能超出项目合同要求的工期，所以我采用了资源优化技术和进度压缩法对活动历时进行了调整和压缩。为了便于安排团队成员的具体工作，分配了相应的工作职责，形成了横道图。公司高层领导通常关注项目是否符合项目的目标，是否按照计划进行，项目团队绩效是否能够保持，因此需要每周向公司高层汇报进度情况，于是形成了概括性进度计划表。</p><p><strong>五、控制进度</strong></p><p>“懂业务的不懂技术，懂技术的不懂业务”，在这种局面下项目风险很大，一旦开发人员没有理解业务去开发，将导致严重的返工，最终影响项目进度。为了及时了解团队成员工作中遇到的问题，本人约定每日下班后举行例会，每个成员都谈谈工作完成情况以及在工作中遇到的问题，对遇到的问题，大家一起讨论形成解决方案，形成会议记录。由于该项目从正式启动到试运行工期很紧，且中间需要经历，清明、五一、端午三个假期，给项目的进度控制带来了较大的压力，本人决定从 2018 年 4 月中旬开始，每周一、三晚加班。</p><p>根据团队成员每天的工作绩效信息，每周形成项目周报，并发送给项目相关干系人，同时，根据绩效信息与进度计划表进行比较，进行偏差分析，利用挣值技术计算进度偏差情况， 及时采取纠正或预防措施。例如：负责需求分析和设计的徐工是其他项目的项目经理，因其他项目上的事情比较多，需求分析和详细设计工作迟迟不能开始，已落后于计划,SV=-3 天， 如果再不提交将影响到编码阶段。本人及时跟徐工进行了沟通，与他协商约定，本人负责帮他完成一部分其他项目中的工作，他加班负责先把马上要进入编码阶段的需求分析和设计提交出来，最终编码开发工作得以按计划开展。</p><p><strong>六、解决资源冲突</strong></p><p>由于项目业务面广而复杂，考虑到部门实际情况，以及客户要求 2019 年 6 月 30 日试运行的硬性指标，本人将系统分解成 4 个相关联的子系统分别同时进行开发，并将项目组分成4 个小组，每小组配备 2 至 3 人分别进行开发。例如，由于本项目需要的开发人员较多，开发阶段需要从其他项目组中抽调的 2 个开发人员迟迟没有到来，如果不能及时解决，将严重影响项目的开发进度。经过及时与公司领导沟通协商，通过招聘外包人员进驻项目。</p><p><strong>七、总结与展望</strong></p><p>经过全体人员的共同努力，该项目于 2019 年 6 月一次性通过了客户方的验收， 受到了客户领导和公司管理层的一致好评。项目通过验收后，我们还专门组织全体团队成员召开了 项目总结大会，分析总结项目建设过程中采用了哪些好的做法、存在的不足，为以后的项目 建设收集宝贵的资料。在本项目管理过程中，深深体会到项目进度管理在项目建设中的重要性。在今后的项目管理工作中，我一定会吸取经验教训，不断提高自身的管理能力和管理水平，为我国的信息化建设贡献自己的微薄之力。</p><h2 id="四、成本管理"><a href="#四、成本管理" class="headerlink" title="四、成本管理"></a>四、成本管理</h2><p><strong>【摘要】</strong></p><p>2015年5月，我参加了公司面向17年欧美市场贩卖的XXXX机的开发工作，并担任该项目的项目经理。该项目主要是在15年既有XXXX机的基础上，增加安全密码打印，XML电文控制打印，卡纸重印，扫描原稿至云服务器等商务功能，丰富产品线的同时，目标在17-18年进一步扩大欧美XXX机SOHO市场占有率。</p><p>本文结合了我在该项目中的实践，主要讨论作为成本补偿合同中的乙方的项目经理，如何制定成本管理计划，运用估算成本，控制成本等成本管理的子过程，采用三点估算，类比估算，质量成本，挣值管理等工具与技术，避免成本超支的风险,实现有效的成本管理，取得项目预期收益。在本文最后本人还总结了本项目中成本管理方面的不足。</p><p><strong>【正文】</strong></p><p>2015年5月，我作为项目经理参加了公司面向17年XXXX机的开发工作。该项目是在15年成熟框架的基础上，增加安全密码打印，XML电文打印，卡纸重印，扫描至云服务器等商务功能,目标在17-18年进一步扩大欧美SOHO市场的占有率。该项目为嵌入式开发项目，使用C语言并采用XDDP派生功能开发流程进行开发。该项目光软件方面预算就有近500人月，并由我们总公司(甲方)和中国研发中心(乙方)两个团队共同协作完成。其中近三成的工作通过外包委托的方式，由我们负责在15个月内完成。</p><p>该项目规模大，研发周期长，又是采用虚拟团队，范围定义不够清晰，成本精确估算困难，不确定因素多。我作为乙方项目经理，经协商后与总公司签订了成本补偿加激励的合同。与总价类合同不同，该合同承诺报销一切开发产生的直接成本费用，同时也将成本超支风险转移给了甲方，所以总公司作为甲方格外在意我们的成本管理，成本管理的成功与否直接影响着甲方关键干系人对项目的满意度。作为项目经理，我在规划成本管理，估算成本，控制成本等三方面采取了三点估算，类比估算，挣值管理，质量成本等的成本管理方式，和团队成员一起取得了项目的预期收益。满足了甲方干系人对成本管理的要求，获得了甲方干系人对项目的一致好评。</p><p><strong>1.规划成本管理</strong></p><p>作为项目经理的我在规划成本管理中，首先参考了项目章程上的总体预算，制定了生产性指标(成本绩效指标CPI)项目结束时CPI必须大于等于1的目标。同时定义内部临界值不小于0.95，外部临界值不小于0.9。同时规定在每周一的项目周次会议上以固定格式报告CPI等成本绩效，并决定以元为单位计算挣值管理测量成本。对于甲方最关心的人力资源成本，我规定了资深工程师项目经理单金为160元/小时，一般工程师90元/小时，初级工程师单金50元/小时，一天7小时为基准，平均每月20.75天来计算。为达成CPI大于1的目标，作为项目经理我计划在回归测试时，导入自动化测试工具，计划增加变更设计Review时间比率来提高上工程项目的质量，减少因质量问题而造成的返工。有了以上的成本计划后，便明确了在项目中如何规划，安排和控制成本。</p><p><strong>2.估算成本</strong></p><p>在项目成本中主要包括直接成本和间接成本两大块。因公司事业环境因素，高层管理人员工资等间接成本会分开核算，而根据合同甲方承诺报销的所有费用，都属于项目的直接成本。</p><p>为了准确估算项目直接成本，我参照了成本管理计划，列出了合同中可以报销的所有直接发生的成本费用项。具体包括：人力成本(包括差旅费)，开发试验机，耗材(墨盒，纸张)各开发工具的Licence。软件项目的成本构成中，人力资源成本往往占有8成左右甚至更多，而且相对其他费用固定的成本构成科目，软件开发作为脑力劳动，估算人力成本是重点也是难点。所以针对分解后每个活动，在列出活动估算依据后，通过会议的方式，结合资深工程师的经验加上会议上的三点估算，和基于之前项目的实际绩效数据后的类比估算，再乘以担当资源的单价，估算出了各个活动的成本。根据各个活动的不确定因素，风险因素，质量成本沟通管理成本情况，为各个活动增加了应急储备金。自下而上汇总活动成本后，就算出了项目的BAC。得到高层领导和甲方干系人的确认和批准后，做成了可参考的成本基准。</p><p><strong>3.控制成本</strong></p><p>因为软件类项目的特殊性质，它的人力成本不光难于准确估算，也难于控制。所以在控制成本中我主要也是围绕人力成本展开。根据成本管理计划，在控制成本上，我使用挣值管理的方式。因我司的项目组织为弱矩阵型，每周一各个职能经理都会将配下资源一周的项目成本以人时为单位人时汇总给我，这样只要乘上资源单价后就有了AC。参考进度基准后，可得出项目PV和EV的值，有了这些计算值后，准确掌握每周项目CPI的变化就变得可能。结合人力资源计划和当下风险发生的情况，算出ETC，完成对将来的成本预测。从而能够在每周一准确地将成本绩效和对于未来的预测等项目基本情况，传达给需要的甲方干系人。</p><p>为了更好的控制成本提高CPI值，我还加强了质量的监控，提出高质量低返工就是节约成本的概念，并严格要求变更设计Review的时间要达到设计时间的15%，对于设计Review时间不到总设计时间15%的案件，一律追加设计Review时间，保证在V模型的上工程提高设计的品质。在项目中后期，每修改一个Bug后为了不影响其他既有功能，我们团队中使用PC晚间跑自动化测试脚本的方式来做回归测试，在保证了质量的同时，也缩减了项目人力资源的开销。</p><p><strong>【总结】</strong></p><p>和团队成员经过15个月的共同努力，该项目在16年8月正式验收完毕，完工时CPI为1.023，达到了项目预期的收益，实现了和总公司甲方的双赢。不同于总价合同，作为乙方项目经理的我在该项目中，首次尝试实践了成本补偿合同的成本管理。使用了不同与总价合同的成本管理方式，深切体会了成本与风险质量范围进度等的关系，自己成本管理能力也有了提升。但在该项目的成本管理中，也存在一些不足。比如中期人力资源的频繁更替和培训，出现了CPI低于0.8的情况，后来通过稳定团队成员的士气，并导入自动化测试后缩减成本后，才将CPI转降为升。在项目实际进行过程中，团队也无法保证均匀绩效，导致CPI出现了预期以外的波动情况。每个项目都有其不同的特点，根据项目的不同成本管理方式也不能一层不变。如何更高效的管理成本是作为项目经理的我需要在今后的项目中不断完善的地方。</p><h2 id="五、质量管理"><a href="#五、质量管理" class="headerlink" title="五、质量管理"></a>五、质量管理</h2><h3 id="5-1-范文一"><a href="#5-1-范文一" class="headerlink" title="5.1 范文一"></a>5.1 范文一</h3><p><strong>摘要</strong></p><p>2014年4月，我参加了某市质量技术监督局“金质工程”软件部署及适应性维护项目的实施，担任本项目的项目经理。该项目投资约915万元人民币，建设工期为6个月，该项目是为了促进各级质监机关向管理服务型转变，提高质量监督检验检疫执法的透明度，形成全国统一的质监大网络，促进质监系统执法电子化、信息化，为生产企业和外经贸企业带来更大的方便与效益，加大打击假冒伪劣的力度，更有效地规范市场经济秩序，促进社会主义市场经济的发展。本文结合作者的实际经验，以该项目为例，讨论了信息系统项目建设过程中的质量管理，包括本项目的制定质量管理计划、落实质量保证措施、实施质量控制活动等过程及方法等。</p><p><strong>正文</strong></p><p>2014年4月，我参加了某市质量技术监督局“金质工程”软件部署及适应性维护项目的实施，担任本项目的项目经理。该项目投资约915万元人民币，建设工期为6个月，该项目是为了在全市质量技术监督管理系统各单位统一部署由国家局下发的“金质工程”软件并对该软件进行适应性维护，促进各级质监机关向管理服务型转变，提高质量监督检验检疫执法的透明度，形成全国统一的质监大网络，促进质监系统执法电子化、信息化，为生产企业和外经贸企业带来更大的方便与效益，加大打击假冒伪劣的力度，更有效地规范市场经济秩序，促进社会主义市场经济的发展。该项目建设内容包括在市局中心机房建设配套本项目的服务器及存储系统、网络及安全系统、数据库软件、防病毒软件、部署“金质工程”一期建设成果内各系统并针对该市特有情况和国家局出台的最新规定对本软件进行适应性维护和相应表单、流程的更新，为各派出局、所及检测站点建设直连市局的数据专线，使各派出局、所及检测站点可以访问、共享此次“金质工程”软件部署、维护工作的建设成果，简化各单位办事流程。</p><p>质量是系统的生命线，对项目的成败起着关键的决定性作用。好的质量是规划出来的，而不是检查和测试出来的。项目质量管理包括质量计划的编制、项目质量保证和项目质量控制三个过程。质量计划编制判断哪些质量标准与本项目有关，并决定应如何达到这些质量标准。项目质量保证过程定期评估项目总体绩效，建立项目能达到相关质量标准的信心。项目质量控制过程检测项目的总体结果，判断它们是否符合相关质量标准，并找出如何消除不合格绩效的方法。信息项目质量提高空间非常大，强有力的领导有助于质量意识的形成。建立组织级项目管理体系、组织级质量管理体系和项目及激励制度为实施项目质量管理提供强有力的组织环境。该项目的成功与很大程度上归功于在项目整体实施过程中对质量的有效管理，下面结合我的实际经验，分别对项目质量管理过程中的质量管理计划的编制、质量保证与质量控制活动的展开等几个方面加以简要论述。</p><p>一、制定质量管理计划</p><p>要做好质量的管理，一个完备可行的质量计划是必不可少的。“质量出自计划和设计，而非出自检查”，良好的质量保证计划有助于正确的指导项目质量管理行为。我在制订项目管理计划的过程中，首先，制定项目的质量标准。与品质保证人员经过反复商讨，并经过与高层经理、项目组相关成员、客户等干系人的沟通，在充分了解他们对本项目的质量要求与期望的基础上，确定了本项目的质量目标，包括功能验收、竣工验收和最终验收的具体标准；定义项目实施过程中阶段性输出物的质量标准，产品需求评审缺陷排除率、系统测试缺陷排除率等。</p><p>其次，我梳理了质量管理的监控点，输出质量检查单。我们根据范围说明书明确了项目的范围、中间产品和最终产品，找出可能影响产品质量的技术要点，对其进行逐一分析，确定需要监控的关键元素，设置整体项目实施过程中合理的检查点及度量指标，把满足项目质量标准的活动或者过程规划到项目的中间产品和项目的中间过程中去。针对实际控制检查点，在项目实施的不同阶段结合质量管理的监控点，将各个过程域对应的检查项，形成《质量检查单》，使之成为一个对本项目的质量管理行之有效的手段。</p><p>最后，我强调了质量管理计划的评审。质量计划编制任务完成后，我们召集高项目相关干系人对质量保证计划进行了评审。通过评审，使大家对描述在质量计划中的相关角色、职责、活动等内容保持一致认识。</p><p>二、实施质量保证</p><p>质量保证应贯穿于整个项目生命周期，它包括所有有计划地系统地为保证项目能够满足的质量标准而建立的活动。我们在项目质量保证过程中重点做好以下几个方面的工作：</p><p>首先，依照质量管理计划制定的标准，评审和审核项目的活动及其产品。质量保证组在整个项目生命周期中定期评审和审核项目活动及其工作产品，通过《品质保证周报》、《品质保证审计报告》、《品质保证问题跟踪表》、《品质保证里程碑报告》等形式，就项目是否遵守已制定的标准向项目组提供报告，我通过这种方式能及时获知项目进展中的各类质量数据及信息，以便我及时采取有利于保证过程及产品质量的措施。</p><p>及时做好预防及纠正措施。品质保证工程师向项目组反馈有关评审和审核的结果，以便使我能够及时在项目过程中对偏差采取及时有效的防范和纠正措施，以此避免项目管理中因过程中的问题而造成不必要的损失。比如在需求评审阶段，由于项目干系人较多，导致评审参与度不足70%，评审缺陷率没有达到每页1个的标准。品质保证人员根据评审结果的审计情况通过邮件及口头沟通的形式，及时向项目组提出预警，敦促项目组加强文档评审的参与力度。我也有针对性的提出，将专家评审的参与度、评审有效性作为对员工绩效的良好考核指标之一，通过考核机制及时的纠正质量保证过程中发现的问题。</p><p>通过以上有效的质量保证活动，使项目的质量要求得以保证，主要成效表现在返工率减少、生产效率提高、产品质量提升，项目成本降低。</p><p>三、做好质量控制</p><p>在本项目的实施过程中，我们对整个项目生命周期的各个阶段，尤其是系统分析、设计、实施、测试等阶段进行有效的质量控制和管理；注意贯彻预防为主和检验把关相结合的质量控制原则，要求项目组全体成员在实施过程中，按照计划、执行、检查、处理的质量环要求，实施各环节的质量控制；通过每周工作汇报总结、品质保证工程师日常审计、实施人员间的互查、里程碑的工作总结以及执行有效的测试等手段，来发现项目进展中的偏差及不合格项。对于超出即定标准的偏差通过因果图法分析原因，并采取有效的纠正措施，确保系统的关键指标在实施过程中得到全面的监控；在各个重要控制点，如需求、设计、实施、测试等工作完成之时，实行阶段性审查和评审，对于发现的问题及时组织相应的责任人在规定的时间段内予以解决。我安排加强项目组单元测试，在小组内部执行互查互纠等预防手段提高施工质量，软件部分通过制定迭代版本发布，逐个版本多轮测试，通过不同build的缺陷数形成系统测试的趋势图，在趋势图明显处于收敛状态的前提下才能完成版本的正式发布。</p><p>经过我们团队的不懈努力，历时6个月，本项目终于在2014年国庆节前通过了建设单位组织的项目最终验收，促进了各级质监机关向管理服务型转变，提高了质量监督检验检疫执法的透明度，形成了全国统一的质监大网络，促进了质监系统执法电子化、信息化，为生产企业和外经贸企业带来了更大的方便与效益，加大了打击假冒伪劣的力度，更有效地规范了市场经济秩序，促进了社会主义市场经济的发展。该项目于当年国庆节前验收，获得了建设单位的充分好评，还被评为了当年的向国庆献礼工程。本项目的成功得益于我成功的质量管理。在后续的学习和工作中，我将不断的充电学习，和同行进行交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的贡献。</p><h3 id="5-2-范文二"><a href="#5-2-范文二" class="headerlink" title="5.2 范文二"></a>5.2 范文二</h3><p><strong>摘要：</strong></p><p>2018年2月，我有幸参与了XX 市电网公司人力资源管理系统建设项目，担任项目经理职位。该项目以《XX市电网公司”十三五”信息化规划实施计划》为准则，目的是采用统一的技术路线和架构体系，构建一体化的信息化应用环境。整个项目总投资 800 万元，建设工期为一年，该系统以专业的人力资源管理技术，依托动态详实的数据，完整实现了劳动组织管理、用工管理等系统业务功能，为客户及时提供多角度的人力资源统计分析报告。</p><p>本人在项目的质量管理过程中，结合公司质量管理体系要求和项目实际情况，科学的运用信息系统项目质量管理的理论知识，通过建立项目质量规划、有效地展开质量保证活动、执行质量控制等管理办法，最终使项目按期保质完成，满足客户要求。在本文的最后对该项目的一些经验教训进行总结。</p><p><strong>正文∶</strong></p><p>2019年2月，我作为项目经理参与了XX市电网公司人力资源管理系统建设项目，该项目是2019年XX市电网公司”十三五”信息化规划实施计划的重点工作，同时也列为XX市电网公司重点信息化项目。该项目总投资共800万元人民币，建设工期为一年，该项目在 XX 市电网公司范围内推广应用，能够进一步提升信息共享和协同作业范围，可有效解决数据统计工作量大、容易出错的等业务难题，通过各种在线办公功能解决范围远、沟通难、时间长等问题，在提高业务办公质量的同时，更能有效的进行成本控制，一举多得。人力资源管理系统目前具备劳动组织管理、人员调配、班子建设与干部管理、员工信息管理、专家队伍建设管理、劳动关系管理、绩效管理、员工资质管理、考勤休假、保险福利、薪酬管理、离退休管理、外事管理、自助服务、统计报表、决策分析、数据中心、基础平台、系统设置等20多个系统功能模块，满足XX市电网公司人力资源管理需求。</p><p>该系统采用java 语言开发，，基于J2EE 架构，采用Oracle10G作为数据库、Weblogic9.2作为中间件，应用服务器是 DELL塔式商用服务器，数据库服务器采用双机热备加光纤存储，服务器操作系统采用 RHEL4.7。从事多年项目管理的我深知，需求是龙头，因此，在项目开始实施后，我带领我的项目团队深入甲方现场，通过用户访谈等方式获取用户需求，编制了需求规格说明书，并会同甲方召开了需求评审会，确定了项目的需求，为后期的项目管理莫定了基础。</p><p>由于本项目被列为2018年XX市电网公司重点信息化项目，人力资源管理系统作为核心业务系统，为了使项目能够顺利实施，执行严格的质量管理至关重要，在具体工作中，我根据项目的实际情况，主要从质量管理的质量规划、实施、质量保证、质量控制方面进行论述∶</p><p><strong>一、制定质量管理规（划规质量管理）</strong></p><p>人力资源管理系统项目的质量规划，包括识别与该项目相关的质量标准以及如何满足这些标准。首先由识别相关的质量标准开始，通过参照或者依据本公司的质量策略、项目章程、项目的范围说明书、风险登记册、项目管理计划等作为制定质量规划的依据。</p><p>我根据以往的经验，决定采用质量成本分析法，项目的质量成本分为预防成本、评估成本和故障成本，预防成本和评估成本是一致成本，一般发生在质量保证和质量控制过程中，而故障成本属于不一致成本。我们通过公司的组织过程资产库得到以前类似项目的质量成本数据，类比本项目的实际情况以及需要达到的质量标准等，初步估计了项目的质量成本。项目成功的标准就是增加预防成本要比设法降低弥补成本更值得，因此，我们决定增加预防成本的投入，使质量审计、质量培训、供应商评估等方面工作能够顺利进行。</p><p><strong>二、实施质量保证</strong></p><p>质量保证是一项管理职能，质量保证应贯穿于整个项目生命周期，它包括所有有计划地、系统地为保证项目能够满足的质量标准而建立的活动。本项目的质量保证工作由公司的质量保证小组专门负责，我根据项目的实际情况，主要采用质量审计的方法，邀请公司质量保证小组来对其他质量管理活动进行结构性的审查。质量保证活动能否顺利开展不仅只在于全体项目组成员参与管理，领导的重视和支持也是非常重要，为了让客户对项目充满信心，每次召开质量审计会议，我们都会邀请客户方高层代表、公司领导高层参加。另外，每次审计会议总结，都及时以邮件、传真等形式发送客户方以及公司领导高层等重要项目干系人。经过数次的审计会议，客户对项目能够顺利完成充满信心，亦表示积极配合我们的工作，公司领导亦表示全力支持我开展质量保证工作。早在项目启动阶段，我与项目组的QA(质量保证人员)已经展开质量保证计划的编制工作，在与客户代表、公司高层领导充分沟通的基础上，成功通过了评审，制定了该项目质量保证计划，该计划中详细明确了质量保证工作的内容和工作进度安排，需要做好以下方面工作∶</p><p>加强测试工作，并形成制度。测试是保证软件质量的重要手段，也是让用户直观地了解软件质量和熟悉软件操作的有效途径。我有计划地强化测试环节，让用户由始至终地参与测试工作和测试活动，做到尽可能覆盖整个项目过程，并且制定详细的计划并编制相应的文档，如测试计划、测试报告等资料。通过测试活动，能尽早发现每个阶段中软件存在的缺陷，及时采取纠正措施。总之，一切测试应符合用户需求。及时发现不一致问题，确保其得以解决。在评审和审计过程中，QA对于发现的不一致项在《QA审计报告》中及时记录，并把记录提交我处，由我去处理后续事情，安排相关人员解决问题，同时QA人员持续关注不一致问题的解决情况，直到该问题得以解决。</p><p><strong>三、质量控制(控制质量)</strong></p><p>质量控制是验证具体的项目成果，判断是否符合有关的项目质量标准，并确定消除产生不良结果原因的途径。有效的质量控制能够及时发现与质量标准的差异，从而及时采取纠正措施。我根据项目的实际情况，要求项目组全体成员在实施过程中，严格按照质量控制循环PDCA的要求，实施各环节的质量控制，另外，由于该项目的功能模块较多，为避免遗漏，我们准备了详细的质量检查单，对每个模块，都列出了要测试的功能点及其操作流程，很好的减轻了开发人员、测试人员的工作量。</p><p>我根据项目范围说明书以及项目 WBS 对项目所有活动进行定义，划分了劳动组织管理、员工信息管理、用工管理、薪酬管理、绩效管理、决策分析、统计报表、基础平台为主要功能模块，并以此作为里程碑事件，规定每个里程碑需要达到一定的质量要求，对里程碑点发布的版本要求做完备详细的测试，并且对里程碑事件实行阶段性审查和评审以形成基线。同时我要求项目团队成员妥善保存质量控制过程中产生的相关文档资料，并由我汇总提交客户方代表、公司高层领导审阅。</p><p>经过我们团队不懈的努力，本项目在2019年1月试运行成功，系统运行状况良好，得到用户的好评，并在2月份顺利通过了验收。回顾项目质量管理的过程，虽然没有严重的项目质量问题，但还存在一些不足之处∶新成员的培训计划没有做好。在项目的初期，新来的技术人员由于缺乏经验，有时会忽略本该被发现的问题，给项目质量带来隐患。针对此问题，我们邀请了专家对新来的成员进行质量管理方面的培训，强化意识。最终这一问题得到了解决。质量保证措施不够全面。在项目实施过程中发现的问题及解决方法没有很好的形成文档，导致部分细小问题反复出现。所以在后续的学习和工作中，我将不断的充电学习，和同行进行交流，提升自己的业务和管理水平，力争为我国信息化建设作出自己的努力。</p><h2 id="六、人力资源管理"><a href="#六、人力资源管理" class="headerlink" title="六、人力资源管理"></a>六、人力资源管理</h2><p><strong>摘要：</strong></p><p>2018年3月，我作为项目经理参与了XX市社保信息管理系统项目的建设，该项目投资共580万元人民币，建设工期为1年普通过该项目的实施，在XX市建成了集中统一的社会保险信息管理系统，建成了市级劳动保障数据中心，实现了“数据大集合”和业务经办的全程信息化。该项目于2019年3月，通过了业主方的验收，赢得了用户的好评。本文结合我的实际经验，以该项目为例，讨论了信息系统项目建设过程中的人力资源管理，主要从规划人力资源管理、组建项目团队、建设项目团队和管理项目团队四个过程，有条不紊的进行人力资源管理，加之进行了良好的配置管理，在整个项目建设过程中始终遵循了变更控制流程，合理运用人力资源管理的措施，使该项目顺利完成了既定目标。</p><p><strong>正文：</strong></p><p>2018年3月，我作为项目经理参与了XX市社保信息管理系统项目的建设，该项目投资共580万元人民币，建设工期为1年，通过该项目的实施，在XX市建成了集中统一的社会保险信息管理系统，建成了市级劳动保障数据中心，实现了“数据大集合”和业务经办的全程信息化。同时也满足了社会公众对社会保险事务的有关服务要求、与相关部门的横向信息交换、市一区(县)一街道(社区)延伸的三级应用，形成全市统一的安全、快捷、便民的社会保险信息服务和管理体系。</p><p>本项目采用满足J2EE标准的B/S/S三层架构技术，以Oracle数据库为支撑，符合“金保工程”技术规范和联网要求。开发过程应用轻量级J2EE架构，基于MVC模式的Struts框架，以Ibatis作为持久化层，采用Spring进行中间层(业务层)建设，应用服务器采用浪潮高性能服务器。本项目针对市、区(县)、街道(社区)三级社保信息管理机构，包含业务经办、公共服务、基金监管、宏观决策等四大业务子系统，统合养老保险、医疗保险、失业保险、工伤保险、生育保险和住房公积金等的主要功能模块。实现业务专网纵向上三级机构的全面贯通，横向上与合作银行实时联网，提供对经办工作的全流程管理，确保社保工作流程规范、数据准确、管理高效、服务便捷。</p><p>项目人力资源是创造一切项目成果的本源，项目人力资源管理就是通过人力资源规划，把大家组织起来，根据工作性质和各成员的特点“因人施用”。因此，在本项目中人力资源管理显得尤为重要，项目实施过程中，我作为项目经理除了对其余管理领域进行克尽职守的管理外，本文特别围绕人力资源管理从如下几个方面进行论述。</p><p><strong>一、规划人力资源管理</strong></p><p>规划人力资源管理就是决定项目参与者角色、职责和汇报关系的过程。作为项目经理的我深知，高效率的好团队出自良好的人力资源规划;因此在本项目的初期，我根据项目管理计划及参考公司以往类似项目并结合本项目的实际资源需求，通过项目组织图和职位描述识别出本项目需要的人员，包括：项目经理1人、需求分析人员4人、设计人员3人、代码开发人员13人、测试人员5人、现场软件和硬件实施人员6人、配置管理员1人、质量管理员1人等，其中配置管理员和质量管理员属于兼职人员，他们在多个项目中兼职，实现了人力资源配置最大化。我在规划人力资源管理的过程中力求角色和职责清晰，按照各种岗位的职能来约定人员的能力要求，充分考虑了相关人员进入与退出项目的时间，避免了在项目实施过程中的职责不清造成相互推诿的情况。同时还对如何获得这些资源、需要什么培训、如何进行认可与奖励进行考虑，也就是对人力资源管理的后续过程进行了规划。最终形成了人力资源管理计划。</p><p><strong>二、组建项目团队</strong></p><p>组建项目团队就是一个获取人力资源的过程。在制定了人力资源管理计划后，我开始着手组建项目团队。首先，是向公司人力资源部要求将预分派到本项目的人员安排到位，基本落实了本项目要求的骨干人员，但发现代码开发人员和测试人员有缺口，原因是公司近期同时进行的项目较多，实在抽不出人手来了;经与人力资源部协商，确定通过招募和采用多标准决策分析的方式向社会公开招聘符合本项目要求的代码开发人员和测试人员。最终于项目启动之前，所有的项目组成员全部到位，至此我充分考虑到项目成员的工作兴趣和职业发展意愿，尽量发挥项目成员的特长，让每个人从事适合自己的工作岗位。</p><p><strong>三、建设项目团队</strong></p><p>建设项目团队就是通过开展一系列活动提高团队的战斗力。主要包括提高团队成员个人的技能和提高团队成员之间的信任感和凝聚力，为共同目标而高效率地协同工作。为实现这个目标，我根据人力资源管理计划和项目人员所从事的岗位要求，通过安排项目成员集中办公的方式，培养了集体荣誉感和团队精神，同时制定了项目内部的培训、活动计划。在项目实施期间，我们一共进行2次业务培训、4次技术培训和3次管理知识培训，通过多种形式的培训计划，充分调动项目成员积极提升自身技能水平的热情，技能的提升为项目的实施过程扫平了沟通上的障碍;同时开展周期性的团队建设活动，如每月月末都安排一次项目聚餐，营造民主平等、相互信任的团队氛围。建立明确的团队考核与评价标准，工作结果公正公开、赏罚分明，并将绩效信息记录备案，最终反映到年终奖的考评中。</p><p><strong>四、管理项目团队</strong></p><p>管理项目团队是指跟踪个人和团队的执行情况，提供反馈，解决问题和协调变更，以提高项目的绩效。在项目实施过程中，我根据人力资源管理计划、团队的绩效评价以及记录的问题日记等，充分了解各项目成员的基本情况，然后有针对性的观察各项目成员的工作状态，一旦发现存在过激的异常情况，就主动积极的与其约谈，努力开导并协助其探讨解决问题的方法;当然，对于非常好的表现，我会第一时间表达我的关注与肯定。冲突管理是项目团队管理的最大挑战。对于团队中出现的冲突，我主要采用合作/解决问题的策略，力求在双赢的模式下友好的解决问题。比如，项目成员小张和小李因各自所负责模块出现接口的互不兼容问题，各执已见发生了争执;我了解具体情况后，通过对双方进行了开导和说服，最终顺利解决了此次冲突。</p><p>经过我们团队的不懈努力，历时1年，本项目终于于2019年3月，通过了业主方组织的验收。在合同规定的工期内出色的完了各项任务，截止目前，该系统已经成功上线1年多的时间，运行状况良好，得到了业主方的好评。本项目的成功得益于我成功的人力资源管理，当然，也存在一些不足之处，值得我及团队成员反思，比如：对如何灵活处理冲突的各种策略把握的不够熟练，导致一些冲突处理不当;个别团队建设活动策划得欠妥，导致大家参与的兴致不高。不过，经过我后期的纠偏，并没有对项目产生什么影响。在今后的学习和工作中，我将不断的充电学习，和同行多进行沟通交流，提升自己的业务和管理水平。</p><h2 id="七、沟通管理"><a href="#七、沟通管理" class="headerlink" title="七、沟通管理"></a>七、沟通管理</h2><h3 id="7-1-范文一"><a href="#7-1-范文一" class="headerlink" title="7.1 范文一"></a>7.1 范文一</h3><p><strong>【摘要】</strong></p><p>2015年2月初我作为项目经理主导实施了某市某汽车股份有限公司MES项目，该项目投资650万元人民币，建设工期为13个月，通过该项目的建设解决了该工厂的多车型多批次小批量混线生产、线边生产消耗拉动物料需求、供应商供货管理、高位货架管理、关重件扫描控制、质量问题追溯、一车一档等问题，同时和企业的SAP、SRM、QNS系统做集成解决了企业的信息孤岛问题。该项目于2016年3月份，通过了业主方的验收，获得了用户的好评，并作为重点试点单位，向其他生产基地推广实施。</p><p>本文结合作者的实际项目经验，以该项目为例，讨论了信息系统建设过程中的项目沟通管理，主要从以下几方面进行阐述：1、识别项目干系人，并了解这些项目干系人对项目的收益和影响，谁需要什么样的信息，什么时候需要。2、针对不同的项目干系人以合适的方式及时提供信息。3、收集项目的进度情况、状态信息和预测信息，编制绩效报告。4、对项目沟通进行管理，满足信息需求者的需求，并解决项目干系人之间的问题。</p><p><strong>【正文】</strong></p><p>2015年2月初我作为项目经理主导实施了某市某汽车股份有限公司MES项目。系统上线后通过一系列的拉动关联，重组和优化了公司的业务流程，构建起采购、供应商、物流仓库、总装车间、焊装车间、涂装车间、冲压车间之间的内部集成的一体化系统，使整车生产的信息化管理程度和按需配送物料的及时响应度得到了明显的提高。该项目开发语言采用C#.Net、J2EE，数据库采用oracle 10g，中间件采用weblogic10，系统采用C/S架构，数据库服务器为RedHat Linux，应用服务器为windows server2003企业版，开发工具使用eclipse3.0 和Vs2008，其中应用服务器和数据库服务器硬件均采用机架式IBM X3850系列。</p><p>众所周知，在项目实施过程中，沟通管理占用项目经理工作量将近90%。而且由于本项目涉及到的系统多——需要4个系统做集成，人员广——涉及到的开发团队有3个，业务部门有7个，因此，在本项目中，沟通管理尤为重要。在本项目管理中，我作为项目经理除了对其余管理领域进行克制恪守的管理外，特别对沟通管理从以下几个方面进行了管理。（过渡段）</p><p>一、 识别项目干系人，了解项目干系人的需求，编制沟通计划</p><p>1、 识别项目干系人：项目开始后我作为项目经理带领项目团队（业务顾问2人，.Net 开发工程师3人，Java开发工程师2人，SAP开发工程师1人，测试工程师1人，项目配置管理员1人）深入甲方现场并协同甲方召开了项目启动会，根据<strong>项目章程</strong>中的公司组织架构了解了参与本项目的各个项目干系人，如：总经理、生产副总、采购部部长、四大分厂厂长、物流部部长、以及关键操作岗的业务骨干。会后对项目干系人进行了分析和总结，生产副总负责项目所需资源的总协调，采购部长、四大分厂厂长、物流部部长和相关岗位的业务骨干负责需求的提出和系统上线后的具体使用，其中采购部长、四大分厂厂长和物流部长会对项目的收尾和验收起决定作用，因此我们在做需求和范围定义的时候必须要充分考虑这个几个部门的要求。</p><p>2、 了解项目干系人需求：从事多年项目管理经验的我深知，需求是龙头，因此带领项目成员通过访谈、现场观察、交流会的方式去挖掘各个项目干系人的需求。经过30多天的时间了解了各项目干系人对系统的功能需求、性能需求，编写了项目需求文档说明书，然后召集项目干系人进行需求的确认、评审和高层领导的会签，确定了项目需求基线，为后期的项目管理确定了基础。</p><p>3、 通过以上的项目干系人的识别分析和项目干系人需求的了解，我们确定了项目沟通计划，确定了沟通的内容、方式、频次、时间、地点和沟通时需要项目组提供的资料等，如：每周五上午8点在总装厂会议室以现场会议的方式进行沟通，项目组所有人必须全部参加。项目经理以PPT的方式提供项目绩效报告和在项目中遇到的问题，会议记录以电子邮件的形式发送给项目组所有干系人并抄送给主管副总裁。</p><p>二、 采取合适的沟通方式把项目干系人的所需信息在合适的时间提供给项目干系人</p><p>1、 沟通方式和分发方式：在项目实施过程中，为了保证项目组有足够的工作时间同时为了提高工作效率，我们采取了多沟通相结合的方式进行沟通。如：项目组内部的咨询顾问2人、开发工程师4人、测试工程师、配置管理员出现问题的时候，我们及时的进行口头沟通，尽快的解决问题，事后会把项目中遇到的问题和解决办法以电子邮件的形式分发。和用户进行沟通时，我们采用正式的会议的沟通方式并结合文档，所有的涉及到需求变更的、设计的、进度的、测试的、以及形成的相关决议的等信息必须以文档的形式分发并归档。</p><p>2、 总结经验教训：由于本项目涉及的系统比较多，各种接口众多，集成度要求高，在项目实施过程中总会出现业务设计和技术实现方面的问题，有时候解决一个问题需要查询大量的资料才能解决，为了以后再遇到这种问题能够很快的得到解决，我们在把问题解决后都整理成一个解决方案，并将方案分类是技术解决方案的还是经验教训的，将方案加入到我们知识库中。如：我们的知识库中已经包含了.NET 、J2EE、SAP、Webservice等总计超过15000条的经验分享，这也是我们项目能够成功实施的一个宝库。</p><p>三、 了解项目进度情况、项目范围、项目状态、项目预测等信息，并编制项目绩效报告</p><p>1、 收集项目绩效信息：在项目管理过程中，我通过微软的Project2010 进行项目计划的管理。每天下午临下班前半个小时，我会挨个了解当天的项目业务顾问设计情况、开发工程师的开发情况、测试工程师的测试情况和已完成任务的百分比，并在project中更新进度比例。定期收集经过项目内部评审过的设计说明书、测试计划、用户手册等 。</p><p>2、 项目状态评审：在项目实施过程中，我要求项目组内部每周四下午召开项目状态评审会议，会议评审相关的接口设计说 明、测试用例和测试计划、用户手册等，项目组内成员可以把在项目中遇到的问题提出讨论解决，如果不能解决的我会协调公司其他的资源来协助解决。每周五上午和用户部门召开项目例会，汇报项目绩效报告和需求变更请求的讨论。</p><p>四、 与项目干系人进行沟通协调，处理好项目干系人之间的关系</p><p>明确问题记录和沟通方法：在每周和客户之间的项目例会中，我会把系统中已发现的问题清单列出，和业务部门讨论哪些问题需要系统提供功能实现的并明确责任人，哪些问题是属于管理方面需要改善的，要让项目干系人清楚的了解项目的进度情况和他们需求是否匹配。将在会议中形成的决议通过电子邮件发给项目干系人，避免由于信息沟通不畅引起的不满。</p><p>经过我们团队的不懈努力，历时13个月时间，本项目终于与2016年3月，通过了业主方组织的验收，本项目的顺利验收，解决用户企业整车生产多品种共线生产的问题，得到了业主方的好评，同时也为向其他生产基地重点推广该项目奠定了基础。本项目的成功得益于我成功的沟通管理。当然，在项目中还有一些不足之处，比如 ：在项目的实施过程中，由于采购的条码打印机无法打印，后来有供应商从厂家派遣技术人员过来才得到了解决，影响了供应商交付模块的上线，不过，经过我后期的纠偏，并没有对项目产生什么影响。在后续的学习和工作中，我将不断的充电学习，同时进行业务交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的努力。</p><h3 id="7-2-范文二"><a href="#7-2-范文二" class="headerlink" title="7.2 范文二"></a>7.2 范文二</h3><p><strong>摘要：</strong></p><p>2019年4月，我参加了XX省商业银行绩效考核系统项目的建设，担任了项目经理的角色，该项目投资共380万元人民币，建设工期为一年。通过该项目的建设实现了从多角度量化分析柜员、客户经理、部门经理、支行行长、会计主管的工作量以及对银行的利润贡献率等，实施对相关人员工作量、工作效率和利润献度的量化考核，为银行提供全面、客观、科学的考核数据，实现对不同对象的业绩考核，从而为银行制定有效人才激励机制提供有力保证，实现银行绩效管理目标。该项目作为XX商业银行的战略性项目，旨在全面革新地方性商业银行绩效管理模式，受到了XX商业银行和本公司的高度重视。本人也在项目管理中结合公司要求和项目实际情况，科学的应用信息系统项目沟通管理的理论知识，该项目于2020年4月顺利验收，系统运行稳定并具有良好的行业示范作用。本文结合作者的实际经验，以该项目为例，讨论了信息系统项目建设过程中的沟通管理，主要从规划沟通管理、管理沟通、控制沟通三个方面进行阐述。</p><p><strong>正文：</strong></p><p>2019年4月，我参加了XX省商业银行绩效考核系统项目的建设，担任了项经理的角色，该项目投资共380万元人民币，建设工期为一年。通过该项目的建设实现了从多角度量化分析柜员、客户经理、部门经理、支行行长、会计主管的工作量以及对银行的利润贡献率等，实施对相关人员工作量、工作效率和利润献度的量化考核，为银行提供全面、客观、科学的考核数据，实现对不同对象的业绩考核，从而为银行制定有效人才激励机制提供有力保证，实现银行绩效管理目标。该系统釆用B/S架构，服务器使用曙光刀片机，操作系统采用RHEL7，使用JAVA语言开发，SVN作为配置管理工具，中间件使用 weblogic，数据库釆用 oracle logo，该绩效管理系统的主要功能包括考核指标体系管理、支行绩效管理、客户经理考核、柜员考核、会计和信贷主管考核、业务头寸报表、大客户息跟踪。该项目的干系人涉及到客户方项目领导、客户方顾问、客户方项目责人、我方项目领导、项目顾问、项目经理、分析设计人员、开发人员、测试人员、美工等。由此可见，该项目周期长、投资大、千系人多，有效的管理是项目成功的关键。</p><p>由于本项目的顺利上线涉及到业务的考核，因此，在本项目中沟通管理尤为重要。通过公司的项目经理竞选机制，我有幸获得了公司和客户方领导的信任成为该项目的项目经理。，全面主持项目的管理工作。在本项目中，我除了对其他管理领域进行克制恪守的管理外，特别对沟通管理从如下几个方面进行了管理。</p><p><strong>一、规划沟通管理</strong></p><p>编制本项目的沟通管理计划时，我遵循了以下两个原则:(1)全员参与。计划的编制不仅靠一人之力还更应发挥团队的力量。项目中标后，我带领项目组成员通过召开<strong>头脑风暴会议</strong>列出项目干系人名单，并邀请部分干系人参与讨论等形式编写了本项目的<strong>沟通管理计划</strong>。(2)做好干系人分析。干系人分析是制定沟通管理计划的依据之一。本项目涉及干系人较多，包括建设方总公司的副总经理、信息技术服务中心主管、建设方各个业务部门、我公司项目管理部的负责人等，这就需要我明确沟通人员和其接受的信息。我根据沟通内外有别等原则确定了各干系人的沟通策略。比如建设方总公司副总经理，是本项目的发起人需要在项目建设过程中及时给他递送项目的进展情况，以获取他对于我以及整个项目团队的信任;而我公司的项目管理部负责人更关注于系统整体的开发进展情况，以及项目的总体成本花费情况，我每周都会汇报上述内容，以获取公司层面对我和项目的资源支持。</p><p><strong>二、管理沟通</strong></p><p>按照沟通计划，我通过工作会议、邮件、电话等方式为项目千系人及时提供系统开发的相关信息。对于建设方的高层领导和我公司的项目管理部，我在每月末将项目的进度情况以及当月内产生的各会议评审报告，采用电话和邮件的方式进行发布;对于项目组内部成员，我则是利用公司内部的即时通信软件作为辅助沟通手段，同时每周通过周例会的方式进行沟通交流;在遇到紧急情况时，邀请千系人举行紧急协调会;对于项目的变更严格按照变更流程处理，并及时通知相应千系人。为了更进一步优化管理沟通效果我还釆取了绩效报告措施。绩效报告主要是为了定时进行工作的汇报，与指定的进度、成本、范围等基准进行比较找出实际与计划之间的之间的偏差。针对不同的干系人，进行的绩效报告的方式也不同。对于建设方的高层领导和我公司的项目管理部，主要关注项目的进展情况，所以釆用里程碑和阶段评审的方式进行绩效汇报:对于项目组内部成员，我则要求每周五通过邮件提交本周工作汇报，内容包括本周完成的工作和下周任务计划。每个项目组成员都要对自己的总结报告负责，这些信息都会汇总成每周的工作汇报并张贴在项目组宣传栏上展示，并将电子版发给我公司项目管理部的负责人进行查阅，听取其反馈意见。我结合工作汇报召开评审会议，检查项目进展情况，利用挣值管理分析偏差并制定纠偏措施，以此制作项目的绩效报告。通过绩效报告，项目干系人可以获得项目在特定时间内的进展以及资源的使用情况等信息。</p><p><strong>三、控制沟通</strong></p><p>沟通控制可以确定项目成果是否正确，是否满足沟通要求，同时消除产生不良结果的原因，及时纠正缺陷。有效的沟通控制能够及时发现一些与沟通标准的差异，从而便于及时采取措施。为了有效地做好沟通控制，我要求测试不仅仅是测试人员的事情，开发人员在提交代码前，都必须做好单元测试，填写单元测试报告。配置管理员会不定期检查单元测试报告是否齐全。另外由于项目功能点比较多，为避免遗漏，我准备了详细的沟通检查单。对每个模块，我都列出了要测试的功能点及其操作流程，这样大大简化了测试人员的工作。在项目执行过程中，平均每半个月要发布一次版本，要对每个版本都进行所有功能的测试是不现实的为了检查项目成果与沟通标准的差距，在项目一开始我就定义了四个里程碑点，每个里程碑需要达到一定的沟通要求，对里程碑点发布的版本要求做完备详尽的测试。对于其它版本，则着重检查当前发布版本对上一版本的改进。沟通控制不但要发现问题，还要分析出问题产生的原因，以便采取相应的措施。在该项目中我采用了专家判断来分析沟通问题产生的原因。首先列出需要分析的结果，然后结合各方面专家意见列出各种可能性，再将它们分类，确定主要类别，最后再确定和主要类别相关的原因。在项目开展一段时间后，对各种引发沟通问题的原因通过专家的专业知识和经验进行分析，能够直观的看出当前阶段影响沟通的主要原因。</p><p>经过我们团队不懈的努力该绩效管理系统在2020年2月底试运行成功，并在4月初通过了验收，为银行提供全面、客观、科学的考核数据，实现对不同对象的业绩考核，从而为银行制定有效人才激励机制提供有力保证，实现银行绩效管理目标。回顾整个项目过程，虽然项目工期长、业务复杂、干系人多，但是通过我有效的沟通管理，还是多次受到公司和X商业银行的表扬，并按时上线验收。但在这其间也有一些问题存在，比如:在项目的实施过程中，由于系统业务需求一变再变，导致项目章程制定沟通与原计划相比略有延误，以及在项目实施工程中有个别团队成员推诿、扯皮的现象，不过经过我后期的纠偏，并没有对项目产生什么影响。在后续的学习和工作中，我将不断的充电学习，积极和同行进行交流，提升自己的业务和管理水平，为我国信息化建设贡献出自己的一份力量。</p><h2 id="八、干系人管理"><a href="#八、干系人管理" class="headerlink" title="八、干系人管理"></a>八、干系人管理</h2><p><strong>摘要：</strong></p><p>2018年3月，我参加了XX省农商银行总行绩效考核系统项目的建设，担任了项目经理的角色，该项目投资共500万元人民币，建设工期为一年。通过该项目的建设实现了从多角度量化分析柜员、客户经理、部门经理、支行行长、会计主管的工作量以及对银行的利润贡献率等，实施对相关人员工作量、工作效率和利润贡献度的量化考核，为银行提供全面、客观、科学的考核数据，实现对不同对象的业绩考核，从而为银行制定有效人才激励机制提供有力保证，实现银行绩效管理目标。该项目作为XX农商银行总行的战略性项目，旨在全面革新地方性农商银行总行绩效管理模式，受到了XX农商银行总行和本公司的高度重视。本人也在项目管理中，结合公司要求和项目实际情况，科学的应用信息系统项目干系人管理的理论知识。该项目于2019年3月顺利验收，系统运行稳定并具有良好的行业示范作用。本文结合作者的实际经验，以该项目为例，讨论了信息系统项目建设过程中的干系人管理，主要从识别干系人、规划干系人管理、管理干系人参与、控制干系人参与四个方面进行阐述。</p><p><strong>正文：</strong></p><p>2018年3月，我参加了XX省农商银行总行绩效考核系统项目的建设，担任了项目经理的角色，该项目投资共500万元人民币，建设工期为一年。通过该项目的建设实现了从多角度量化分析柜员、客户经理、部门经理、支行行长、会计主管的工作量以及对银行的利润贡献率等，实施对相关人员工作量、工作效率和利润贡献度的量化考核，为银行提供全面、客观、科学的考核数据，实现对不同对象的业绩考核，从而为银行制定有效人才激励机制提供有力保证，实现银行绩效管理目标。</p><p>本项目采用满足J2EE标准的B/S/S三层架构技术，以Oracle数据库为支撑，符合“金保工程”技术规范和联网要求。开发过程应用轻量级J2EE架构，基于MVC模式的Struts框架，以Ibatis作为持久化层，采用Spring进行中间层(业务层)建设，应用服务器采用浪潮高性能服务器。</p><p>该绩效管理系统的主要功能包括考核指标体系管理、支行绩效管理、客户经理考核、柜员考核、会计和信贷主管考核、业务头寸报表、大客户信息跟踪。该项目的干系人涉及到客户方项目领导、客户方顾问、客户方项目负责人、我方项目领导、项目顾问、项目经理、分析设计人员、开发人员、测试人员、美工等。由此可见，该项目周期长、投资大、干系人多，有效的管理是项目成功的关键。由于本项目的顺利上线涉及到业务的考核，因此，在本项目中干系人管理尤为重要。通过公司的项目经理竞选机制，我有幸获得了公司和客户方领导的信任，成为该项目的项目经理。，全面主持项目的管理工作。在本项目中，我除了对其他管理领域进行克制恪守的管理外，特别对沟通管理从如下几个方面进行了管理。</p><p><strong>一、识别干系人</strong></p><p>我们首先制定出该责效管理系统项目的章程，内容包括项目目标、可交付成果、执行方案。在这一过程中我们采取了干系人分析的措施以识别干系人。干系人分析是制定干系人管理计划的依据之一。本项目涉及干系人较多，包括银行方总行的副行长、信息技术服务中心主管、银行方各个业务部门、我公司项目管理部的负责人等，这就需要我明确沟通人员和其接受的信息。我根据沟通内外有别等原则确定了各干系人的沟通策略。比如建设方总公司副总经理，是本项目的发起人之一，需要在项目建设过程中及时给他递送项目的进展情况，以获取他对于我以及整个项目团队的信任;而我公司的项目管理部负责人更关注于系统整体的开发进展情况，以及项目的总体成本花费情况，我每周都会汇报上述内容，以获取公司层面对我和项目的资源支持。根据干系人分析结果，我们整理出干系人登记册。</p><p><strong>二、规划干系人管理</strong></p><p>规划干系人管理是基于对干系人需要、利益及对项目成功的潜在影响的分析，制定合适的管理策略以有效调动干系人参与整个项目生命周期的过程，能与项目干系人的互动提供清晰且可操作的计划以支持项目的利益。我们根据干系人登记册的信息，不定期与银行方总行副行长、信息技术服务中心主管、各业务部门主管、我公司项目管理部负责人举行会议，以确定所有干系人应有的参与程度，这些信息可用来准备干系人管理计划。</p><p><strong>三、管理干系人参与</strong></p><p>管理干系人参与是在项目的整个生命周期中与干系人进行沟通和协作，以满足其需要与期望，解决实际出现的问题，并促进干系人合理参与项目活动的过程，有助于提升项目经理来自干系人的支持，并把干系人的抵制降到最低，从而显著提高项目成功的机会。我们根据干系人管理计划，主动调动项目干系人适时参与项目，以获取或确认他们对项目成功的持续承诺。我们积极与银行方总行副行长、信息技术服务中心主管、各业务部门主管、我公司项目管理部负责人进行交互式沟通，不定期召开视频会议进行多向信息交换，并且取得了明显效果，获得了来自多方干系人的支持，大大减轻了项目实施的压力。我们把干系人信息的变化更新到干系人登记册中。</p><p><strong>四、控制干系人参与</strong></p><p>控制干系人参与是一个监控过程，这个过程实时观察计划与实际的偏差，全面监督项目干系人之间的关系，发现问题时及时调整策略和计划，以调动干系人参与的过程。对干系统人管理的主要目标是促进干系人对项目的理解与支持，使干系人了解项目的进度和有可能带来的影响。由于该项目干系人众多，各干系人出于自身利益的考虑，均会在项目的实施过程中施加压力和影响，试图使项目向有利于自己的方向发展，由此产生了许多矛盾和冲突。比如银行方信息技术服务中心的主管强烈要求在系统测试阶段要额外增加4名测试工程师，希望通过加强测试来保证系统的稳定性和可靠性，而我公司项目管理部出于人力资源成本的考虑，不同意增加测试工程师，在沟通过程中，我既不能直接拒绝建设方提出的要求，也不能强制施压给项目管理部一定要同意，得益于前期良好的信息分发机制，我与建设方建立了良好的沟通关系，通过组织干系人会议后，最终与银行方及我公司项目管理部达成共识，测试阶段无需追加测试工程师人数，但在系统验收前需要多增加一轮系统测试，由此该问题得以解决，我们将这些信息更新到干系人登记册和问题日志中。</p><p>经过我们团队不懈的努力该绩效管理系统在2019年1月底试运行成功，并在3月初通过了验收，为银行提供全面、客观、科学的考核数据，实现对不同对象的业绩考核，从而为银行制定有效人才激励机制提供有力保证，实现银行绩效管理目标。回顾整个项目过程，虽然项目工期长、业务复杂、干系人多，但是通过我有效的干系人管理，还是多次受到公司和XX农商银行总行的表扬，并按时上线验收。但在这其间也有一些问题存在，比如：</p><p>在项目的实施过程中，由于系统业务需求一变再变，导致项目章程制定沟通与原计划相比略有延误，以及在项目实施工程中有个别团队成员推诿、扯皮的现象，不过经过我后期的纠偏，并没有对项目产生什么影响。在后续的学习和工作中，我将不断的充电学习，积极和同行进行交流，提升自己的业务和管理水平。</p><h2 id="九、风险管理"><a href="#九、风险管理" class="headerlink" title="九、风险管理"></a>九、风险管理</h2><h3 id="9-2-范文一"><a href="#9-2-范文一" class="headerlink" title="9.2 范文一"></a>9.2 范文一</h3><p><strong>摘要：</strong></p><p>2017年6月，我参与了某某市职工总医院区域合作医疗信息系统项目(简称HIS项目)的建设，担任高级项目经理，项目总投资1000万元，工期为8个月。HIS项目的总目标是：建立一个中心三个平台，即卫生数据中心、数字医疗平台、公共卫生平台和协同办公平台，业务涵盖了基础平台、病人及费用管理、医技管理、临床管理、协同办公等子系统。HIS项目于2018年1月底正式投运，通过了系统的验收，受到业主及相关单位的一致好评和认可。</p><p>在充分分析了HIS项目后，我认为项目的风险管理尤为重要，HIS项目和其他经济活动一样有风险，需要通过管理来降低风险和损失。在HIS项目实施过程中，我采用了项目的风险管理方法，从编制风险管理计划和风险识别、定性和定量风险分析、编制风险应对计划、风险监控等几个方面进行，为项目圆满成功奠定了不可或缺的重要基础。</p><p><strong>正文：</strong></p><p>2017年6月，为了实现医疗卫生行业信息化的跨越式发展，适应日渐增长的医疗市场竞争，提升医院的服务水平、服务质量水平、科学管理水平和工作效率，同时满足国家对三甲医院的信息化建设要求，某某集团提出建立某某市职工总医院区域合作医疗信息系统项目，经过公开招标后，我司成功中标，承接该项目建设实施工作。我司按照以往战略、类似项目经验和技术条件将项目分为了硬件实施和软件开发，将硬件实施和机房建设分包给了一家有集成资质的单位，并任命我为HIS项目软件开发的高级项目经理，管理项目软件开发的实施工作，项目总投资为1000万元，工期为8个月。HIS项目的总目标是建立一中心三平台，即卫生数据中心、数字医疗、公共卫生和协同办公平台，是整合各种卫生数据资源，实现网络互连和信息共享，HIS系统建设是以卫生数据为核心，通过统一的卫生数据平台，实现卫生数据中心与各医院、各分院和社区卫生服务中心进行数据交换和共享，通过公共卫生平台，实现公共卫生信息决策和支持，通过协同办公平台，实现职工总医院卫生行政体系统一集中管理，业务范围涵盖了基础平台、病人及费用管理、医技业务管理、临床业务管理、协同办公等子系统，该系统采用数据库/应用服务器/客户端三层结构，其中客户端用c#开发，数据库用SQLSERVER，采用基于SOA集成平台传递接口信息，统一集成服务。</p><p>HIS项目是一个综合性的系统工程项目，包括了各医院、分院、社区卫生服务中心，在管理模式上存在较大差异，各个地区工作流程也不一致;从技术角度涉及协同办公、工作流、全文检索、备份归档、无线通信等相关技术;人力资源方面，需要不同专业技术的开发人员，可能会存在多部门之间的协作;协同办公是公司新的业务领域，我方领导也希望将本项目作为公司业务延伸拓展的一个新的窗口。由此可见，该项目组织构成复杂、干系人面广人多、技术难度高，而且涉及新的业务领域，风险之大可想而知。因此，在该项目中，我充分重视了风险管理，按照项目风险管理理论，通过计划编制、风险识别、风险分析、风险应对、风险监控等方法，有条不紊地完成了该项目。具体来说，我是按照以下基本的管理过程来进行风险管理的。</p><p><strong>1、制定风险管理计划，识别项目风险</strong></p><p>首先，制定风险管理计划，识别项目风险。谨慎、清晰的计划能够提高风险管理过程的成功概率。因此，我们采用会议的方法来制定风险计划，所有的项目干系人代表都被邀请参加了风险管理计划会议，全面地考虑了风险对项目的影响，确定如何为该项目处理和执行风险管理活动。在计划中，具体描述了基本的风险管理活动(如每15天召开一次风险评估会议)，根据项目管理理论和我公司的项目实践，定义了项目中的风险管理过程，估计了风险管理的时间表和费用，并把风险管理活动纳入了项目计划，把风险管理费用纳入了成本费用计划。根据项目的实际情况，我们把项目中的风险划分为技术风险、团队风险、外部风险三大类，采用风险分解结构(RBS)形式列举了已知的风险，把技术问题的解决、需求和范围定义不清、WBS分解粒度不够细化、用户参与不足、缺乏领导支持、等作为项目计划阶段的主要风险事件。在识别了上述风险后，我们还确定了这些风险的基本特性，引起这些风险的主要因素，以及可能会影响项目的方面，形成了详细的风险列表记录.</p><p><strong>2、定性和定量风险分析</strong></p><p>其次，对风险做定性和定量分析，评估风险的影响。我们根据风险管理计划中的定义，确定每一个风险的发生可能性，并分析每一个风险对项目的影响，包括对时间、成本、范围等各方面的影响。其中不仅仅包括对项目的负面影响，还分析了风险带来的机会。在这个过程中，我们还是采用会议的方式来进行的。不过，在风险分析的会议中，除了有关项目干系人外，我们还邀请了相关领域的专家参加，以提高分析结果的准确性。例如，对于移动应用、电子签章、工作流等技术类风险的分析，我们就邀请了业内著名的专家参与评估。在确定了风险的可能性和影响后，接下来需要进一步确定风险的优先级，风险优先级是一个综合的指标，其高低反映了风险对项目的综合影响。我们采用了风险优先级矩阵来评定风险优先级的，最后得出的结果是公文数据安全的风险排在第一位，该风险的可能性很高，影响也很大。</p><p>对已知风险进行定性分析后，我们还进行了定量分析，定量地分析了各风险对项目目标的影响.在这个过程中，我们采用了专家评估的方法，组织相关成员对项目进行乐观、中性和悲观估计，同时，也利用了我公司历史项目的数据，用来辅助评估.进行定量分析之后，更新了风险记录列表。</p><p><strong>3、制定风险应对计划</strong></p><p>再次.制定风险应对计划编制，加强风险监控。根据定性和定量分析的结果，我们对已识别的风险，制订了应对计划。对不同的风险，采取了不同的应对措施和缓解计划，对每个计划都制定了责任人。我们定期对已经识别出的风险的状态进行跟踪，监控风险发生概率和影响度的变化。在这个过程中，主要采用了偏差分析、项目绩效分析和监控会议的方式来进行的。监控风险发生标志，更深入地分析已经识别出的风险，继续识别项目中新出现的风险，复审风险应对策略的执行情况和效果。根据目前风险监控的结果修改风险应对策略，根据新识别出的风险进行分析并制定新的风险应对措施等。</p><p>对于一些技术风险，例如移动办公方案的确定上，我们根据苹果、安卓、windows等三款不同的操作系统的手机开发了公文审批的POC原型，给领导和用户进行演示，在术评审会我们还邀请了第三方专家参与，对各种方案进行比选和、决策分析和测评。通过这些方式，一来有效的保障了阶段性开发的质量;二来可以最大程度的得到用户的理解与支持;三来将项目整体风险化整为零。</p><p><strong>4、风险监控</strong></p><p>最后，加强主要风险的追踪，在各个阶段保持良好的风险意识。我们把需求和范围定义不清、WBS分解粒度不够细化、用户参与不足、缺乏领导支持、技术问题等作为项目的主要风险事件，按级别排序张贴在公告栏上。事实表明，这种做法效果明显。特别是客户方面，我定期把风险事件列表通过Email发给客户方项目负责人和主管领导。公司高层也对项目的质量状态和风险情况很关心，多次出现在项目例会和阶段性评审会议上。由于有效的风险控制，加之领导的重视，项目小组人员受到鼓舞，士气高涨，积极性和自信心明显增强，使得项目得以顺利实施。</p><p><strong>结束语</strong></p><p>由于我们分重视项目的风险管理，项目按期保质完成，客户很满意，也为今后公司类似项目积累了经验，得到了公司管理层的高度评价，这归功于整个团队的配合。但是回顾起来，也有一些不足的地方：因为工期紧，任务重，所以经常加班，大家非常疲惫，导致团队成员做事效率低下，积极性不高，项目出现了团队风险。我也采取了一些补救的措施，如请示管理层在精神方面做了一些鼓励和表扬，适当聚餐、看电影、组织健身活动，一定程度上缓解了紧张的氛围，大家也没了太多的怨言。总之，项目风险的管理方式多种多样，因人而异、因项目规模而异，管理方式不是一成不变的。适合自己的管理模式才是最好的模式，这些都有待于我们进一步研究、探索、实践和总结。</p><h3 id="9-1-范文二"><a href="#9-1-范文二" class="headerlink" title="9.1 范文二"></a>9.1 范文二</h3><p>由于项目参与人员较多，功能和目标复杂，工期较长，规模较大，加上电力公司高层对该项目期望值高，项目的风险大大增加。因此我对风险管理方面给予了高度的重视。我针对项目的特点，结合团队的实际情况，主要从风险管理计划编制、风险识别、风险定性分析、风险定量分析、风险应对计划和风险监控这几个环节对风险进行了管理：</p><p><strong>一、风险管理计划编制</strong></p><p>风险管理计划主要描述了在项目中如何组织和执行风险管理。俗话说，好的开端是成功的一半，拥有谨慎和清晰的计划必然能够更有效地做好风险管理。因此，我们在项目计划阶段广泛收集了以往类似项目的管理执行情况和经验，根据本项目内部、外部环境特点和制约条件，制定了本项目的风险管理计划。在风险管理计划中，我们规定了实施风险管理的方法、人员职责的分配和风险类别，估计了风险管理的成本，明确了风险报告的记录与格式、风险跟踪机制等内容。另外，为了能够有效地跟踪控制风险，我们决定每半个月召开一次风险评估会议。</p><p><strong>二、风险识别</strong></p><p>风险识别就是要确定项目中存在哪些潜在的风险，识别引起这些风险的主要因素和风险可能引起的后果。在前两次风险评估会议上，我召集了全体项目组成员进行<strong>头脑风暴</strong>，并访谈了单位里面一位有过类似项目经验的项目经理。通过会议和访谈，我们得到了项目的<strong>风险登记册</strong>，将风险主要划分为了内部风险和外部风险两类。</p><p>内部风险主要体现在技术风险上面，因为本项目所涉及的窃电防控监测技术需要进行一定的算法分析和设计，监测当前所有典型窃电行为，质量要求极高。另外，有几名项目团队成员缺乏相关开发经验，技术不够熟练。外部风险主要是电力公司领导对此项目非常重视，可能会有项目范围和进度变更，这可能影响到项目进展和按时交付。</p><p><strong>三、定性和定量风险分析</strong></p><p>定性风险分析就是对已识别风险进行优先级排序，重点关注高优先级的项目风险。我首先将<strong>风险发生的概率</strong>分为“极低、低、中、高、极高”这五级（对应值是0.1、0.3、0.5、0.7和0.9），影响分为大中小三级（对应值是0.3、0.6和0.9），然后召集项目干系人和全体项目成员认真<strong>评估</strong>了每个风险的概率和影响，<strong>用概率和影响矩阵</strong>对各个风险进行了排序。例如无法和电力公司已有系统相兼容的概率虽然为中级，但是影响非常大，于是它的优先级较高，排在前面。而电力公司提出变更的外部风险虽然造成的影响比较大，但是我们考虑到电力公司和我单位有过长期合作，此前一般不会提出重大变更，其发生概率是较低，且项目留有足够的应急时间，可以接受此风险，从而优先级较低，排在后面。</p><p>定量风险分析就是定量地分析风险对项目目标的影响，这能够让我们更科学的以数据来做决策。我们主要使用了决策树估计方法，进一步从量化的角度确定了不同风险对项目各个阶段的影响程度。</p><p><strong>四、风险应对计划</strong></p><p>风险应对计划就是对经过定性、定量分析后更新的项目风险记录表进行分析，进一步确定哪些是对项目有利的机会，哪些是对项目不利的威胁，合理制定有针对性、可行的应对措施的过程活动。在项目进展过程中，我们主要防控了以下几个风险：</p><p>1.为避免外部接口风险发生，我专门指定了一名技术人员，负责与电力公司领导、电力公司已有基础系统开发商进行接口相关工作的沟通联络，定期沟通汇报，一旦出现问题，我们将集体进行分析研讨，迅速解决问题。</p><p>2.针对技术风险，我向公司申请了两名经验丰富的高级工程师，邀请了技术专家对不熟练人员进行了内训，同时制定奖励措施，激励项目组成员自主学习和相互分享知识。</p><p>3.在项目详细设计将要完成时，电力公司客户代表提出，公司领导想要提前考察系统概况，希望我们能够先做出一个简易版本。由于此项变更可能对项目质量、进度、成本都造成重大影响，让项目面临更多的风险，因此我们对变更可能造成的各方面影响进行了分析，决定将此简易版本作为一个单独的附加项，在不影响正式版本进展的前提下，简易版本和正式版本的编码工作并行进行。随后，我们提交变更控制委员会，得到了批准。接着我们着手实施变更和监控，并通知了各项目干系人和项目组成员。经过团队成员的努力，简易版本很快开发完成，电力公司领导对此非常满意，项目风险也没有失控。</p><p><strong>五、风险监控</strong></p><p>风险监控在项目全过程中进行，就是跟踪已识别的风险，监测残余风险和识别新的风险，保证风险计划的执行，并评价这些计划对减轻风险的有效性。因此我要求各团队成员定期对风险进行状态审计和评审，并根据风险监控的结果来适当修改应对策略，始终将风险掌握在可控制的范围内。</p><p>2015年11月，经过项目组团队成员的共同努力，窃电防控系统最终按时上线运行了，顺利实现了预期功能，得到了电力公司的高度认可。但是在风险管理过程中也有不足之处，例如每半个月召开的风险评估会议没有做好计划，都是在会前临时想到要做什么才在会上提出，这导致有些时候会议没有得到实质性结果，团队成员也厌烦了无用的会议，积极性不高。不过由于其他方面工作充分，并没有产生什么影响。在后面的项目和工作中，我会更加努力，改正缺点，不断提高风险管理水平，更好地管理各个项目。</p><h2 id="十、采购管理"><a href="#十、采购管理" class="headerlink" title="十、采购管理"></a>十、采购管理</h2><h3 id="10-1-范文一"><a href="#10-1-范文一" class="headerlink" title="10.1 范文一"></a>10.1 范文一</h3><p><strong>摘要：</strong><br>　　2015年1月，深圳市交警局交通科研所开展了交通信息采集与信息共用平台项目以下简称”平台项目的开发工作，该平台项目是在多个现有交通监控系统的信息数据整合及汇总的基础上，按照业务要求，以一定的算法对交通历史数据作出融洽、加工及统计分析等操作。为用户提供实时、准确的市区内整体交通状况，实现智能化交通管理及监控。我有幸参与了解这个项目的建设，主要负责其中的项目采购管理和合同管理工作。 </p><p>项目采购是从项目组织外部购买项目所需的产品和服务的过程，通过采购外单位的产品或服务，以满足自身业务的需求，提高自身业务能力水平和效益。合同管理则是确保供方的执行符合合同的要求的过程。本文通过描述了本平台项目的项目采购管理过程，详细论述了项目中的采购管理和合同管理，以及采取的策越和步骤。同时，就本项目的采购管理和合同管理出现的问题和相应措施进行了一下反思。 </p><p><strong>正文：</strong><br>　　2015年1月，我参与了深圳市交警局交通科技研究所的平台项目的建设工作。在本平台项目建设之前，该交警局就已有多个交通应用系统，如：ATC及SMOOTH交通监控系统、网络化车牌识别系统、交通诱导系统及OCTV人工录入系统等。尽管这些系统在各自的领域里都能各司其职，但系统间彼此孤立，其交通信息数据的共享性和整合性较差，建设之初并且有考虑对市区整体交通信息数据的分析和利用。因此，就有必要建设一个能够充分整合现有交通应用系统各类交通信息的综合信息平台，以便实现各类交通信息的开发和共享。同时，通过平台的数据统计分析工作，把更完整、可靠的数据发送给外部发布系统，做到更加准确和及时的交通监控，从而实现智能化交通管理。 </p><p>　　交通科技研究所是交警局一附属企业，主要负责交警局新建系统项目的开发管理及对现有系统的维护。本所具有一定的开发能力，也有一些项目管理的经验，但人手较少，现有技术骨干人员手头上都有相关的项目在管理和维护中。更为关键的是：本市8月中旬将举行世界大学生运动会，根据交警局领导的批示，本平台项目必须在6月底上线，试运行一个月后，就要正式投入大运会交通监控管理的工作中。鉴于项目工期较紧迫，而且项目非常强调系统的稳定性和成熟性，我所经过几次研讨会议，决定通过向外单位采购方式解决项目需求。 </p><p>　　采购策略可分为招标采购和非招标采购，招标采购就是由我方提出招标条件和要求，由多方供应商参与投标。通过招标的方式，我方能获得比较合理的价格和优质的产品和服务，同时也可以促进供应商之间的公平竞争。非招标方式多用于标识规格的产品采购，通过市场多方询价的方式，选择供应商，相对比较简单方便。而对于项目的采购管理过程而言，则可分为6个过程： </p><p>　　采购计划编制：确定是否采购，采购什么，如何采购、何时采购等问题；合同编制：包括准备招标、询价所需要的文件和确定合同签订的评估标准。记录项目对于产品和服务的需求，并且寻找潜在的供应商；招标：依法公平、公正、公开地进行招标工作，发布项目采购招标书，接受供应商的投标书；供方选择：按照科学、合理的评估标准，组织相关专家进行评标活动，审查、比较所有投标书，选择综合能力及性价比较高的供应商与之谈判并签订最终合同；合同公里：合同管理是依据签署的协议，确保供方的项目建设活动符合合同要求的一系列过程；合同收尾：包括确认产品或服务是否符合合同要求，以及对项目管理过程的收尾。 </p><p>　　采购工作说明书，是根据项目范围说明书、WBS和WBS字典制定而成。说明书详细地规定了采购项目，以便潜在的供方确定他们是否有能力提供项目。项目合同就是定义买卖双方各自义务的协议，对于供应商而言，就是定义其提供的指定产品或服务，项目验收标准、款项交付等事项的协议。项目合同是项目的采购管理计划得以瞎利实施的保证。 </p><p>　　综合项目的复杂程度和专业性，我所决定通过招标方式，选择实力及规模较大的行业领先软件企业作为项目的软件供应商。对于硬件设备，其价格比较透明，技术参数标准化程度较高，购买及维护也比较方便。因此，我们决定自行通过国内代理商订购所需产品。 </p><p>　　对于项目的采购过来工作而言，其成败的关键在于采购计划编制活动、招标活动的科学合理的安排以及对项目采购合同的完善管理： </p><p>　　一、充分了解项目状况和项目实际需求，做好采购计划编制。 </p><p>　　在编制采购计划前，我们组织相关行业特别是有同类型项目经验的专家，对平台项目的开发成本做了估算。一方面，估算平台大致成本，以便检查是否有直接预算支持；另一方面，也可以作为合同的一个约束条件，控制项目成本。经过多次商讨，定出成本估算值，并决定采用固定总价合同类型。 </p><p>　　编制项目采购计划最忌“关起门来，自作自受”，详细、科学、合理的采购计划是以项目实际情况作为立足点的。特别是对本平台项目，涉及多个不同的应用系统，用户类型和交涉的部门都比较多。因此，在制定采购计划前，我们多次走访各部门业务人员，并特别就业务关键岗位进行了全方位的学习和深入了解。这大大方便了我们界定清楚项目范围，制作出初步的项目范围说明书，并以其为基础制作项目采购工作说明书及采购管理计划。 </p><p>　　二、科学、合理的招标过程，是为了通过公平、公开的竞争，让优秀的供应商脱颖而出，这也是获得优质的项目成果的关键。 </p><p>　　在招标过程中，我们先在本市的政府采购中心网站登记相关招标信息，并举行了最初的供应商碰头会，以便我们就参与投标的各个供应商一个初步了解，也有利于潜在供应商对我们的项目有一个清晰、共同的理解。投标之前，我们同行业专家就相关竞标企业进行了摸底排查，大致对其规模和实力有一定的了解。同时，就平台项目的实际情况，制定了评标的标准及策略。招标过程中，我们先根据本行业信息系统的要求，设置筛选系统要求竞标企业必须拥有计算机信息系统集成二级（或以上）资质和国家涉密计算机系统集成乙级或以上资质。然后依据前期研讨会确定的项目技术参数及验收标准，按照重要程度对每一个评价标准设定一个权重，按照供方所得项目技术标准综合分，结合项目建设价格作为选择供方的依据。 </p><p>　　经过几轮评选活动后，我们选择了一家规模和实力较大，技术综合得分及性价比都比较高的A公司作为本平台项目的供方。A公司作为本行业的领先者，拥有多个类似项目的成功案例，而且之前也和本市警局做过其他业务项目，用户口碑和行业评价都比较好。因为之前与交警局有过合作项目，也比较熟悉我方的采购管理流程。 </p><p>　　三、合同管理是确保供方的执行符合合同要求的过程，是规范供方项目建设行为的标准。 </p><p>　　鉴于本平台项目的特殊情况，在本合同中，我们特别强调平台项目的交付期和质量。平台项目开发期从2015年1月中旬开始，计划6月底交付系统并进行试运行。合同的付款方式，我们按照这一的模式进行：附有首付款，按照项目关键里程碑设置多个进度款，每个里程碑能如期完成的支付特定额度的款项一般为合同的20%-30%。未能按期完成的，按照进度情况处于相应罚款。平台项目能如期充工，并顺利通过试运行及验收，按合同说明共支付90%的合同额。项目建设完成后，留10%作为尾款，在供方免费维护期过后一年付清。系统开发过程中涉及交警局的机密信息和部分执法信息，对此，我们也做了信息保密的要求。在多方共同合作努力下，平台项目在2015年6月底顺利通过验收，基本实现了合同协议和项目范围说明书的要求。经过一个月的试运行后，正式投入使用，并在大运会期间获得良好的实用效果，得到了相关领导和国外来宾的高度评价。 </p><p>　　我也就项目采购管理过程的一些不足之处进行了反思，例如：合同管理中，我们就A公司一些不符合合同要求的现象，在未经沟通情况下，对其进行了处罚。A公司认为是双方沟通不到位造成的，所以对单方面的处罚多有微词。经过这次项目建设，我体会到，项目合同不应该成为甲方的“棒子”，而是作为双方共同为项目目标努力的标尺，这也是项目采购管理的成功保障。</p><h3 id="10-2-范文二"><a href="#10-2-范文二" class="headerlink" title="10.2 范文二"></a>10.2 范文二</h3><p><strong>摘要</strong></p><p>2014年4月，我参加了某市质量技术监督局金质工程软件部署及适应性维护项目的实施，担任本项目的项目经理。该项目投资约915万元人民币，建设工期为6个月，该项目是为了促进各级质监机关向管理服务型转变，提高质量监督检验检疫执法的透明度，形成全国统一的质监大网络，促进质监系统执法电子化、信息化，为生产企业和外经贸企业带来更大的方便与效益，加大打击假冒伪劣的力度，更有效地规范市场经济秩序，促进社会主义市场经济的发展。本文结合作者的实际经验，以该项目为例，讨论信息系统项目建设过程中的项目的采购管理，包括编制采购计划、编制合同、招标、供方选择、合同管理、合同收尾等六个过程。</p><p><strong>正文</strong></p><p>2014年4月，我参加了某市质量技术监督局金质工程软件部署及适应性维护项目的实施，担任本项目的项目经理。该项目投资约915万元人民币，建设工期为6个月，该项目是为了在某市质监系统各单位统一部署由国家局下发的金质工程软件并对该软件进行适应性维护，促进各级质监机关向管理服务型转变，提高质量监督检验检疫执法的透明度，形成全国统一的质监大网络，促进质监系统执法电子化、信息化，为生产企业和外经贸企业带来更大的方便与效益，加大打击假冒伪劣的力度，更有效地规范市场经济秩序，促进社会主义市场经济的发展。该项目建设内容包括在市局中心机房建设配套本项目的服务器及存储系统、网络及安全系统、数据库软件、操作系统软件、防病毒软件、部署“金质工程”一期建设成果内各系统并针对该市特有情况和国家局出台的最新规定对本软件进行适应性维护，为各派出局、所及检测站点建设直连市局的数据专线，使各派出局、所及检测站点可以访问、共享此次金质工程软件部署、维护工作的建设成果，简化各单位办事流程。</p><p>由于本项目的顺利上线涉及到业务的考核，因此，本项目中，采购管理尤为重要。项目的采购管理，包括编制采购计划、编制合同、招标、供方选择、合同管理、合同收尾等六个过程。是从项目外采购所需的产品和服务的过程，通过流程化、标准化的采购管理和运作，运用高效合理的活动，可以达到降低成本、增加公司利润的目标。在本项目中，我作为项目经理除了对其余管理领域进行恪尽职守的管理外，特别对采购管理从如下几个方面进行了管理。</p><p> 1.根据项目的实际情况，科学编制采购计划</p><p>编制采购计划是项目采购管理的第一步。我们可以通过采购计划，确定项目是否需要采购、如何采购、采购什么、采购多少、以及何时采购。在该项目中，除金质工程软件外所有软硬件产品都需我们外购。我们要采购的软件产品主要有：金质工程软件配套使用的操作系统、数据库、中间件等软件产品以及能方便地进行日常网络管理维护、网络及终端安全管理的软件产品等。而所需采购的硬件产品主要有服务器、存储设备、网络设备、不间断供电设备以及操作控制电脑等。我们以项目所需采购的产品为基础，科学地制订了一个较为完善的采购计划。该采购计划明确了采购产品清单、采购数量、采购方法和采购时间等重要信息。</p><ol start="2"><li>高度重视合同编制</li></ol><p>为了保障外包采购的有效性，按时、高质量的获得外部产品和服务资源，必须高度重视采购合同的编制过程。在这个环节，我主要组织业务部门专家，通过头脑风暴的方式并参考公司以往成熟的采购合同来准备本项目的合同编制过程中的采购文档及评标标准。由于本项目技术方案基本确定，故采购文档的主要目标便是向潜在的供应商征集产品报价，同时以此了解供应商对我方所需产品及服务的理解程度，我们结合本项目的整体技术方案和国家局技术中心发布的金质工程软件运行环境要求，作为供应商编制方案报价的输入，也为评估的精确程度提供了依据。在制定合同采购文档的同时，制定了对投标书的评级和打分评估标准，提出了对供应商的各方面能力的明确要求。</p><ol start="3"><li>精心组织招标活动</li></ol><p>商务标由公司商务部统一处理，我们从项目成本角度协助参与。我作为项目经理，重点关注技术标部分的独立评估，我采用加权系统作为供应商选择的工具和技术，组织专家从几个维度来考虑供应商的技术维度的适合程度，将不同的评价标准设定不同的权重。第一，供应商的技术实力；第二，对我方需求的理解程度；第三，现场响应速度及售后维护服务；第四，供应商在业界的口碑。在几个细项中，我将供应商的技术实力、对我方需求的理解程度，以及现场响应速度及售后维护服务设置了比较高的权重，以保证合作供应商的综合能力，避免因供应商能力不足而不能满足项目整体进度及质量的要求。组织公司专家库专家通过技术标的比选背靠背打分的方式，客观给出各个投标供应商的技术能力评分，结合商务报价，最终选出若干合格的供应商作为本项目的产品供货合作伙伴。</p><p> 4.对产品供方进行评估，以选择最佳供方。</p><p>招投标活动结束后，我们下一步要做的就是选择合适的供货方，实施项目的产品采购。经过市场调研和多方询价，有人提出使用盗版软件的建议。但我认为：使用盗版软件虽然能省下巨额的项目成本，但它也给项目埋下了巨大的风险：一是软件的安全性和稳定性无法得到保证；二是如果被相关公司发现并予以起诉，后果更加严重；三是合同要求我方所***品必须为正版产品，违背合同规定的责任是我方所无法承受的。所以，我们决定购买正版的产品。对于硬件产品，市面上的服务器和PC的架构主要有intel和amd两大供应商体系。我们决定选用intel的产品，因为intel体系的产品在业界口碑更好，工作能耗、效率、速度和稳定性优于AMD的对应产品。国内的服务器提供商有多家，如戴尔、惠普、联想、曙光等。经过询价和技术实力对比，我们决定选用曙光的服务器产品。其原因是：曙光产品的性价比较高，技术实力特别雄厚，另一个因素是客户方也倾向于采购国产品牌。</p><p> 5.严格执行合同管理的规章制度，通过流程保证双方权利。</p><p>合同管理包括对合同关系应用适当的项目管理过程并将这些过程的输出集成到整个项目的管理中。在各供货商履约供货的过程中，我同步推进着绩效监控和质量控制活动，我及时发现该市开始了大规模的道路改造工程，而项目实施现场大多位于改造路段附近，交通受阻严重，虽然各供应商都按合同约定的时间开始了供货，但是受交通条件影响，部分产品出现了未能按期到场的情况。我立刻小幅调整项目实施计划、主动采取多种有效的纠偏措施，将该现状所造成的不利影响降到了可以忽略的程度。鉴于这一现象是因不可抗拒力而产生，并非供货商故意不按合同履约，且未对项目正常实施造成过重的拖累，我在与各方干系人充分沟通协商并取得各方谅解后按照合同管理流程通过变更控制委员会为各供货商办理了供货延期的相应变更手续，为其按合同结算货款提供了方便，保障了供货商的合法权益。</p><p> 6.完善合同收尾过程。</p><p>合同收尾的工具和技术有采购审计和合同档案管理系统。各供货商完成供货义务，所***品品牌、型号、数量、质量、价格等要素得到了我公司采购部门和质量管理部门的一直认可，并由项目部人员接收用于本项目的安装实施工作。项目即进入了合同收尾阶段，在这个阶段里，我们组织公司有关部门和人员进行了采购审计活动，详细检查分析了我所组织实施的采购管理的各个环节，肯定了我的成功之处，也找出了一些做的不够细致的地方，形成审计报告后更新入组织过程资产，供未来项目参考改进。</p><p>经过我们团队的不懈努力，历时6个月，本项目终于在当年国庆节前通过了建设单位组织的项目最终验收，它的成功得益于我成功的采购管理。在后续的学习和工作中，我将不断的充电学习，多多和同行进行交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的贡献。</p><h3 id="10-3-范文三"><a href="#10-3-范文三" class="headerlink" title="10.3 范文三"></a>10.3 范文三</h3><p><strong>摘要</strong></p><p>2018年9月，我公司中标了“某省彩票中心社会化渠道平台”建设项目，我担任项目经理一职，建设费用为350万，工期为5个月。彩票中心希望通过本项目建设，扩展彩票社会化销售渠道，为彩民提供多元化购彩环境。本文结合该项目采购管理的实践工作经验，采用了PDCA循环管理方法，以及科学、合理的运用项目管理工具与技术，通过项目过程的持续改进，控制和协调好项目采购工作，本文讨论信息系统项目建设过程中的项目的采购管理，包括编制规划采购、实施采购、控制采购、结束采购(采购计划、编制合同、招标、供方选择、合同管理、合同收尾等六个)等过程。本项目于5月20正式投产，至今良好运行，受到用户方和公司的一致好评。</p><p><strong>正文：</strong></p><p>2018年9月，某彩票中心为了加快建设多元化彩票销售渠道，将本项目列为2017年重点工作，项目主要包括两大部分，其一为系统功能包括：彩票游戏销售、兑奖、移动支付、会员管理、资金结算、数据报表、监控和预警等模块功能;其二为系统硬件其功能包括：自助一体机。在项目管理过程中分别采用MSProject.VSS工具完成项目管理和配置管理工作，实现对项目整个生命周期各个环节进行监控，实时动态反应项目各阶段执行情况，进行控制和分析，计划投资350万，工期5年，系统采用B/S体系结构，以Oracle数据库为支撑，符合“金保工程”技术规范和联网要求。开发过程应用轻量级J2EE架构，采用Spring进行中间层(业务层)建设，应用服务器是DELL塔式商用服务器，业务逻辑采用JAVA技术实现。由于前期项目招标过程中我是主要参与者，对项目情况比较了解，通过公司领导发布项目章程，我有幸获得了公司领导与甲方客户的信任，成为高级项目经理，全面主持项目管理工作。在此之前公司没有做过类似案例，彩票业务领域经验不足，项目实施难度大，技术要求高，干系人复杂，为了保证该项目的顺利完成，我采用了项目型的管理方式和间接管理模式，将项目分解为二个子项目，并任命李某、张某为子项目管理，采用项目管理知识和项目管理系统指导项目工作。</p><p>我们最终决定将主要精力放在项目管理上，规划和监控项目实施，由于本项目的顺利上线后会接受上级管理部门审计工作，因此，本项目中采购管理尤其重要。项目的采购管理，包括编制规划采购、实施采购、控制采购、结束采购(编制采购计划、编制合同、招标、供方选择、合同管理、合同收尾等六个过程)。是从项目外采购所需的产品和服务的过程，通过流程化、标准化的采购管理和运作，运用高效合理的活动，可以达到降低成本、增加公司利润的目标。在本项目中，我作为项目经理除了对其余管理领域进行恪尽职守的管理外，科学合理的采购工作能够为后续项目顺利开展奠定了基础，保证了项目范围、时间、成本、质量、资源等各要素过程能相互协调统一，最终项目能按计划顺利实施交付使用。该项目的成功归功于对项目采购的有效管理，通过如下几个方面进行简要论述：</p><p><strong>一、根据项目实际需求，科学编制采购计划</strong></p><p>规划采购并制定科学合理的采购管理计划是开展任何项目活动之前的必要工作，也是项目采购管理的开始，制定有效的采购计划，能够确定项目是否需要采购、如何采购、采购什么、采购多少、以及何时采购。我邀请了公司采购部门负责人、外聘采购专家、福彩中心技术部领导以及团队成员一起进行了项目采购研讨工作，我根据《项目管理计划》、《需求文档》、《活动资源要求》、《项目进度》、《活动成本估算》、《项目范围说明书》、《工作分解结构WBS》及《WBS字典》等资源进行了认真分析，通过专家技术性判断最终确定，对非主体部分会议管理子系统的建设进行外包，开始项目采购工作，选择招标采购方式，合同方面采用固定总价合同，最终开成了本项目的《采购管理计划》、《采购工作说明书》和《采购文件》，以指导采购管理过程中编制合同、招标、供方选择、合同管理、合同收尾等工作的开展。该采购计划明确了采购产品清单、采购数量、采购方法和采购时间等重要信息。同时还生成了《采购工作说明书》，详细描述了工作的具体地点、完成的预定期限、具体的可交付成果、付款方式和期限、相关质量技术指标、验收标准等内容，以便供应商提供符合采购管理要求的产品。项目采购管理，是指从项目外采购工作所需的产品和服务的过程在该项目中，除系统软件外所有软硬件产品都需外购。我们要采购的软件产品主要有：金质工程软件配套使用的操作系统、数据库、中间件等软件产品以及能方便地进行日常网络管理维护、网络及终端安全管理的软件产品等。而所需采购的硬件产品主要有服务器、存储设备、网络设备、不间断供电设备以及操作控制电脑等。我们以项目所需采购的产品为基础，科学地制订了一个较为完善的采购计划。该采购计划明确了采购产品清单、采购数量、采购方法和采购时间等重要信息。</p><p><strong>二、综合软硬件需求，选择最佳供应商，完成实施采购工作</strong></p><p>根据《采购管理计划》、《采购文件》和《采购工作说明书》。本项目中我们确定了项目采购策略，以公开招标、内部该村与询价相结合的方式，对采购金额大于100万元以上项目设备、产品采用公开招标，内部议标的方式，对于采购金额低于100万以下的项目设备、产品采用询价方式。在制定好采购计划后，我们成立了采购小组，负责项目的设备采购与软件外包的管理工作。采购小组按照制定的采购策略采取邀请招标方式进行采购，首先根据行业的标准和系统要求，对国内主要3家外包软件公司进行了详细的调研，并向他们发出了详细的邀请书，经过评标对比各软件公司的投标书，根据招标文件要求，邀请专家和甲方代表组成招标小组，经过综合评份，选择了一家资质良好，资金和技术实力强，报价合理的软件公司，并签字了合同，在合同中，我们特别强调了开发软件的质量和交付日期，在软件的开发中，对于保密资料作了要求。完成采购合同签订工作，其包括货物或服务名称、技术要求、数量、价格、交货期限地点和方式、验收方式、违约责任和结算方式。我们从项目成本角度协助参与。我作为项目经理，重点关注技术标部分的独立评估，我采用加权系统作为供应商选择的工具和技术，组织专家从几个维度来考虑供应商的技术维度的适合程度，将不同的评价标准设定不同的权重。第一，供应商的技术实力;第二，对我方需求的理解程度;第三，现场响应速度及售后维护服务;第四，供应商在业界的口碑。在几个细项中，我将供应商的技术实力、对我方需求的理解程度，以及现场响应速度及售后维护服务设置了比较高的权重，以保证合作供应商的综合能力，避免因供应商能力不足而不能满足项目整体进度及质量的要求组织公司专家库专家通过技术标的比选背靠背打分的方式，客观给出各个投标供应商的技术能力评分，结合商务报价，最终选出若干合格的供应商作为本项目的产品供货合作伙伴。</p><p><strong>三、跟踪项目实施，控制采购</strong></p><p>顺利完成采购实施工作后，各供应商根据各自合同要求，正式进入合同履行阶段，我们针对供应商合同执行过程进行绩效监控，确保按照合同要求及时完成可交换物。跟踪软件开发和通用硬件采购工作，跟踪各供应商实施供货过程。及时处理合同管理方面的工作。在开发中，我们首先要求外包软件公司按照我们预先指定的开发流程进行软件开发，严格执行合同中的实施进度，每周提交本周工作报告和下周工作计划，每月提交工作月报，加强了外包的监控。虽然各供应商都按合同约定的时间开始了供货，但由于临近春节EMC存储需要复杂的海关手续，与预计划时间延迟交货，出现了未能按期到场的情况。我立刻小幅调整项目实施计划、主动采取多种有效的纠偏措施，将该现状所造成的不利影响降到了可以忽略的程度。，且未对项目正常实施造成过重的拖累，我在与各方干系人充分沟通协商并取得各方谅解后按照合同管理流程通过变更控制委员会为各供货商办理了供货延期的相应变更手续，为其按合同结算货款提供了方便，保障了供货商的合法权益。(根据项目管理计划、采购文件、合同、批准的变更请求、工作绩效报告和工作绩效数据等，是进行控制采购过程的前提。采购文件归档(采购文件评审、采购合同文件、采购验收和结算文件。)采购化物管理(存放环境、设备存放和标识、进货日期、入库条件、)输出：工作绩效信息，包括了合同履约情况，可交付成果完成情况，追踪未交付的成果。)</p><p><strong>四、结束采购</strong></p><p>采购合同履约结束后，我们按照合同规定支付了分包商费用，并组织相关人员对本次采购工作的经验和不足进行了总结。</p><p>本项目采购中部分供应商承诺按时交付的工作成果出现延期，开始认为是供应商人员不足，安排增加人手，达到了一定的效果，另外，我专门安排一位项目成员负责跟踪供应商，把供应商管理作为项目团队管理的一部分，把供应商计划作为总计划的一部分，把供应商执行纳入项目监控范围，发现问题当即整改，在我们严格要求下，供应商工作进度明显改善，工作进度能够中上整体的进度。</p><p>合同收尾。软件外包部分功能的达不到合同技术要求，我们供应商对项目整体的需求理解存在一定的偏差，因此每次与甲方进行项目沟通时，都会邀请供应商一同前往进行讨论，尽量将双方信息一致，多让承包商参与需求调研，直接听取用户的意见，效果明显。合同收尾阶段，我们组织公司有关部门和人员对采购过程进行了采购审计活动，详细检查分析了我所组织实施的采购管理的各个环节，肯定了我的成功之处，也找出了一些做的不够细致的地方，形成审计报告后更新入组织过程资产，供未来项目参考改进。</p><p>经过我们团队的不懈努力，历时6个月，本项目终于在当年国庆节前通过了建设单位组织的项目最终验收，它的成功得益于我成功的采购管理。在后续的学习和工作中，我将不断的充电学习，多多和同行进行交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的贡献。</p><h2 id="十一、通用模板"><a href="#十一、通用模板" class="headerlink" title="十一、通用模板"></a>十一、通用模板</h2><p><strong>摘要</strong></p><p>2020年10月(接近考试时间)，我作为项目经理参与了XXX信息系统建设的项目，该项目投资共800万元人民币，建设工期为1年，通过该项目的建设，实现了······，该项目于2021年10月，通过了业主方的验收，赢得了用户的好评。本文结合作者的实际经验，以该项目为例，讨论了信息系统项目建设过程中的XX管理(具体根据考试题目来)（200-330字）。</p><p><strong>正文</strong></p><p>2020年10月，我作为项目经理参与了XXX信息系统建设项目，该项目投资共500万元人民币，建设工期为1年，我们组建了XX型组织的团体，包括项目经理1名，项目经理助理1名，系统架构师1名，系统设计师3名，网络工程师1人，程序开发工程师4名，实施工程师4名，数据分析师2名，测试工程师2名，安全工程师2名，质量保证人员（QA）2人，文档配置人员2人,共25人。其软硬件全部部署在华为云，为了安全，采取三层网络架构模式，分为核心层、业务层、缓冲层，每一层之间都部署有下一代防火墙设备。核心层主要是部署数据库服务器及网络存储设备，只允许业务层服务器访问，业务层主要是部署各模块服务器及接口服务器，缓冲层主要部署互联网服务器。服务器绝大多数是采用linux操作系统，有部分接口服务器使用windows，该系统采用JAVA语言开发，数据库采用的oracle，采用b/s模式，便于系统快速升级及部署。在大家的共同努力下，该项目于2021年10月按时完成，顺利通过专家组验收，在试运行阶段，收到了广大用户的一致表扬。（500字左右）</p><p>由于本项目的顺利上线涉及到业务的考核，因此，在本项目中，XX管理尤为重要，在本项目中，我作为项目经理特别除了对其余管理领域进行恪职尽守的管理外，特别对XX管理从如下几个方面进行了管理：根据各大管理的过程来写。</p><p><strong>结尾</strong></p><p>经过我们团队不懈的努力，历时1年，本项目终于于2021年10月通过了业主方组织的验收，给用户解决了什么问题，或者是达到了什么目的(根据自己的项目去写)得到了业主的好评。本项目的成功得益于我成功的XX管理。当然，在本项目中，还有一些不足之处，比如在项目的实施过程中，由于项目组2名成员国为自身原因突然离职，导致项目的团队建设出现一些小问题，还有，曾经由于需要购买的服务器由于连日暴雨的不可抗力导致环境搭建进度出现些许异常(自己去想一些小问题，切忌，别出现什么大问题)，不过，经过我后期的纠偏，并没有对项目产生什么影响。在后续的学习和工作中，我将不断的充电学习，和同行进行交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的努力。</p><h2 id="十二、历年论文考点"><a href="#十二、历年论文考点" class="headerlink" title="十二、历年论文考点"></a>十二、历年论文考点</h2><p>2021年下：质量、进度、风险、人力资源、安全、整体、沟通</p><p>2021年上：范围管理 or 合同管理</p><p>2020年下：成本管理 or 采购管理</p><p>2019年下：整体管理 or 沟通管理</p><p>2019年上：风险管理+安全管理 or 人力资源管理+成本管理</p><p>2018年下：沟通管理 or 风险管理</p><p>2018年上：质量管理 or 人力资源管理</p><p>2017年下：安全管理 or 成本管理</p><p>2017年上：范围管理 or 采购管理</p><p>2016年下：绩效管理 or 人力资源管理</p><p>2016年上：范围管理 or 进度管理</p><p>2015年下：成本管理 or 采购管理</p><p>2015年上：风险管理 or 质量管理</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理之机器</title>
      <link href="/2021/03/15/46.ji-suan-ji-zu-cheng-yuan-li-zhi-ji-qi-day-01/"/>
      <url>/2021/03/15/46.ji-suan-ji-zu-cheng-yuan-li-zhi-ji-qi-day-01/</url>
      
        <content type="html"><![CDATA[<h2 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h2><p>计算机组成原理是计算机课程体系中唯一一门讲授<strong>计算机硬件逻辑实现</strong>的课程。</p><p>本课程在课程体系中的地位：</p><p><img src="1.1.png"></p><p>把传感器嵌入和装备到电网、铁路、桥梁、隧道、 公路、建筑、供水系统、大坝、 油气管道等各种物体中，并且被普遍连接，形成所谓“物联网”， 然后将“物联网” 与现有的互联网整合起来，实现人类社会与物理系统的整合，形成智慧地球。</p><p><strong>计算机的软硬件概念：</strong></p><p><img src="1.2.png"></p><p><img src="1.3.png"></p><p><strong>计算机系统的层次结构：</strong></p><p><img src="1.4.png"></p><p><img src="1.5.png"></p><p><strong>计算机体系结构和计算机组成：</strong></p><p><img src="1.6.png"></p><h2 id="二、计算机的发展及应用"><a href="#二、计算机的发展及应用" class="headerlink" title="二、计算机的发展及应用"></a>二、计算机的发展及应用</h2><p><strong>计算机的产生和发展：</strong>世界上第一台电子计算机 ENIAC（1946）</p><p><img src="2.1.png"></p><p><strong>硬件技术对计算机更新换代的影响：</strong></p><p><img src="2.2.png"></p><p><strong>IAS 的逻辑结构：</strong></p><p><img src="2.3.png"></p><p><strong>IBM System／360：</strong></p><p><img src="2.4.png"></p><p><strong>微型计算机的出现和发展：</strong></p><p><img src="2.5.png"></p><p><strong>Intel 公司的典型微处理器产品：</strong></p><p><img src="2.6.png"></p><p>Moore 定律：微芯片上集成的晶体管数目每三年翻两番</p><p><strong>软件技术的兴起和发展：</strong></p><p><strong>各种语言：</strong></p><ul><li>机器语言-面向机器    </li><li>汇编语言-面向机器    </li><li>高级语言-面向问题<ul><li>FORTRAN 科学计算和工程计算 </li><li>PASCAL 结构化程序设计 </li><li>C++ 面向对象</li><li> Java 适应网络环境</li></ul></li></ul><p><strong>系统软件：</strong></p><ul><li>语言处理程序    <ul><li>汇编程序 编译程序 解释程序 </li></ul></li><li>操作系统<ul><li>DOS、UNIX、Windows Linux、Kylin Linux</li></ul></li><li>服务性程序 <ul><li>装配 调试 诊断 排错 </li></ul></li><li>数据库管理系统 <ul><li>数据库和数据库管理软件</li></ul></li><li>网络软件</li></ul><p><strong>软件发展的特点：</strong></p><ol><li>开发周期长 </li><li>制作成本昂贵 </li><li>检测软件产品质量的特殊性 软件是程序以及开发、使用和维护程序所需要的所有文档</li></ol><h2 id="三、系统总线"><a href="#三、系统总线" class="headerlink" title="三、系统总线"></a>三、系统总线</h2><h3 id="3-1-总线的基本概念"><a href="#3-1-总线的基本概念" class="headerlink" title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h3><p><strong>总线是连接各个部件的信息传输线，是各个部件共享的传输介质。</strong></p><p><strong>总线上信息的传送：串行/并行</strong> </p><p><strong>总线结构的计算机举例：</strong></p><ol><li><p>单总线结构框图：</p><p><img src="3.1.1.png"></p></li><li><p>面向 CPU 的双总线结构框图：</p><p><img src="3.1.2.png"></p></li><li><p>以存储器为中心的双总线结构框图：</p><p><img src="3.1.3.png"></p></li></ol><h3 id="3-2-总线的分类"><a href="#3-2-总线的分类" class="headerlink" title="3.2 总线的分类"></a>3.2 总线的分类</h3><ol><li><p><strong>片内总线：</strong>    <strong>芯片内部</strong>的总线</p></li><li><p><strong>系统总线：</strong>    <strong>计算机各部件之间</strong>的信息传输线</p><p>a. 数据总线：<strong>双向</strong> 与机器字长、存储字长有关</p><p>b. 地址总线：<strong>单向</strong> 与存储地址、 I/O地址有关</p><p>c. 控制总线：<strong>有出 有入</strong>（中断请求、总线请求；存储器读、存储器写；总线允许、中断确认）</p></li><li><p><strong>通信总线：</strong>    用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信</p><p><strong>传输方式：</strong>    1. 串行通信总线    2. 并行通信总线</p></li></ol><h3 id="3-3-总线特性及性能指标"><a href="#3-3-总线特性及性能指标" class="headerlink" title="3.3 总线特性及性能指标"></a>3.3 总线特性及性能指标</h3><p><strong>总线物理实现：</strong></p><p><img src="3.3.1.png"></p><p><strong>总线特性：</strong></p><ol><li>机械特性：尺寸、形状、管脚数及排列顺序</li><li>电气特性：传输方向和有效的电平范围</li><li>功能特性：每根传输线的功能：a. 地址 b. 数据 c. 控制</li><li>时间特性：信号的时序关系</li></ol><p><strong>总线的性能指标：</strong></p><ol><li>总线宽度：数据线的根数</li><li>标准传输率：每秒传输的最大字节数（MBps）</li><li>时钟同步/异步：同步、不同步</li><li>总线复用：地址线与数据线复用</li><li>信号线数：地址线、数据线和控制线的总和</li><li>总线控制方式：突发、自动、仲裁、逻辑、计数</li><li>其他指标：负载能力（负载的 IO 设备数量）</li></ol><p><strong>总线标准：</strong></p><p><img src="3.3.2.png"></p><h3 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h3><p><strong>单总线结构：</strong></p><p><img src="3.4.1.png"></p><p><strong>多总线结构：</strong></p><p>​    <strong>a. 双总线结构</strong></p><p>​    <img src="3.4.2.png"></p><p>​    <strong>b. 三总线结构</strong></p><p>​    <img src="3.4.3.png"></p><p>​    <strong>c. 三总线结构的又一形式</strong></p><p>​    <img src="3.4.4.png"></p><p>​    <strong>d. 四总线结构</strong></p><p>​    <img src="3.4.5.png"></p><h3 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h3><h4 id="3-5-1-总线判优控制"><a href="#3-5-1-总线判优控制" class="headerlink" title="3.5.1 总线判优控制"></a>3.5.1 总线判优控制</h4><ul><li>主设备(模块)对总线有控制权</li><li>从设备(模块) 响应从主设备发来的总线命令</li><li>总线判优控制<ul><li>集中式：链式查询、计数器定时查询、独立请求方式</li><li>分布式</li></ul></li></ul><h4 id="3-5-2-总线通信控制"><a href="#3-5-2-总线通信控制" class="headerlink" title="3.5.2 总线通信控制"></a>3.5.2 总线通信控制</h4><p><strong>目的：解决通信双方协调配合问题</strong></p><p><strong>总线传输周期：</strong></p><ul><li>申请分配阶段：主模块申请，总线仲裁决定</li><li>寻址阶段：主模块向从模块给出地址和命令</li><li>传数阶段：主模块和从模块交换数据</li><li>结束阶段：主模块撤消有关信息</li></ul><p><strong>总线通信的四种方式：</strong></p><ul><li><p>同步通信：由统一时标控制数据传送</p></li><li><p>异步通信：采用应答方式，没有公共时钟标准</p></li><li><p>半同步通信：同步、异步结合</p><p>上述三种通信的共同点：一个总线传输周期（以输入数据为例）</p><ul><li>主模块发地址、命令：占用总线</li><li>从模块准备数据：不占用总线 总线空闲</li><li>从模块向主模块发数据：占用总线</li></ul></li><li><p>分离式通信：充分挖掘系统总线每个瞬间的潜力</p><p>一个总线传输周期</p><ul><li>子周期1：主模块申请占用总线，使用完后即放弃总线的使用权</li><li>子周期2：从模块申请占用总线，将各种信息送至总线上</li></ul><p>分离式通信特点：</p><ol><li>各模块有权申请占用总线</li><li>采用同步方式通信，不等对方回答</li><li>各模块准备数据时，不占用总线</li><li>总线被占用时，无空闲（充分提高了总线的有效占用）</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> MOOC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 回顾</title>
      <link href="/2021/03/03/45.html-hui-gu/"/>
      <url>/2021/03/03/45.html-hui-gu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>什么是 HTML？</p><p>HTML 是用来<strong>描述网页</strong>的一种语言。</p><ul><li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)</li><li><strong>HTML 不是一种编程语言，而是一种标记语言</strong> (markup language)</li><li>标记语言是一套标记<strong>标签</strong> (markup tag)，HTML <strong>使用标记标签来描述网页</strong></li></ul><p>网页的版本迭代：HTML4、XHTML2.0、HTML5…</p><p>通过<code>&lt;!doctype html&gt;</code>告诉浏览器当前网页的版本是 HTML5</p><pre><code>&lt;!--文档申明,申明当前网页的版本--&gt;&lt;!doctype html&gt;&lt;!--html的根标签(元素),网页中的所有内容都要写在根元素里面--&gt;&lt;html&gt;    &lt;!--head是网页的头部.head中的内容不会直接出现在网页中,主要帮助浏览器或搜索引擎来解析网页--&gt;    &lt;head&gt;        &lt;!--meta标签用来设置网页的各种元数据--&gt;        &lt;meta charset="utf-8"&gt;        &lt;!--title中的内容会显示在浏览器的标题栏,搜索引擎主要根据title中的内容判断网页的主要内容--&gt;        &lt;title&gt;html结构&lt;/title&gt;    &lt;/head&gt;    &lt;!--body是html的子元素,表示网页的主题,网页中所有的可见内容都应该写在body里--&gt;    &lt;body&gt;        &lt;!--网页的一级标题,不建议使用font元素,html只负责结构,为了将结构 表现 行为分离最好用css来实现--&gt;        &lt;h1&gt;点击此处查询参考手册:---&gt;&lt;a href="https://www.w3school.com.cn/" target="_blank"         style="color: red; text-decoration: none;"&gt;W3School&lt;/a&gt;&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="二、标签（元素）"><a href="#二、标签（元素）" class="headerlink" title="二、标签（元素）"></a>二、标签（元素）</h2><h3 id="2-1-替换标签（元素）"><a href="#2-1-替换标签（元素）" class="headerlink" title="2.1 替换标签（元素）"></a>2.1 替换标签（元素）</h3><p><strong>替换元素</strong>（<strong>replaced element</strong>）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。</p><p>替换元素介于行内元素和块元素之间，具有两种元素的特点。</p><p>简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如iframe元素，可能具有自己的样式表，但它们不会继承父文档的样式。</p><p>CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。</p><p>典型的可替换元素有：</p><ul><li>iframe</li><li>video/audio</li><li>embed</li><li>img</li></ul><p>有些元素仅在特定情况下被作为可替换元素处理，例如：</p><ul><li>option</li><li>audio</li><li>canvas</li><li>object</li><li>applet</li></ul><h3 id="2-2-自闭合标签"><a href="#2-2-自闭合标签" class="headerlink" title="2.2 自闭合标签"></a>2.2 自闭合标签</h3><pre><code>&lt;meta&gt;标签:设置页面元信息&lt;br&gt;：换行&lt;hr&gt;：水平线&lt;img&gt;：图像    src 外部图片路径 (规则和超链接一样)    alt 图片的描述,默认情况不显示,当某些浏览器图片无法加载时显示        -搜索引擎会根据 alt中内容识别图片,不写alt属性则该图片不会被搜索引擎收录    width 指定图片宽度 height 指定图片高度        -宽度和高度如果只修改了一个,则另一个会等比例缩放,不建议全部修改影响图片显示效果.        -一般在pc端,不建议修改图片的大小(放大失真,缩小浪费内存),需要多大图片就裁多大;        -但是在移动端,经常需要对图片进行缩放(大图缩小防止失真)      格式:            jepg (jpg)                -支持的颜色比较丰富不支持透明效果和动图                -一般用来显示照片            gif                -支持的颜色比较少,支持简单透明和动图                -颜色单一的图片和动图            png                -支持颜色丰富和复杂透明,不支持动图                -专门为网页而生            webp                -谷歌新推出的专门用来表示网页中图片的一种格式                -具备其他格式所有优点的同时文件特别小                -缺点:兼容性不好            base64                -将图片使用base64编码转化为字符后引入图片                -需要和网页一起加载出来的图片才会用base64&lt;input&gt;：表单元素&lt;link&gt;：定义文档与外部资源的关系的链接&lt;col&gt;:在表格table中定义一个或多个列的属性&lt;base&gt;：设置网页所有链接的相对目录(如根目录)&lt;param&gt;：元素允许您为插入 XHTML 文档的对象规定 run-time 设置&lt;area&gt;：标签定义图像映射内部的区域（图像映射指的是带有可点击区域的图像）。&lt;embed&gt;：HTML5 中新增的,标签定义了一个容器，用来嵌入外部应用或者互动程序（插件）。&lt;keygen&gt;：该对象提供了一个安全的方式来验证用户。&lt;source&gt;：标签为媒体元素（比如 和 ）定义媒体资源。&lt;object&gt;：或者&lt;applet&gt; 标签提供参数。</code></pre><h3 id="2-3-元标签"><a href="#2-3-元标签" class="headerlink" title="2.3 元标签"></a>2.3 元标签</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta name="keywords" content="html5,meta,title"&gt;    &lt;meta name="description" content="meta标签的使用说明"&gt;    &lt;meta name="author" content="ADAI"&gt;    &lt;meta http-equiv="refresh" content="60; url=https://www.w3school.com.cn/"&gt;    &lt;title&gt;meta标签(元素)的使用&lt;/title&gt; &lt;/head&gt;&lt;body&gt;    &lt;h1 style="text-align: center; color: red;"&gt;meta标签的使用&lt;/h1&gt;    &lt;font size="6" color="blue"&gt;        &lt;em&gt;            &lt;pre&gt;                &amp;lt;!--                     meta写在head标签中,主要用来设置网页元数据,不是给用户看而是给浏览器或搜索引擎                        -charset 设置页面的字符编码(字符集)                        -name 数据的名                        -content 数据的值(内容)                        -keywords 多个关键字用,隔开                        -description 网站的描述,会显示在搜索引擎的搜索结果中                        -http-equiv="refresh" 将页面重新定向到另一个网站                        -meta还可以设置移动端的适口大小(之后再学)                        -title中的内容会作为网页搜索出来结果中的超链接文字标题显示                --&amp;gt;            &lt;/pre&gt;        &lt;/em&gt;         &lt;/font&gt;   &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2-4-常用标签"><a href="#2-4-常用标签" class="headerlink" title="2.4 常用标签"></a>2.4 常用标签</h3><pre><code>注释：&lt;!-- Ctrl+/ --&gt;实体：&amp;nbsp; 空格 &amp;lt; 小于号 &amp;gt; 大于号 &amp;copy; 版权符号--&gt;标题（Heading）&lt;h1&gt; - &lt;h6&gt; h1在网页中的重要性仅次于title标签,一般一个页面只有一个h1标题分组：可以将一相同的标题同时放入到hgroup中    &lt;hgroup&gt;        &lt;h1&gt;赤壁赋&lt;/h1&gt;        &lt;h2&gt;苏轼&lt;/h2&gt;    &lt;/hgroup&gt;段落：&lt;p&gt; 列表：1.无序列表ul (使用最多,如网页导航栏) 2.有序列表ol 3.定义列表dl (dt dd)     列表用li (list item)来包裹内容,所有列表之间可以相互嵌套超链接：&lt;a&gt;：&lt;a href="www.w3cschool.com.cn"&gt;外部网站地址&lt;/a&gt;    target 属性指定超链接打开的位置 可选值: _self 在当前页面中打开超链接 _blank 在新的页面中打开超链接    href 属性            #: 跳转到当前页面的顶部位置            #加上目标元素id属性的值: 跳转到页面的指定位置            在开发中当超链接href值暂时未定时,可以将#或javascript:;作为href的路径占位符使用    id 属性 (唯一,不重复)            -每一个标签都可以添加一个id属性            -id属性是元素的唯一标识,同一个页面中不可能出现重复的id属性,区分大小写            -id的值为了符合规范属性最好是小写英文字母开头    图像：&lt;img&gt;长引用：blockquote短引用：q旁注信息并显示为更小文本：small换行：br(br*6换6行)斜体显示文本：i强调语音语调的加重：em突出显示部分文本：mark定义不正确的文本：s加粗文本字体：b强调重要的内容：strong文本为缩写形式：abbr定义地址、签名或者文档的作者身份：address&lt;frame&gt;：内联框架：向当前页面中引入一个其他页面,不会被搜索引擎检查搜索        src 指定引入网页的路径        frameborder 指定内联框架的边框 (0:无边框;1:有边框)</code></pre><h3 id="2-5-语义化标签"><a href="#2-5-语义化标签" class="headerlink" title="2.5 语义化标签"></a>2.5 语义化标签</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;语义化标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 布局标签 (结构化语义标签) --&gt;    &lt;!--         header:网页的头部;        main:网页的主体部分 (一个页面中只会有一个main);        footer:网页的底部;        nav:网页中的导航;        aside:和主体相关的其他内容 (侧边栏);        article:独立的文章;        section:独立的区块,上边的标签都不能表示时使用section;        以上标签是HTML5新标签,需要新版浏览器支持,使用较少,只做了解     --&gt;     &lt;!--          div:没有语义,就是用来表示一个区块,目前div是我们的主要布局元素;         span:没有语义,行内元素,一般用于在网页中选中文字;         目前布局通常用div和span来实现.      --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2-6-音视频标签"><a href="#2-6-音视频标签" class="headerlink" title="2.6 音视频标签"></a>2.6 音视频标签</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;音视频&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--         audio 标签用来向页面中引入一个外部的音频文件,是一个替换标签            属性:                controls 是否允许用户控制播放                autoplay 打开页面时自动播放 (为了用户体验,目前大部分浏览器不支持该功能)                loop 循环播放     --&gt;    &lt;audio src="../source/audio/01.mp3" controls autoplay loop&gt;&lt;/audio&gt;    &lt;!-- 除了通过src来指定外部文件的路径外,还可以通过source来指定文件的路径         采取自上而下只运行第一个格式支持播放的文件 --&gt;    &amp;nbsp;         &lt;audio controls loop&gt;          &lt;source src="../source/audio/02.ogg"&gt;         &lt;source src="../source/audio/03.flac"&gt;        &lt;embed src="../source/audio/02.mp3" type="audio/mp3" width="120" height="60"&gt;        &lt;!-- 对不起,您的浏览器不支持播放,请升级! --&gt;    &lt;/audio&gt;&lt;br&gt;    &lt;!-- 当使用ie低版本时需要用到embed引入音视频,该标签会自动播放并且需要规定width和height属性    到合适大小,不支持loop属性不支持很多MP3之外的格式且容易出bug,该元素只做了解不常用 --&gt;        &lt;!-- video 标签用来向网页中引入一个视频,使用方式和 audio 基本一样     &lt;video src="../source/video/01.mp4" width="10%"&gt;&lt;/video&gt; (不能像左边那么写,无法播放)--&gt;    &lt;video controls width="22%"&gt;        &lt;source src="../source/video/01.webm"&gt;                    &lt;source src="../source/video/01.mp4"&gt;                    &lt;embed src="../source/video/01.mp4" type="video/mp4"&gt;                            &lt;/video&gt;    &amp;nbsp;    &lt;!-- iframe嵌入外部视频,和本地直接播放不同,需要网速加载 --&gt;    &lt;iframe src="//player.bilibili.com/player.html?aid=86208216&amp;bvid=BV1k7411x7gA&amp;cid=147347434&amp;page=1"     scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"    width="600" height="524"&gt;     &lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器差异及渲染</title>
      <link href="/2021/02/28/44.liu-lan-qi-chai-yi-ji-xuan-ran/"/>
      <url>/2021/02/28/44.liu-lan-qi-chai-yi-ji-xuan-ran/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常见浏览器及其内核"><a href="#一、常见浏览器及其内核" class="headerlink" title="一、常见浏览器及其内核"></a>一、常见浏览器及其内核</h2><p><img src="1.png"></p><p>微软的新一代浏览器Microsoft Edge，宣布打算采用 Chromium 开源项目开发桌面版的 Microsoft Edge 浏览器，详情见<a href="https://blogs.windows.com/windowsexperience/2018/12/06/microsoft-edge-making-the-web-better-through-more-open-source-collaboration/#Q4eKSlPUTUfiWhxF.97">Microsoft Edge: Making the web better through more open source collaboration</a>.</p><p>对此表示喜大普奔，毕竟IE太难用了，开发的时候做兼容也是非常恶心，(╥╯^╰╥)</p><hr><h2 id="二、什么是内核"><a href="#二、什么是内核" class="headerlink" title="二、什么是内核"></a>二、什么是内核</h2><blockquote><p>浏览器最重要或者说核心的部分是<strong>“Rendering Engine”</strong>，可大概译为“解释引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如HTML、JavaScript）并渲染（显示）网页。<br> 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。<br> 不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</p></blockquote><blockquote><p>另一种关于内核的说明：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E">维基百科(↓)</a></p></blockquote><h3 id="2-1-排版引擎"><a href="#2-1-排版引擎" class="headerlink" title="2.1 排版引擎"></a>2.1 排版引擎</h3><p> <strong>排版引擎</strong>（layout engine），也称为<strong>浏览器引擎</strong>（web browser engine）、<strong>页面渲染引擎</strong>（rendering engine）或<strong>样版引擎</strong>，负责获取标记式内容（如<a href="https://zh.wikipedia.org/wiki/HTML">HTML</a>、<a href="https://zh.wikipedia.org/wiki/XML">XML</a>及图像文件等等）、整理信息（如<a href="https://zh.wikipedia.org/wiki/CSS">CSS</a>及<a href="https://zh.wikipedia.org/wiki/XSL">XSL</a>等），并将排版后的内容输出至显示器或打印机。</p><h3 id="2-2-JavaScript-引擎"><a href="#2-2-JavaScript-引擎" class="headerlink" title="2.2 JavaScript 引擎"></a>2.2 JavaScript 引擎</h3><p>  <strong>JavaScript 引擎</strong>是一个专门处理<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>脚本的<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a>，一般会附带在<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器</a>之中。</p><table><thead><tr><th align="center">JS引擎</th><th align="center">应用程序(实现)</th></tr></thead><tbody><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/V8_(JavaScript%E5%BC%95%E6%93%8E)">V8</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Google_Chrome">Google Chrome</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/SpiderMonkey">SpiderMonkey</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Mozilla_Firefox">Mozilla Firefox</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/WebKit#JavaScriptCore">JavaScriptCore</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Safari">Safari</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/Chakra_(JScript%E5%BC%95%E6%93%8E)">Chakra (JScript引擎)</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Internet_Explorer">Internet Explorer</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/Chakra_(JavaScript%E5%BC%95%E6%93%8E)">Chakra (JavaScript引擎)</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Microsoft_Edge">Microsoft Edge</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/KJS">KJS</a></td><td align="center">Konqueror</td></tr></tbody></table><hr><h2 id="三、浏览器渲染原理"><a href="#三、浏览器渲染原理" class="headerlink" title="三、浏览器渲染原理"></a>三、浏览器渲染原理</h2><p>Web页面运行在各种各样的浏览器当中，浏览器载入、渲染页面的速度直接影响着用户体验简单地说，页面渲染就是浏览器将html代码根据CSS定义的规则显示在浏览器窗口中的这个过程。</p><p>先来大致了解一下浏览器都是怎么干活的：</p><ol><li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li><li>浏览器开始载入html代码，发现<code>&lt;head&gt;</code>标签内有一个<code>&lt;link&gt;</code>标签引用外部CSS文件；</li><li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li><li>浏览器继续载入html中<code>&lt;body&gt;</code>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li><li>浏览器在代码中发现一个<code>&lt;img&gt;</code>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li><li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li><li>浏览器发现了一个包含一行Javascript代码的<code>&lt;script&gt;</code>标签，赶快运行它；</li><li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</li><li>终于等到了<code>&lt;/html&gt;</code>的到来，浏览器泪流满面……</li><li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下<code>&lt;link&gt;</code>标签的CSS路径；</li><li>浏览器召集了在座的各位<br> <code>&lt;span&gt;&lt;ul&gt;&lt;li&gt;</code>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li></ol><p>说到页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，这个回退的过程叫<strong>reflow</strong>。</p><p>reflow几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。</p><p>鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。</p><p>通常我们都无法预估浏览器到底会reflow哪一部分的代码，它们都彼此相互影响着。</p><p>reflow问题是可以优化的，我们可以尽量减少不必要的reflow。</p><p>如开头例子中的<code>&lt;img&gt;</code>图片载入问题，这其实就是一个可以避免的reflow——给图片设置宽度和高度。</p><p>这样浏览器就知道了图片的占位面积，在载入图片前就预留好了位置。</p><p><strong>repaint：重绘</strong></p><p>如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器repaint。</p><p>repaint的速度明显快于 reflow（在IE下需要换一下说法，reflow要比repaint 更缓慢）。</p><h2 id="四、CSS性能"><a href="#四、CSS性能" class="headerlink" title="四、CSS性能"></a>四、CSS性能</h2><p><strong>最终决定浏览器表现出来的页面效果的差异是：渲染引擎 Rendering Engine（也叫做排版引擎），也就是我们通常所说的<a href="http://www.smallni.com/?p=106">“浏览器内核”</a>，负责解析网页语法（如HTML、JavaScript）并渲染、展示网页。相同的代码在不同的浏览器呈现出来的效果不一样，那么就很有可能是不同的浏览器内核导致的。</strong></p><p><strong>加载页面时浏览器的工作流程：</strong></p><p><strong>1、解析HTML以重建DOM树（Parsing HTML to construct the DOM tree ）</strong>：<br> 渲染引擎开始解析HTML文档，转换树中的标签到DOM节点，它被称为“内容树”。</p><p><strong>2、构建渲染树（Render tree construction）</strong>：<br> 解析CSS（包括外部CSS文件和样式元素），根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树。</p><p><strong>3、布局渲染树（Layout of the render tree）:</strong><br> &lt;wbr style=”font-family: “Microsoft Yahei”, sans-serif;”&gt;从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。</p><p><strong>4、绘制渲染树（Painting the render tree）</strong><br> &lt;wbr style=”font-family: “Microsoft Yahei”, sans-serif;”&gt;: 遍历渲染树，每个节点将使用UI后端层来绘制。</p><p>主要的流程就是：构建一个dom树，页面要显示的各元素都会创建到这个dom树当中，每当一个新元素加入到这个dom树当中，浏览器便会通过css引擎查遍css样式表，找到符合该元素的样式规则应用到这个元素上。</p><p><strong>注意了：css引擎查找样式表，对每条规则都按从右到左的顺序去匹配。</strong></p><p>对此，在CSS书写过程中，总结出如下性能提升的方案：</p><ol><li>避免使用通配规则：如 *{} 计算次数惊人！只对需要用到的元素进行选择</li><li>尽量少的去对标签进行选择，而是用class，如：#nav li{},可以为li加上nav_item的类名，选择.nav_item{}</li><li>不要去用标签限定ID或者类选择符，如：ul#nav，应该简化为#nav</li><li>尽量少的去使用后代选择器，降低选择器的权重值，后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>考虑继承样式，了解哪些属性是可以通过继承而来的，避免对这些属性重复指定规则。</li></ol><h2 id="五、CSS初始化"><a href="#五、CSS初始化" class="headerlink" title="五、CSS初始化"></a>五、CSS初始化</h2><p><strong>浏览器 CSS 样式初始化：</strong></p><ul><li>若要求不高追求方便可以直接：</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">*</span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>normalize.css</p></li><li><p>reset.css</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 全家桶 day 07</title>
      <link href="/2021/02/26/43.react-quan-jia-tong-day-07/"/>
      <url>/2021/02/26/43.react-quan-jia-tong-day-07/</url>
      
        <content type="html"><![CDATA[<h2 id="一、组件的生命周期"><a href="#一、组件的生命周期" class="headerlink" title="一、组件的生命周期"></a>一、组件的生命周期</h2><p><strong>生命周期回调函数 &lt;=&gt; 生命周期钩子</strong>：在组件特定的生命周期里 React 可以自动帮忙调用生命周期钩子里的函数，来完成特定的功能。</p><p>需求: 自定义组件</p><pre><code>   1. 让指定的文本做显示/隐藏的动画   2. 切换时间为2s   3. 点击按钮从界面中移除组件界面</code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>title<span class="token operator">></span>ComponentLife<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"example"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react-dom.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/babel.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">// 创建组件</span>    <span class="token keyword">class</span> <span class="token class-name">Life</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>                state <span class="token operator">=</span> <span class="token punctuation">{</span>opacity<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>                death <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 卸载组件</span>            ReactDOM<span class="token punctuation">.</span><span class="token function">unmountComponentAtNode</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// componentDidMount：在组件挂载完毕后调用</span>        componentDidMount <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 在此方法中启动定时器/绑定监听/发送ajax请求</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 获取原状态</span>                <span class="token keyword">let</span> <span class="token punctuation">{</span>opacity<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state                opacity <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">0.1</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>opacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> opacity <span class="token operator">=</span> <span class="token number">1</span>                <span class="token comment" spellcheck="true">// 更新状态</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>opacity<span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// componentWillUnmount：组件将要卸载时调用</span>        componentWillUnmount <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 清除定时器/解除监听</span>              <span class="token comment" spellcheck="true">// 清除定时器</span>            <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// render：初始化渲染以及状态更新之后调用</span>        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">(</span>                <span class="token operator">&lt;</span>div<span class="token operator">></span>                    <span class="token operator">&lt;</span>h2 style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>opacity<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>opacity<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">></span>天气热得不得了！<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>                    <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>death<span class="token punctuation">}</span><span class="token operator">></span>是的呀<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>            <span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 渲染组件</span>    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Life content<span class="token operator">=</span><span class="token string">"react学不会, 怎么办?"</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、React-生命周期（旧）"><a href="#二、React-生命周期（旧）" class="headerlink" title="二、React 生命周期（旧）"></a>二、React 生命周期（旧）</h2><p><img src="2.png"></p><ol><li><p>组件的三个生命周期状态:</p><p>Mount：插入真实 DOM</p><p>Update：被重新渲染</p><p>Unmount：被移出真实 DOM</p></li><li><p>React 为每个状态都提供了勾子(hook)函数</p><p>componentWillMount()</p><p>componentDidMount()</p><p>componentWillUpdate()</p><p>componentDidUpdate()</p><p>componentWillUnmount()</p></li><li><p><strong>生命周期流程</strong>:</p><p>a. 初始化阶段：由 ReactDOM.render() 触发</p><p>​    constructor()：创建对象初始化state</p><p>​    componentWillMount()：将要插入回调</p><p>​    render()：用于插入虚拟DOM回调</p><p>​    **componentDidMount()**：组件刚挂载到页面 ====》常用，做初始化操作：开启定时器、发 ajax 请求、消息订阅</p><p>b. 更新阶段：由组件内部 this.setSate() 或父组件重新 render 触发</p><p>​    shouldComponentUpdate()：阀门默认开启</p><p>​    componentWillUpdate()：将要更新回调</p><p>​    **render()**：更新(重新渲染) ====》必须使用</p><p>​    componentDidUpdate()：已经更新回调</p><p>c. 移除组件：由 ReactDOM.unmountComponentAtNode() 触发</p><p>​    **componentWillUnmount()**：组件将要被移除的回调 ====》常用，做收尾操作：清除定时器，取消订阅消息</p></li></ol><h2 id="三、React-生命周期（新）"><a href="#三、React-生命周期（新）" class="headerlink" title="三、React 生命周期（新）"></a>三、React 生命周期（新）</h2><p><img src="3.png"></p><p>和旧的生命周期相比，新的生命周期：</p><p><strong>废弃了三个钩子：WillMount、WillReceiveProps、WillUpdate，使用需要加上UNSAFE_前缀，不常用，开发基本用不上</strong></p><p><strong>提出两个新钩子：getDerivedStateFromProps、getSnapshotBeforeUpdate，极其不常用，开发基本用不上</strong></p><p><strong>其他的都是一样的，常用的三个钩子：render()、componentDidMount()、componentWillUnmount()</strong></p><p>getDerivedStateFromProps：state 的值在任何时候都取决于 props 时，派生状态会导致代码冗余，并使组件难以维护。可以不使用它，用构造器代替。</p><p>getSnapshotBeforeUpdate：在最近一次渲染输出（提交到 DOM 节点）之前被调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 全家桶 day 06</title>
      <link href="/2021/02/24/42.react-quan-jia-tong-day-06/"/>
      <url>/2021/02/24/42.react-quan-jia-tong-day-06/</url>
      
        <content type="html"><![CDATA[<h2 id="一、高阶函数、柯里化"><a href="#一、高阶函数、柯里化" class="headerlink" title="一、高阶函数、柯里化"></a>一、高阶函数、柯里化</h2><p><strong>高阶函数</strong>：如果一个函数符合以下其中一点，就是高阶函数。</p><ol><li>若 A 函数接收的参数是一个函数，则 A 为高阶函数。</li><li>若 A 函数调用后，它的返回值仍是一个函数，则 A 为高阶函数。</li></ol><p>常见高阶函数：</p><ol><li><p>Promise</p><p>new Promise((excutor)=&gt;{})，在 new 一个 Promise 时，需传一个执行器函数 excutor 作为参数。</p></li><li><p>setTimeout(()=&gt;{})，接收参数是函数</p></li><li><p>数组的常见方法：arr.map()，接收参数是函数</p></li></ol><p><strong>函数柯里化</strong>：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。</p><p><strong>函数柯里化案例：</strong></p><p>之前的 saveUsername 和 savePassword 等用来保存用户名、密码的方法代码相似度高，可以定义一个 saveFormData 方法专门用来保存表单数据。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>title<span class="token operator">></span>高阶函数、柯里化<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"example"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react-dom.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/babel.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>  <span class="token keyword">class</span> <span class="token class-name">Login</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 初始化状态</span>    state <span class="token operator">=</span> <span class="token punctuation">{</span>      username<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>      password<span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 保存表单数据到状态中</span>    saveFormData <span class="token operator">=</span> <span class="token punctuation">(</span>dataType<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dataType<span class="token punctuation">,</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 对象中的属性名是字符串，dataType相当于'dataType'，需要加上[]让它成为变量而不是字符串</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">[</span>dataType<span class="token punctuation">]</span><span class="token punctuation">:</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 表单提交的回调</span>    handleSubmit <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的默认行为: 阻止提交表单</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span>username<span class="token punctuation">,</span>password<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`你输入的用户名是：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>username<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，你输入的密码是：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>password<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>        render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">></span>            用户名：<span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveFormData</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"username"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>            密码<span class="token punctuation">:</span><span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveFormData</span><span class="token punctuation">(</span><span class="token string">'password'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"password"</span> name<span class="token operator">=</span><span class="token string">"password"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>            <span class="token operator">&lt;</span>button<span class="token operator">></span>登录<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 渲染组件</span>  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Login<span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、不用柯里化"><a href="#二、不用柯里化" class="headerlink" title="二、不用柯里化"></a>二、不用柯里化</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>title<span class="token operator">></span>高阶函数、柯里化<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"example"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react-dom.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/babel.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>  <span class="token keyword">class</span> <span class="token class-name">Login</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 初始化状态</span>    state <span class="token operator">=</span> <span class="token punctuation">{</span>      username<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>      password<span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 保存表单数据到状态中</span>    saveFormData <span class="token operator">=</span> <span class="token punctuation">(</span>dataType<span class="token punctuation">,</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">[</span>dataType<span class="token punctuation">]</span><span class="token punctuation">:</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 表单提交的回调</span>    handleSubmit <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的默认行为: 阻止提交表单</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span>username<span class="token punctuation">,</span>password<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`你输入的用户名是：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>username<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，你输入的密码是：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>password<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>        render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">></span>            用户名：<span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span>event <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveFormData</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">}</span>             type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"username"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>            密码<span class="token punctuation">:</span><span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span>event <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">saveFormData</span><span class="token punctuation">(</span><span class="token string">'password'</span><span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">}</span>                         type<span class="token operator">=</span><span class="token string">"password"</span> name<span class="token operator">=</span><span class="token string">"password"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>            <span class="token operator">&lt;</span>button<span class="token operator">></span>登录<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 渲染组件</span>  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Login<span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 全家桶 day 05</title>
      <link href="/2021/02/22/41.react-quan-jia-tong-day-05/"/>
      <url>/2021/02/22/41.react-quan-jia-tong-day-05/</url>
      
        <content type="html"><![CDATA[<h2 id="一、React-事件处理"><a href="#一、React-事件处理" class="headerlink" title="一、React 事件处理"></a>一、React 事件处理</h2><ol><li>   通过 onXxx 属性指定组件的事件处理函数(注意大小写)</li></ol><p>​    a.    React 使用的是自定义(合成)事件，而不是使用的原生DOM事件，兼容性更好</p><p>​    b.    React 中的事件是通过事件委托方式处理的(委托给组件最外层的元素)，更加高效</p><ol start="2"><li>   通过 event.target 得到发生事件的 DOM 元素对象(发生事件的元素正好是需要操作的元素)，不要过度使用 ref</li></ol><pre><code>&lt;input onFocus={this.handleClick}/&gt;handleFocus(event) {    event.target  // 返回input对象}</code></pre><h2 id="二、收集表单数据"><a href="#二、收集表单数据" class="headerlink" title="二、收集表单数据"></a>二、收集表单数据</h2><ol><li><p>问题: 在react应用中, 如何收集表单输入数据</p></li><li><p>包含表单的组件分类：</p></li></ol><pre><code>需求：自定义包含表单的组件输入用户名密码后，点击登陆提示输入信息，不提交表单</code></pre><ul><li>受控组件：随着输入来维护状态，优势在于可以不用 ref</li><li>非受控组件：现用现取</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>title<span class="token operator">></span>受控组件<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"example"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react-dom.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/babel.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>  <span class="token keyword">class</span> <span class="token class-name">Login</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 初始化状态</span>    state <span class="token operator">=</span> <span class="token punctuation">{</span>      username<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>      password<span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 保存用户名到状态中</span>    saveUsername <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>username<span class="token punctuation">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 保存密码到状态中</span>    savePassword <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>password<span class="token punctuation">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 表单提交的回调</span>    handleSubmit <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 阻止事件的默认行为: 阻止提交表单</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span>username<span class="token punctuation">,</span>password<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`你输入的用户名是：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>username<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，你输入的密码是：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>password<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>        render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">></span>            用户名：<span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>saveUsername<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"username"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>            密码<span class="token punctuation">:</span><span class="token operator">&lt;</span>input onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>savePassword<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"password"</span> name<span class="token operator">=</span><span class="token string">"password"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>            <span class="token operator">&lt;</span>button<span class="token operator">></span>登录<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 渲染组件</span>  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Login<span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>title<span class="token operator">></span>非受控组件<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"example"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react-dom.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/babel.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>  <span class="token keyword">class</span> <span class="token class-name">LoginForm</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>        username<span class="token punctuation">:</span> <span class="token string">''</span>      <span class="token punctuation">}</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>handleChange <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">handleChange</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>username<span class="token punctuation">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">handleSubmit</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`准备提交的用户名为: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>username<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, 密码:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>pwdInput<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 阻止事件的默认行为: 提交表单</span>      event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span> action<span class="token operator">=</span><span class="token string">"/test"</span><span class="token operator">></span>          <span class="token operator">&lt;</span>label<span class="token operator">></span>            用户名<span class="token punctuation">:</span>            <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>username<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>          <span class="token operator">&lt;</span>label<span class="token operator">></span>            密码<span class="token punctuation">:</span>            <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"password"</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>pwdInput <span class="token operator">=</span> input<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>          <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"submit"</span> value<span class="token operator">=</span><span class="token string">"登陆"</span> <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">></span>      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>LoginForm <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 全家桶 day 04</title>
      <link href="/2021/02/20/40.react-quan-jia-tong-day-04/"/>
      <url>/2021/02/20/40.react-quan-jia-tong-day-04/</url>
      
        <content type="html"><![CDATA[<h2 id="一、回调形式的-ref"><a href="#一、回调形式的-ref" class="headerlink" title="一、回调形式的 ref"></a>一、回调形式的 ref</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">></span>  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"example"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react-dom.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/babel.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">/*    需求: 自定义组件, 功能说明如下:      1. 界面如果页面所示      2. 点击按钮, 提示第一个输入框中的值      3. 当第2个输入框失去焦点时, 提示这个输入框中的值   */</span>    <span class="token comment" spellcheck="true">//定义组件</span>    <span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 调用父类(Component)的构造函数</span>        <span class="token comment" spellcheck="true">//console.log(this)</span>        <span class="token comment" spellcheck="true">// 将自定义的函数强制绑定为组件对象</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 将返回函数中的this强制绑定为指定的对象, 并没有改变原来的函数中的this</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 自定义的方法中的this默认为null</span>      handleClick <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// alert(this) //this默认是null, 而不是组件对象</span>        <span class="token comment" spellcheck="true">// 得到绑定在当前组件对象上的input的值</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>msgInput<span class="token punctuation">.</span>value<span class="token punctuation">)</span>      <span class="token punctuation">}</span>      handleBlur <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>      <span class="token punctuation">}</span>      render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>          <span class="token operator">&lt;</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> ref<span class="token operator">=</span><span class="token punctuation">{</span>input <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>msgInput <span class="token operator">=</span> input<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token string">' '</span><span class="token punctuation">}</span>            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">></span>提示输入数据<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token punctuation">{</span><span class="token string">' '</span><span class="token punctuation">}</span>            <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> placeholder<span class="token operator">=</span><span class="token string">"失去焦点提示数据"</span> onBlur<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleBlur<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 渲染组件标签</span>    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyComponent <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、creatRef"><a href="#二、creatRef" class="headerlink" title="二、creatRef"></a>二、creatRef</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">></span>  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"example"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/react-dom.development.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"../js/babel.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>  <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">/*    需求: 自定义组件, 功能说明如下:      1. 界面如果页面所示      2. 点击按钮, 提示第一个输入框中的值      3. 当第2个输入框失去焦点时, 提示这个输入框中的值   */</span>    <span class="token comment" spellcheck="true">//定义组件</span>    <span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// React.creatRef 调用后会返回一个容器，用来储存被ref标识的节点，几个ref节点就需要创建几个容器</span>        myRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">creatRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        myRef2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">creatRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 展示左侧输入数据</span>        handleClick <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>msgInput<span class="token punctuation">.</span>value<span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 展示右侧输入数据</span>          handleBlur <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token function">alert</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>          <span class="token punctuation">}</span>        render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>                <span class="token operator">&lt;</span>div<span class="token operator">></span>                    <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>myRef<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>                    <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">></span>提示输入数据<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>                    <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>myRef2<span class="token punctuation">}</span> onBlur<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleBlur<span class="token punctuation">}</span> type<span class="token operator">=</span><span class="token string">"text"</span> placeholder<span class="token operator">=</span><span class="token string">"失去焦点提示数                      据"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>                <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 渲染组件标签</span>    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyComponent <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这种方式最被官方推荐。</p></blockquote><h2 id="三、字符串形式的-ref"><a href="#三、字符串形式的-ref" class="headerlink" title="三、字符串形式的 ref"></a>三、字符串形式的 ref</h2><blockquote><p>这种方式官方不推荐使用，编码简单但存在性能问题，以后可能会被弃用。</p></blockquote><p>给标签指定 ref 标识后可以通过 this.refs 找到对应的标签：</p><p><img src="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 全家桶 day 03</title>
      <link href="/2021/02/18/39.react-quan-jia-tong-day-03/"/>
      <url>/2021/02/18/39.react-quan-jia-tong-day-03/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Props-基本使用"><a href="#一、Props-基本使用" class="headerlink" title="一、Props 基本使用"></a>一、Props 基本使用</h2><pre><code>&lt;script type=”text/babel”&gt;    // 创建组件    class Person extends React.Component{        render(){            console.log(this);            const {name,age,sex} = this.props             return (                &lt;ul&gt;                    &lt;li&gt;姓名：{name}&lt;/li&gt;                    &lt;li&gt;性别：{sex}&lt;/li&gt;                    &lt;li&gt;年龄：{age}&lt;/li&gt;                &lt;/ul&gt;            )        }    }        // 渲染组件到页面    ReactDOM.render(&lt;Person name="jerry" age="19" sex=”女”/&gt;,document.getElementById('test1'))    ReactDOM.render(&lt;Person name="tom" age="18" sex= "男"/&gt;,document.getElementById('test2'))    ReactDOM.render(&lt;Person name="bob" age="30" sex="男"/&gt;,document.getElementById('test3'))&lt;/script&gt;</code></pre><h2 id="二、批量传递-Props"><a href="#二、批量传递-Props" class="headerlink" title="二、批量传递 Props"></a>二、批量传递 Props</h2><pre><code>&lt;script type=”text/babel”&gt;    // 创建组件    class Person extends React.Component{        render(){            console.log(this);            const {name,age,sex} = this.props             return (                &lt;ul&gt;                    &lt;li&gt;姓名：{name}&lt;/li&gt;                    &lt;li&gt;性别：{sex}&lt;/li&gt;                    &lt;li&gt;年龄：{age}&lt;/li&gt;                &lt;/ul&gt;            )        }    }        // 渲染组件到页面    ReactDOM.render(&lt;Person name="jerry" age="19" sex="女"/&gt;,document.getElementById('test1'))    ReactDOM.render(&lt;Person name="tom" age="18" sex= "男"/&gt;,document.getElementById('test2'))        const p = {name: 'bob', age: '30', sex: '男'}    // ReactDOM.render(&lt;Person name={p.name} age={p.age} sex={p.sex}/&gt;,document.getElementById('test3'))    ReactDOM.render(&lt;Person {...p}/&gt;,document.getElementById('test3'))&lt;/script&gt;</code></pre><blockquote><p>Babel + React 可以让展开运算符展开对象，但仅限于标签属性的传递。</p></blockquote><h2 id="三、展开运算符"><a href="#三、展开运算符" class="headerlink" title="三、展开运算符"></a>三、展开运算符</h2><p><img src="3.1.png"></p><h2 id="四、propTypes-类型限制"><a href="#四、propTypes-类型限制" class="headerlink" title="四、propTypes 类型限制"></a>四、propTypes 类型限制</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;title&gt;Props 类型限制&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="example1"&gt;&lt;/div&gt;&lt;hr&gt;&lt;div id="example2"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/prop-types.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt;  /*需求: 自定义用来显示一个人员信息的组件,说明：  1). 如果性别没有指定, 默认为男  2). 如果年龄没有指定, 默认为18  3). 显示年龄比实际大一岁  */  //1. 定义组件类  class Person extends React.Component {    render() {      console.log(this)      const {name,age,sex} = this.props      // this.porps.name = jack 报错，因为props是只读的      return (        &lt;ul&gt;          &lt;li&gt;姓名: {name}&lt;/li&gt;          &lt;li&gt;性别: {sex}&lt;/li&gt;          &lt;li&gt;年龄: {age+1}&lt;/li&gt;        &lt;/ul&gt;      )    }  }  // 对标签属性进行类型、必要性限制  Person.propTypes = {    name: PropTypes.string.isRequired, // 限制name必须传值，且为字符串类型    sex: PropTypes.string, // 限制性别为字符串    age: PropTypes.number, // 限制年龄为数值    speak: PropTypes.func, // 限制speak为函数，注意函数是用func  }  // 指定属性的默认值  Person.defaultProps = {    sex: '男', // 性别默认值为男    age: 18  }  //2. 渲染组件标签  const person = {    name: 'Tom',    sex: '女',    age: 18  }    //3. 渲染组件到页面  ReactDOM.render(&lt;Person {...person} speak={speak}/&gt;, document.getElementById('example1'))  const person2 = {    myName: 'JACK',    age: 17  }  ReactDOM.render(&lt;Person name={person2.myName} age={person2.age}/&gt;,    document.getElementById('example2'))    function speak() {      console.log('我说话了')  }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="五、Props-的简写方式"><a href="#五、Props-的简写方式" class="headerlink" title="五、Props 的简写方式"></a>五、Props 的简写方式</h2><blockquote><p>使用类的关键字 static 给类自身添加属性</p></blockquote><pre class="line-numbers language-js"><code class="language-js"> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 对标签属性进行类型、必要性限制</span>      <span class="token keyword">static</span> propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>      name<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>string<span class="token punctuation">.</span>isRequired<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 限制name必须传值，且为字符串类型</span>      sex<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>string<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 限制性别为字符串</span>      age<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>number<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 限制年龄为数值</span>      speak<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>func<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 限制speak为函数，注意函数是用func</span>     <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 指定属性的默认值</span>    <span class="token keyword">static</span> defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>      sex<span class="token punctuation">:</span> <span class="token string">'男'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 性别默认值为男</span>      age<span class="token punctuation">:</span> <span class="token number">18</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token keyword">const</span> <span class="token punctuation">{</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>sex<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props      <span class="token comment" spellcheck="true">// this.porps.name = jack 报错，因为props是只读的</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>ul<span class="token operator">></span>          <span class="token operator">&lt;</span>li<span class="token operator">></span>姓名<span class="token punctuation">:</span> <span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>          <span class="token operator">&lt;</span>li<span class="token operator">></span>性别<span class="token punctuation">:</span> <span class="token punctuation">{</span>sex<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>          <span class="token operator">&lt;</span>li<span class="token operator">></span>年龄<span class="token punctuation">:</span> <span class="token punctuation">{</span>age<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>      <span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//2. 渲染组件标签</span>  <span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span>    sex<span class="token punctuation">:</span> <span class="token string">'女'</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">18</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//3. 渲染组件到页面</span>  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Person <span class="token punctuation">{</span><span class="token operator">...</span>person<span class="token punctuation">}</span> speak<span class="token operator">=</span><span class="token punctuation">{</span>speak<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token punctuation">{</span>    myName<span class="token punctuation">:</span> <span class="token string">'JACK'</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">17</span>  <span class="token punctuation">}</span>  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Person name<span class="token operator">=</span><span class="token punctuation">{</span>person2<span class="token punctuation">.</span>myName<span class="token punctuation">}</span> age<span class="token operator">=</span><span class="token punctuation">{</span>person2<span class="token punctuation">.</span>age<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">function</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我说话了'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果需要在构造器中通过 this 访问到 props，构造器需要接收 props 并传递给 super（一般不需要），否则打印 this.props 显示undefined：</p></blockquote><pre><code>constructor(props){    super(props)    console.log('constructor',this.props) // 查看所有属性}</code></pre><blockquote><p>类中的构造器一般不需要写。</p></blockquote><h2 id="六、函数组件使用-Props"><a href="#六、函数组件使用-Props" class="headerlink" title="六、函数组件使用 Props"></a>六、函数组件使用 Props</h2><blockquote><p>由于函数可以接收参数，所以才可以接收 Props，但函数无法使用 state 和 refs，除非使用新版 React 的 hooks。</p></blockquote><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 创建组件</span>  <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> <span class="token punctuation">{</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>sex<span class="token punctuation">}</span> <span class="token operator">=</span> props      <span class="token keyword">return</span> <span class="token punctuation">(</span>        <span class="token operator">&lt;</span>ul<span class="token operator">></span>          <span class="token operator">&lt;</span>li<span class="token operator">></span>姓名<span class="token punctuation">:</span> <span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>          <span class="token operator">&lt;</span>li<span class="token operator">></span>性别<span class="token punctuation">:</span> <span class="token punctuation">{</span>sex<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>          <span class="token operator">&lt;</span>li<span class="token operator">></span>年龄<span class="token punctuation">:</span> <span class="token punctuation">{</span>age<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>      <span class="token punctuation">)</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 对标签属性进行类型、必要性限制</span>  Person<span class="token punctuation">.</span>propTypes <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>string<span class="token punctuation">.</span>isRequired<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 限制name必须传值，且为字符串类型</span>    sex<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>string<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 限制性别为字符串</span>    age<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>number<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 限制年龄为数值</span>    speak<span class="token punctuation">:</span> PropTypes<span class="token punctuation">.</span>func<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 限制speak为函数，注意函数是用func</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 指定属性的默认值</span>  Person<span class="token punctuation">.</span>defaultProps <span class="token operator">=</span> <span class="token punctuation">{</span>    sex<span class="token punctuation">:</span> <span class="token string">'男'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 性别默认值为男</span>    age<span class="token punctuation">:</span> <span class="token number">18</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 渲染组件到页面</span>  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Person name<span class="token operator">=</span><span class="token string">"jerry"</span> sex<span class="token operator">=</span><span class="token string">"女"</span> age<span class="token operator">=</span><span class="token string">"18"</span><span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><ol><li><p>   每个组件对象都会有props(properties的简写)属性</p></li><li><p>   组件标签的所有属性都保存在props中</p></li><li><p>   通过标签属性从组件外向组件内传递变化的数据</p></li><li><p>   注意: 组件内部不能修改props数据（只读）</p></li><li><p>   内部读取某个属性值：<em>this.props.propertyName</em></p></li><li><p>   对props中的属性值进行类型限制和必要性限制：</p></li></ol><pre><code>Person.propTypes = {    name: React.PropTypes.string.isRequired,    age: React.PropTypes.number.isRequired}</code></pre><ol start="7"><li>   默认属性值</li></ol><pre><code>Person.defaultProps = {    name: 'Mary'}</code></pre><ol start="8"><li><p>   扩展属性: 将对象的所有属性通过props传递：*&lt;Person {…person}/&gt;*</p></li><li><p>   组件类的构造函数</p></li></ol><pre><code>constructor (props) {    super(props)    console.log(props) // 查看所有属性}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 全家桶 day 02</title>
      <link href="/2021/02/16/38.react-quan-jia-tong-day-02/"/>
      <url>/2021/02/16/38.react-quan-jia-tong-day-02/</url>
      
        <content type="html"><![CDATA[<h2 id="一、组件实例的三大属性"><a href="#一、组件实例的三大属性" class="headerlink" title="一、组件实例的三大属性"></a>一、组件实例的三大属性</h2><p>由于函数式组件没有自己的 this，也没有实例，更别说实例上的属性了。但是最新的 React 有了 hooks 可以让函数式组件使用三大属性。</p><blockquote><p>React 发现组件是类定义的，随后new出该类的实例，并通过该实例调用原型上的render方法。</p><p>React 初始化了三大属性具体值由我们后续添加进去，三大属性不是由组件类生成，而是由类创造的实例对象生成。</p></blockquote><h2 id="二、State"><a href="#二、State" class="headerlink" title="二、State"></a>二、State</h2><h3 id="2-1-原生的事件绑定"><a href="#2-1-原生的事件绑定" class="headerlink" title="2.1 原生的事件绑定"></a>2.1 原生的事件绑定</h3><p><img src="2.1.png"></p><h3 id="2-2-React-事件绑定"><a href="#2-2-React-事件绑定" class="headerlink" title="2.2 React 事件绑定"></a>2.2 React 事件绑定</h3><ul><li><strong>原生：onclick=”demo()”</strong></li><li><strong>React：onClick={demo}</strong></li><li><strong>on 后面首字母大写；函数不要双引号放在花括号中；函数不加小括号调用</strong></li></ul><h3 id="2-3-类的方法的-this"><a href="#2-3-类的方法的-this" class="headerlink" title="2.3 类的方法的 this"></a>2.3 类的方法的 this</h3><p><img src="2.3.1.png"></p><p><img src="2.3.2.png"></p><ul><li><p>实例对象 p1 虽然没有 study 方法但可以沿着原型链去找，study 中的 this 是 p1 实例。</p></li><li><p>第23行代码并没有调用 study 方法，而是在堆内存多开辟一个引用 x 指向栈内存的 study 方法，24 行属于函数直接调用方法，理论上 this 是指向 Window，但却是 undefined。</p></li><li><p>原因：类中所定义的方法会自动在局部开启严格模式，从而 this 为 undefined。</p></li></ul><h3 id="2-4-案例"><a href="#2-4-案例" class="headerlink" title="2.4 案例"></a>2.4 案例</h3><p>案例：动态展示天气状态</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">// 1. 创建组件</span>    <span class="token keyword">class</span> <span class="token class-name">Weather</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建了几个Weather，构造器就调用几次</span>        <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 初始化状态</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>isHot<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> wind<span class="token punctuation">:</span> <span class="token string">'微风'</span><span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 解决changeWeather的this指向问题</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>changeWeather <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>changeWeather<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// render()调用了1+n次，1是初始化那次，n是状态更新的次数</span>        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> <span class="token punctuation">{</span>isHot<span class="token punctuation">,</span> wind<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state            <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1 onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeWeather<span class="token punctuation">}</span><span class="token operator">></span>今天天气很<span class="token punctuation">{</span>isHot <span class="token operator">?</span> <span class="token string">'炎热'</span> <span class="token punctuation">:</span> <span class="token string">'凉爽'</span><span class="token punctuation">}</span>，<span class="token punctuation">{</span>wind<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>            <span class="token comment" spellcheck="true">// changeWeather放在Weather的原型上，供实例使用</span>            <span class="token comment" spellcheck="true">// 由于changeWeather是作为onClick回调，所以不是通过实例调用的，是直接调用。</span>            <span class="token comment" spellcheck="true">// 类中的方法开启了局部的严格模式，所以changeWeather中的this为undefined</span>            <span class="token function">changeWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">const</span> isHot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>isHot                <span class="token comment" spellcheck="true">// 注意：状态不可直接更改，要借助内置的API:setState，合更新操作属于合并而非替换</span>                <span class="token comment" spellcheck="true">// this.state.isHot = !isHot</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>isHot<span class="token punctuation">:</span> <span class="token operator">!</span>isHot<span class="token punctuation">}</span><span class="token punctuation">)</span>                            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2. 渲染组件到页面</span>    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Weater<span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong></p><ul><li>构造器作用：初始化状态，可以通过 bind() 解决 this 的指向问题</li><li>render 中的 this 就是组件实例对象，读取状态进行展示</li><li>自定义方法中使用 setState 进行状态数据的更新</li></ul><h3 id="2-5-State-的简写方式"><a href="#2-5-State-的简写方式" class="headerlink" title="2.5 State 的简写方式"></a>2.5 State 的简写方式</h3><p>利用类的赋值语句规则来简写，Weather的原型上已经没有changeWeather方法，放到了实例自身上。</p><blockquote><p>和函数体不同，类中不能随意写代码（let a;a=1），类里面可以直接写赋值语句(a=1)，类中可以写构造器、方法、赋值语句。</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/babel"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">// 创建组件</span>    <span class="token keyword">class</span> <span class="token class-name">Weather</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化状态</span>        state <span class="token operator">=</span> <span class="token punctuation">{</span>isHot<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> wind<span class="token punctuation">:</span> <span class="token string">'微风'</span><span class="token punctuation">}</span>        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> <span class="token punctuation">{</span>isHot<span class="token punctuation">,</span> wind<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state            <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1 onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeWeather<span class="token punctuation">}</span><span class="token operator">></span>今天天气很<span class="token punctuation">{</span>isHot <span class="token operator">?</span> <span class="token string">'炎热'</span> <span class="token punctuation">:</span> <span class="token string">'凉爽'</span><span class="token punctuation">}</span>，<span class="token punctuation">{</span>wind<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>            <span class="token comment" spellcheck="true">// 自定义方法，要写成赋值语句+箭头函数的形式，箭头函数会去找外层函数的this，即组件实例对象</span>            changeWeather <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">const</span> isHot <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>isHot                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>isHot<span class="token punctuation">:</span> <span class="token operator">!</span>isHot<span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 渲染组件到页面</span>    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Weater<span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在使用类创建组件时，所有自定义的方法都要写成赋值语句 + 箭头函数的形式。</p></blockquote><h2 id="三、State-总结"><a href="#三、State-总结" class="headerlink" title="三、State 总结"></a>三、State 总结</h2><ul><li><p>state 是组件对象最重要的属性, 值是对象(可以包含多个数据)</p></li><li><p>组件被称为”状态机”, 通过更新组件的 state 来更新对应的页面显示(重新渲染组件)</p></li><li><p>组件中 render 方法的 this 为组件实例对象</p></li><li><p>自定义方法中 this 为 undefined 解决：</p><ul><li>强制绑定 this：bind()</li><li>箭头函数</li></ul></li><li><p>状态数据不能直接修改，需要使用 setState</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 全家桶 day 01</title>
      <link href="/2021/02/14/37.react-quan-jia-tong-day-01/"/>
      <url>/2021/02/14/37.react-quan-jia-tong-day-01/</url>
      
        <content type="html"><![CDATA[<h2 id="一、React-简介"><a href="#一、React-简介" class="headerlink" title="一、React 简介"></a>一、React 简介</h2><ol><li><p><strong>概念：</strong></p><p>用于构建用户<strong>界面</strong>的 JavaScript 库。即 React 只关注<strong>视图层</strong>。</p><p>比如有个需求：在页面上展示一些信息，之前的话是分三步走：</p><ol><li>发送请求获取后台接口数据</li><li>处理数据（对数组的遍历、过滤等格式整理）</li><li>使用 JS、jQuery <strong>操作 DOM</strong>，将数据放到相应节点<strong>呈现页面</strong></li></ol></li></ol><p>React 只处理上述的第三步，也就是只负责将数据渲染成 HTML 视图。</p><ol start="2"><li><p><strong>原生的劣势：</strong></p><ol><li><p>原生 JS 频繁操作 DOM，效率低（DOM-API 操作 UI），每一次操作 DOM，会引起浏览器重绘、重排</p><pre><code>document.getElementById('app')document.querySelector('#app')document.getElementsByTagName('span')</code></pre></li><li><p>jQuery 只是在编码上简化了 JS，还是会引起重绘、重排</p></li><li><p>原生 JS 没有<strong>组件化</strong>的编码方案，代码复用率低</p><p>a. 模块化：将一个大的 JS 按功能拆分成多个小的 JS，每个小的 JS 文件可以写一些独立的业务逻辑，方便复用</p><p>b. 组件化：构成页面的每一个独立的功能区域（除了 JS，还包括 HTML、CSS、音视频、字体等）</p></li></ol></li><li><p><strong>React 优势：</strong></p><ol><li><p><strong>组件化</strong>模式，<strong>申明式</strong>（相比于没封装的命令式）编码，提高开发效率和组件复用率。但对应的得学习它的语法规则</p></li><li><p>在 React Native 中可以使用 React <strong>进行移动端开发</strong>，即可以用 JS 编写 Android 应用（Java）或 iOS 应用（OC/Swift）</p></li><li><p>使用<strong>虚拟 DOM + 优秀的 Diffing 算法</strong>，尽量减少与真实 DOM 的交互</p><p>虚拟 DOM：不放在页面中，而是代码运行时，放在电脑的内存里头</p><p><img src="1.1.png"></p><p>数组中每多添加一个 li 标签，DOM 就要重新渲染一次。之前如果有一百个人的 DOM，当新加一个人，就得重新渲染101个 DOM。</p><p>React 会对虚拟 DOM 进行比较，如果没发生变化就不再对应生成新的真实 DOM。</p><p><img src="1.2.png"></p></li></ol></li></ol><h2 id="二、使用案例"><a href="#二、使用案例" class="headerlink" title="二、使用案例"></a>二、使用案例</h2><p>这里不像工程化项目使用脚手架搭建，只是一个案例示范。</p><p><strong>准备好三个文件按顺序引入：</strong></p><p><strong>babel.min.js</strong>：ES6 =&gt; ES5、模块化时浏览器不能解析 import、JSX =&gt; JS</p><p><strong>react.development.js</strong>：React 的核心库</p><p><strong>react-dom.development.js</strong>：操作 DOM 的 React 扩展库</p><blockquote><p>注意：</p><ol><li>需要准备一个容器</li><li>核心库必须在扩展库之前引入</li><li>script 标签是 text/babel</li><li>标签不加引号’’</li></ol></blockquote><p><img src="2.png"></p><h2 id="三、虚拟-DOM-的两种创建方式"><a href="#三、虚拟-DOM-的两种创建方式" class="headerlink" title="三、虚拟 DOM 的两种创建方式"></a>三、虚拟 DOM 的两种创建方式</h2><p><strong>JSX 可以更简单的创建虚拟 DOM</strong>，相当于原生创建虚拟 DOM 写法的一个语法糖。</p><p><img src="3.1.png"></p><p>相当于原生 JS 这样写（不会采用）：</p><p><img src="3.2.png"></p><h2 id="四、虚拟-DOM-和真实-DOM"><a href="#四、虚拟-DOM-和真实-DOM" class="headerlink" title="四、虚拟 DOM 和真实 DOM"></a>四、虚拟 DOM 和真实 DOM</h2><pre><code>console.log('虚拟DOM:',VDOM) // 打印显示：Object（非数组对象和函数对象的一般对象）console.log(typeof VDOM) // 查看数据类型：Objectconsole.log(VDOM instanceof Object) // true</code></pre><p><img src="4.png"></p><h2 id="五、JSX-语法规则"><a href="#五、JSX-语法规则" class="headerlink" title="五、JSX 语法规则"></a>五、JSX 语法规则</h2><p><img src="5.1.png"></p><p><img src="5.2.png"></p><p>React 可以自动遍历显示数组中所有的元素，但是对象则不行</p><pre><code>&lt;script type="text/babel"&gt;    /*     功能: 动态展示列表数据     */    /*     技术点:     1). 使用JSX创建虚拟DOM     2). React能自动遍历显示数组中所有的元素     3). array.map()的使用     */    // 数据的数组    var names = ['jquery', 'zeptoo', 'angular', 'react全家桶', 'vue全家桶']    // 数据的数组--&gt;标签的数组    var lis = []    names.forEach((name, index) =&gt; lis.push(&lt;li key={index}&gt;{name}&lt;/li&gt;))        // 创建虚拟DOM    const ul = &lt;ul&gt;{lis}&lt;/ul&gt;        // 渲染虚拟DOM    ReactDOM.render(ul, document.getElementById('example1'))    const ul2 = &lt;ul&gt;{      names.map((name, index) =&gt; &lt;li key={index}&gt;{name}&lt;/li&gt;)    }&lt;/ul&gt;    ReactDOM.render(ul2, document.getElementById('example2'))  &lt;/script&gt;</code></pre><h2 id="六、react-developer-tools"><a href="#六、react-developer-tools" class="headerlink" title="六、react-developer-tools"></a>六、react-developer-tools</h2><p>安装谷歌插件，包含 Components（查看组件状态）和 Profiler（记录网站性能） 功能。</p><h2 id="七、class-类的复习"><a href="#七、class-类的复习" class="headerlink" title="七、class 类的复习"></a>七、class 类的复习</h2><h3 id="7-1-创建类和它的实例对象："><a href="#7-1-创建类和它的实例对象：" class="headerlink" title="7.1 创建类和它的实例对象："></a>7.1 创建类和它的实例对象：</h3><p><img src="7.1.png"></p><h3 id="7-2-类的继承和重写："><a href="#7-2-类的继承和重写：" class="headerlink" title="7.2 类的继承和重写："></a>7.2 类的继承和重写：</h3><p><img src="7.2.png"></p><blockquote><p>继承让子类也可以使用父类原型上的方法，即使自身没有也可以沿着原型链往上找。</p></blockquote><p><img src="7.3.png"></p><h2 id="八、函数组件和类组件"><a href="#八、函数组件和类组件" class="headerlink" title="八、函数组件和类组件"></a>八、函数组件和类组件</h2><blockquote><p>注意：</p><ol><li>函数式组件申明时首字母必须大写，函数必须有返回值。</li><li>ReactDOM.render() 中必须有组件标签。</li><li>类式组件必须继承父类 extends React.Component。</li><li>类式组件必须有 render 和它的返回值。</li></ol></blockquote><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;title&gt;03_component_basic&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id="example1"&gt;&lt;/div&gt;  &lt;div id="example2"&gt;&lt;/div&gt;  &lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt;  &lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt;  &lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;  &lt;script type="text/babel"&gt;    // 1. 定义组件    /*方式1: 工厂函数组件(简单组件)*/    function MyComponent () {      return &lt;h2&gt;工厂函数组件(简单组件)&lt;/h2&gt;    }    /*方式2: ES6类组件(复杂组件)*/    class MyComponent2 extends React.Component {      render () {          // render放在类MyComponent2的原型对象上供实例使用，它的this是MyComponent2实例对象&lt;=&gt;MyComponent2组件实例对象。        console.log(this) // MyComponent2的实例对象        return &lt;h2&gt;ES6类组件(复杂组件)&lt;/h2&gt;      }    }    // 2. 渲染组件标签到页面    ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById('example1'))    ReactDOM.render(&lt;MyComponent2 /&gt;, document.getElementById('example2'))    /*         执行了ReactDOM.render(&lt;MyComponent /&gt; ... )后，发生了什么？            1. React解析组件标签，找到MyComponent组件。            2. 若发现组件是函数定义的，随后调用该函数，将返回的虚拟DOM转化为真实DOM呈现到页面中。            3. 若发现组件是类定义的，随后new出该类的实例，并通过该实例调用原型上的render方法    */  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除元素</title>
      <link href="/2021/02/12/36.yi-chu-yuan-su/"/>
      <url>/2021/02/12/36.yi-chu-yuan-su/</url>
      
        <content type="html"><![CDATA[<p><strong>移除元素：</strong>给你一个数组 nums 和一个值 val，你需要 <strong>原地</strong> 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 <strong>原地 修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明：</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。可以想象内部操作如下：</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><ul><li><p>示例 1：</p><p>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应返回新的长度 2, 且 nums 中前两个元素均为 2。不需考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p></li><li><p>示例 2：</p><p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。不需考虑数组中超出新长度后面的元素。</p></li></ul><p><strong>提示：</strong></p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 50</li><li>0 &lt;= val &lt;= 100</li></ul><p><strong>题解：</strong></p><pre><code>var removeElement = function(nums, val) {    let ans = 0;    for(const num of nums) {        if(num != val) {            nums[ans] = num;            ans++;        }    }    return ans;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序数组中的重复项</title>
      <link href="/2021/02/11/35.shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/"/>
      <url>/2021/02/11/35.shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</url>
      
        <content type="html"><![CDATA[<p><strong>删除排序数组中的重复项：</strong>给定一个排序数组，你需要在 <strong>原地</strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong>原地 修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><ul><li><p>示例 1:</p><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。</p></li><li><p>示例 2:</p><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></li></ul><p><strong>说明：</strong></p><p>为什么返回数值是整数，输出的答案是数组呢?</p><p>注意，输入数组是以<strong>「引用」</strong>方式传递，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下：</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><p><strong>题解：</strong></p><pre><code>var removeDuplicates = function(nums) {    var count = 0;    var n = nums.length;    for(let i = 1;i&lt;n;i++){        if(nums[i] != nums[i-1]){            nums[i-count] = nums[i]        }else{            count++;        }    }    return n-count;};</code></pre><pre><code>var removeDuplicates = function(nums) {    var j = 0;    var n = nums.length;    for(let i = 1;i&lt;n;i++){        if(nums[i]!=nums[i-1]){            j++;            nums[j] = nums[i];        }    }    return j+1;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序链表</title>
      <link href="/2021/02/10/34.he-bing-liang-ge-you-xu-lian-biao/"/>
      <url>/2021/02/10/34.he-bing-liang-ge-you-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<p><strong>合并两个有序链表：</strong>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><ul><li><p>示例 1：</p><p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]</p></li><li><p>示例 2：</p><p>输入：l1 = [], l2 = []<br>输出：[]</p></li><li><p>示例 3：</p><p>输入：l1 = [], l2 = [0]<br>输出：[0]</p></li></ul><p><strong>提示：</strong></p><ul><li>两个链表节点数目范围是 [0, 50]</li><li>-100 &lt;= Node.val &lt;= 100</li><li>l1 和 l2 均按 <strong>非递减顺序</strong> 排列</li></ul><p><strong>题解：</strong></p><pre><code>// 递归var mergeTwoLists = function(l1, l2) {    if (l1 === null) {        return l2;    } else if (l2 === null) {        return l1;    } else if (l1.val &lt; l2.val) {        l1.next = mergeTwoLists(l1.next, l2);        return l1;    } else {        l2.next = mergeTwoLists(l1, l2.next);        return l2;    }};</code></pre><pre><code>// 迭代var mergeTwoLists = function(l1, l2) {    const prehead = new ListNode(-1);    let prev = prehead;    while (l1 != null &amp;&amp; l2 != null) {        if (l1.val &lt;= l2.val) {            prev.next = l1;            l1 = l1.next;        } else {            prev.next = l2;            l2 = l2.next;        }        prev = prev.next;    }    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可    prev.next = l1 === null ? l2 : l1;    return prehead.next;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共前缀</title>
      <link href="/2021/02/08/32.zui-chang-gong-gong-qian-zhui/"/>
      <url>/2021/02/08/32.zui-chang-gong-gong-qian-zhui/</url>
      
        <content type="html"><![CDATA[<p><strong>最长公共前缀：</strong>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code>""</code>。</p><ul><li><p>示例 1：</p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”</p></li><li><p>示例 2：</p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p></li></ul><p><strong>提示：</strong></p><ul><li><code>0 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> 仅由小写英文字母组成</li></ul><p><strong>题解：</strong></p><pre><code>var longestCommonPrefix = function(strs) {    if(strs.length == 0)         return "";    let ans = strs[0];    for(let i =1;i&lt;strs.length;i++) {        let j=0;        for(;j&lt;ans.length &amp;&amp; j &lt; strs[i].length;j++) {            if(ans[j] != strs[i][j])                break;        }        ans = ans.substr(0, j);        if(ans === "")            return ans;    }    return ans;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的括号</title>
      <link href="/2021/02/08/33.you-xiao-de-gua-hao/"/>
      <url>/2021/02/08/33.you-xiao-de-gua-hao/</url>
      
        <content type="html"><![CDATA[<p><strong>有效的括号：</strong>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><ul><li><p>示例 1：</p><p>输入：s = “()”<br>输出：true</p></li><li><p>示例 2：</p><p>输入：s = “()[]{}”<br>输出：true</p></li><li><p>示例 3：</p><p>输入：s = “(]”<br>输出：false</p></li><li><p>示例 4：</p><p>输入：s = “([)]”<br>输出：false</p></li><li><p>示例 5：</p><p>输入：s = “{[]}”<br>输出：true</p></li></ul><p><strong>提示：</strong></p><ul><li>1 &lt;= s.length &lt;= 104</li><li>s 仅由括号 ‘()[]{}’ 组成</li></ul><p><strong>题解：</strong></p><pre><code>var isValid = function(s) {    const n = s.length;    if (n % 2 === 1) {        return false;    }    const pairs = new Map([        [')', '('],        [']', '['],        ['}', '{']    ]);    const stk = [];    s.split('').forEach(ch =&gt; {        if (pairs.has(ch)) {            if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {                return false;            }            stk.pop();        }         else {            stk.push(ch);        }    });    return !stk.length;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗马数字转整数</title>
      <link href="/2021/02/06/31.luo-ma-shu-zi-zhuan-zheng-shu/"/>
      <url>/2021/02/06/31.luo-ma-shu-zi-zhuan-zheng-shu/</url>
      
        <content type="html"><![CDATA[<p><strong>罗马数字转整数：</strong>罗马数字包含以下七种字符: I，V，X，L，C，D 和 M。</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 范围内。</p><ul><li><p>示例 1:</p><p>输入: “III”<br>输出: 3</p></li><li><p>示例 2:</p><p>输入: “IV”<br>输出: 4</p></li><li><p>示例 3:</p><p>输入: “IX”<br>输出: 9</p></li><li><p>示例 4:</p><p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.</p></li><li><p>示例 5:</p><p>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></li></ul><p>提示：</p><ul><li><p>1 &lt;= s.length &lt;= 15</p></li><li><p>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</p></li><li><p>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</p></li><li><p>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</p></li><li><p>IL 和 IM 这样的例子并不符合题目要求，49 应写作 XLIX，999 应写作 CMXCIX 。</p></li></ul><p><strong>题解：</strong></p><pre><code>var romanToInt = function(s) {    const map = {        I : 1,        IV: 4,        V: 5,        IX: 9,        X: 10,        XL: 40,        L: 50,        XC: 90,        C: 100,        CD: 400,        D: 500,        CM: 900,        M: 1000    };    let ans = 0;    for(let i = 0;i &lt; s.length;) {        if(i + 1 &lt; s.length &amp;&amp; map[s.substring(i, i+2)]) {            ans += map[s.substring(i, i+2)];            i += 2;        } else {            ans += map[s.substring(i, i+1)];            i ++;        }    }    return ans;};</code></pre><pre><code>var romanToInt = function(s) {    var hashNum = {        "I":1,        "V":5,        "X":10,        "L":50,        "C":100,        "D":500,        "M":1000    }    var result = 0;    for(let i = 0;i&lt;s.length;i++){        hashNum[s[i]] &lt; hashNum[s[i+1]] ? result -= hashNum[s[i]] : result += hashNum[s[i]]    }    return result;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文数</title>
      <link href="/2021/02/04/30.hui-wen-shu/"/>
      <url>/2021/02/04/30.hui-wen-shu/</url>
      
        <content type="html"><![CDATA[<p><strong>回文数：</strong>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。回文数是指正序（从左向右）和倒序（从右向左）都一样的整数。如：121 是回文，而 123 不是。</p><ul><li><p>示例 1：</p><p>输入：x = 121<br>输出：true</p></li><li><p>示例 2：</p><p>输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p></li><li><p>示例 3：</p><p>输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。</p></li><li><p>示例 4：</p><p>输入：x = -101<br>输出：false</p></li></ul><p><strong>题解：</strong></p><pre><code>var isPalindrome = function(x) {    return x === Number(x.toString().split('').reverse().join(''))};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数反转</title>
      <link href="/2021/02/02/29.zheng-shu-fan-zhuan/"/>
      <url>/2021/02/02/29.zheng-shu-fan-zhuan/</url>
      
        <content type="html"><![CDATA[<p><strong>整数反转：</strong>给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 [−2<sup>31</sup>,  2<sup>31</sup> − 1]，就返回 0。假设环境不允许存储 64 位整数（有符号或无符号）。</p><ul><li><p>示例 1：</p><p>输入：x = 123<br>输出：321</p></li><li><p>示例 2：</p><p>输入：x = -123<br>输出：-321</p></li><li><p>示例 3：</p><p>输入：x = 120<br>输出：21</p></li><li><p>示例 4：</p><p>输入：x = 0<br>输出：0</p></li></ul><p><strong>解题思路：</strong></p><ul><li>result * 10 + x % 10 取出末位， x % 10（负数结果还是负数，无需关心正负），拼接到 result 中。</li><li>x / 10 去除末位，| 0 强制转换为32位有符号整数。</li><li>通过 | 0 取整，无论正负，只移除小数点部分（正数向下取整，负数向上取整）。</li><li>result | 0 超过32位的整数转换结果不等于自身，可用作溢出判断。</li></ul><p><strong>题解：</strong></p><pre><code>var reverse = function(x) {    let result = 0;    while(x !== 0) {        result = result * 10 + x % 10;        x = (x / 10) | 0;    }    return (result | 0) === result ? result : 0;};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2021/01/30/28.liang-shu-zhi-he/"/>
      <url>/2021/01/30/28.liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<p><strong>两数之和：</strong>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中的同一个元素不能使用两遍。你可以按任意顺序返回答案。</p><ul><li><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p></li><li><p>示例 2：</p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p></li><li><p>示例 3：</p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p></li></ul><p><strong>题解：</strong></p><pre><code>// 暴力枚举var twoSum = function (nums, target) {  let n = nums.length;  for (let i = 0; i &lt; n; i++) {    for (let j = i + 1; j &lt; n; j++) {      if (nums[i] + nums[j] === target) {        return [i, j]      }    }  }  return []};</code></pre><pre><code>// 哈希表var twoSum = function(nums, target){    const map = new Map();    for(let i=0; i&lt;nums.length; i++){        if (map.has(nums[i])){            return [map.get(nums[i]),i];        }else{            map.set(target-nums[i],i);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element UI 组件心得</title>
      <link href="/2021/01/28/27.element-ui-zu-jian/"/>
      <url>/2021/01/28/27.element-ui-zu-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Drawer-抽屉"><a href="#一、Drawer-抽屉" class="headerlink" title="一、Drawer 抽屉"></a>一、Drawer 抽屉</h2><p>这个抽屉组件在 Element 组件的最下面，通过搜索框匹配不到</p><p><img src="1.1.png"></p><p>它是一个带遮罩效果的弹出层，可以设置从设备屏幕的上下左右四个方向弹出，<strong>值得注意的是只能从屏幕的起始位置弹出，如果设置绝对定位或相对定位或者是 margin 都会使里面放置的内容布局出错，遮罩层的点击关闭抽屉事件也会失效</strong>。</p><p><img src="1.2.png"></p><p>Drawer 抽屉类似于 Dialog 弹框组件，里面可以放置表单、表格等多种内容。</p><p>上方页面的效果一开始是使用 Dialog 组件加上手写的 CSS 遮罩来实现，代码冗杂切实现比较麻烦，各种布局层级定位需要调整不好维护，还要修改兼容组件封装好的默认功能，所以挑对组件真的很关键。</p><blockquote><p>Bug：对于抽屉里的表单，如果是在 Vue 的 data 中写死的静态数据则不会自动打开获取焦点，但是后台接口遍历得到的数据则会在抽屉打开的时候自动聚焦第一个表单。如果这个表单是浏览框，它会在抽屉打开的时候自动打开浏览框弹窗，这样体验就很差了。</p></blockquote><p>我一开始是想用 jQuery 获取到抽屉中的第一个表单元素，给抽屉展开的按钮绑定一个点击方法 blur() 去取消聚焦第一个表单。这种方案完全不行，因为抽屉会先展开 =&gt; 聚焦第一个元素 =&gt; 再取消聚焦，此时浏览框已经打开了。后来查文档发现 Drawer 组件有两个事件，<strong>open：Drawer 打开的回调；opened：Drawer 打开动画结束时的回调。</strong>写在这里头还是不行。</p><ul><li>需要在 Drawer 中设置一个 div，设置 ref 和 tabindex 属性用于定位，为 drawer 设置 opened 事件：</li></ul><p><img src="1.3.png"></p><ul><li>在事件中手动聚焦在 div 中（注意：此处的 _this 为在 create 中手动定义的 this）：</li></ul><pre><code>created() {  _this = this;},</code></pre><p><img src="1.4.png"></p><pre class="line-numbers language-javascript"><code class="language-javascript">clearFocus<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  _this<span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>clearRef<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    _this<span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>clearRef<span class="token punctuation">.</span><span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">blur</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就解决了 Element UI Drawer 抽屉组件的聚焦 Bug！</p><p>文档中 Drawer 抽屉组件的 size 属性值为 number / string，试了下设置成 auto 可以自适应，这样表单过多时就不会出现：overflow: hidden; 效果。</p><h2 id="二、Input-输入框"><a href="#二、Input-输入框" class="headerlink" title="二、Input 输入框"></a>二、Input 输入框</h2><p><strong>有时需要屏蔽 input 默认的回车事件/取消回车自动提交表单：</strong></p><p><strong>方法一： 在 form 标签上添加 ‘onkeypress’</strong> </p><pre><code>&lt;form onkeypress="return event.keyCode != 13;"&gt;</code></pre><p><strong>方法二： JQuery 统一处理</strong> </p><pre><code>$(document).on("keypress", "form", function(event) {     return event.keyCode != 13;});</code></pre><p><strong>方法三： JavaScript 统一处理</strong> </p><pre><code> killDefault(event){      var evt = window.event || event;      if (evt.keyCode == 13) {        if(evt.preventDefault){          evt.preventDefault();        }else{          evt.returnValue=false;        }      }    }</code></pre><h2 id="三、Select-选择器"><a href="#三、Select-选择器" class="headerlink" title="三、Select 选择器"></a>三、Select 选择器</h2><p>在 el-select 里面增加 style=“width:500px”，发现没有效果，为什么呢，因为在 element 里面固定好了控件的样式，el-input 里面增加style=”width:500px” 会有效果。</p><p>可以利用 CSS 的样式优先级写一个自定义的 class 来覆盖。</p><h2 id="四、table-行高"><a href="#四、table-行高" class="headerlink" title="四、table 行高"></a>四、table 行高</h2><p>Element UI 自带的 table 设置行高：</p><pre><code>:row-style="{height: 'xxpx'}":cell-style="{padding: '0'}"</code></pre><h2 id="五、表格联合搜索框"><a href="#五、表格联合搜索框" class="headerlink" title="五、表格联合搜索框"></a>五、表格联合搜索框</h2><p>这个不像 Bootstrap 和若依框架只需要申明式的做一下配置就可以实现搜索框对表格数据的筛选联动，具体代码略：</p><pre><code>// 搜索框&lt;el-input type="text" v-model="tableDataName" size="mini"&gt;&lt;/el-input&gt;// 按钮&lt;el-button type="primary" @click="doFilter" size="mini"&gt;搜索&lt;/el-button&gt;</code></pre><pre><code>mounted: function () {  var that = this;  that.getTableData();  that.getTableFilter()}</code></pre><pre><code>// 获取表格数据getTableData() {..}// 筛选后台数据getTableFilter() {...}// 筛选表格doFilter() {...}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Element UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECharts 甘特图</title>
      <link href="/2021/01/24/26.echarts-gan-te-tu/"/>
      <url>/2021/01/24/26.echarts-gan-te-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h2><p>进入 ECharts 官网：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a> ，没有用过的话最好先过一遍它的5分钟快速入门教程。</p><p><strong>值得注意的是在使用 ECharts 时 jQuery 的库也要按需引入</strong>。推荐使用 jsDelivr 方式引入。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"jQuery存放路径/jquery.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"echarts存放/echarts.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="二、甘特图"><a href="#二、甘特图" class="headerlink" title="二、甘特图"></a>二、甘特图</h2><p>参考 CSDN 社区的这篇博客：<a href="https://blog.csdn.net/yixu0534/article/details/82785119">https://blog.csdn.net/yixu0534/article/details/82785119</a></p><p>他的甘特图不兼容高版本的 ECharts，使用时需要引入 4.0.2 版本。</p><p>引入后发现我之前用 5.0.1 版本制作的树，饼、柱状图表默认样式变丑了，还有部分图表无法显示，体验不是很好。所以想要自定义一个不错的甘特图还是得慢慢看文档说明。</p><h2 id="三、部分代码"><a href="#三、部分代码" class="headerlink" title="三、部分代码"></a>三、部分代码</h2><pre><code>// head&lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;ECharts 图表&lt;/title&gt;    &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"&gt;&lt;/script&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/echarts@5.0.1/dist/echarts.min.js"&gt;&lt;/script&gt;&lt;/head&gt;</code></pre><pre><code>// body&lt;body&gt;    &lt;div class="chartBox"&gt;      &lt;div class="leftChart"&gt;        &lt;div id="chart1" style="width: 600px; height: 300px"&gt;&lt;/div&gt;        &lt;div id="chart4" style="width: 600px; height: 300px"&gt;&lt;/div&gt;      &lt;/div&gt;      &lt;div class="rightChart"&gt;        &lt;div id="chart2" style="width: 600px; height: 300px"&gt;&lt;/div&gt;        &lt;div id="chart3" style="width: 600px; height: 300px"&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre><code>// script&lt;script type="text/javascript"&gt;  var chartDom1 = document.getElementById("chart1");  var myChart1 = echarts.init(chartDom1);  var option1;  var treeDatePath = "./echartsTree.json";  var chartDom2 = document.getElementById("chart2");  var myChart2 = echarts.init(chartDom2);  var option2;  var chartDom3 = document.getElementById("chart3");  var myChart3 = echarts.init(chartDom3);  var option3;  var chartDom4 = document.getElementById("chart4");  var myChart4 = echarts.init(chartDom4);  var option4;  // 树状图（参考示例）  ...   // 饼状图（参考示例）  option2 = { ...  // 柱形图（参考示例）  option3 = { ...  // 甘特图（参考示例）  option4 = { ...    option1 &amp;&amp; myChart1.setOption(option1);  option2 &amp;&amp; myChart2.setOption(option2);  option3 &amp;&amp; myChart3.setOption(option3);  option4 &amp;&amp; myChart4.setOption(option4);&lt;/script&gt;</code></pre><pre><code>// style&lt;style&gt;  .chartBox {    display: flex;    align-items: center;    justify-content: space-between;  }  .leftChart {    margin: 20px;  }  .rightChart {    margin: 20px;  }&lt;/style&gt;</code></pre><h2 id="四、效果"><a href="#四、效果" class="headerlink" title="四、效果"></a>四、效果</h2><p><img src="4.1.png"></p><p>基本情况就是这样，具体操作可参考官方教程：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></p><h2 id="五、报错"><a href="#五、报错" class="headerlink" title="五、报错"></a>五、报错</h2><p>ECharts 报错：**”export ‘default’ (imported as ‘echarts’) was not found in ‘echarts’**</p><p>这个是 ECharts 版本太新导致的，引入时这样引入就行了：</p><pre><code>import * as echarts from 'echarts'</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECharts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap - table 使用总结</title>
      <link href="/2021/01/20/25.bootstrap-table/"/>
      <url>/2021/01/20/25.bootstrap-table/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>　　在业务系统开发中，对表格记录的查询、分页、排序等处理是非常常见的，在 Web 开发中，可以采用很多功能强大的插件来满足要求，且能极大的提高开发效率，本随笔介绍这个 Bootstrap-table 是一款非常有名的开源表格插件，在很多项目中广泛的应用。 Bootstrap-table 插件提供了非常丰富的属性设置，可以实现查询、分页、排序、复选框、设置显示列、Card view 视图、主从表显示、合并列、国际化处理等处理功能，而且该插件同时也提供了一些不错的扩展功能，如移动行、移动列位置等一些特殊的功能，插件可以用基于 HTML5 的 data-* 属性标识设置，也可以使用 Javascript 方式进行设置，非常方便。本篇随笔介绍 Bootstrap-table 插件在我实际项目中的应用情况，总结相关使用中碰到的问题处理经验。</p><h2 id="二、模式"><a href="#二、模式" class="headerlink" title="二、模式"></a>二、模式</h2><p>Bootstrap-Table 显示数据到表格的方式有两种，一种是客户端（client）模式，一种是服务器（server）模式。</p><p>　　客户端模式：指的是在服务器中把要显示到表格的数据一次性加载出来，然后转换成 JSON 格式传到要显示的界面中，客户端模式较为简单，它是把数据一次性加载出来放到界面上，然后根据你设置的每页记录数，自动生成分页。当点击第二页时，会自动加载出数据，不会再向服务器发送请求。同时用户可以使用其自带的搜索功能，可以实现全数据搜索。对于数据量较少的时候，可以使用这个方法。</p><p>　　服务器模式：指的是根据设定的每页记录数和当前要显示的页码，发送数据到服务器进行查询，然后再显示到表格中。该方法可以根据用户的需要动态的加载数据，节省了服务器的资源，但是不能使用其自带的全数据搜索功能。</p><p>Bootstrap-table 是基于 Boostrap 开发的插件，因此使用的时候，需要引入 Bootstrap 的脚本和样式。</p><p>如果我们项目中没有引入相关的文件，则需要引入这些样式和脚本文件，如下所示。</p><pre><code>1 &lt;link rel="stylesheet" href="bootstrap.min.css"&gt;2 &lt;script src="jquery.min.js"&gt;&lt;/script&gt;3 &lt;script src="bootstrap.min.js"&gt;&lt;/script&gt;</code></pre><p>然后是 Bootstrap-table 的依赖引用：</p><p>CSS 文件引入：</p><pre><code>1 &lt;link rel="stylesheet" href="bootstrap-table.css"&gt;</code></pre><p>脚本文件引入：</p><pre><code>1 &lt;script src="bootstrap-table.js"&gt;&lt;/script&gt;2 &lt;--汉化文件，放在 bootstrap-table.js 后面--&gt;3 &lt;script src="bootstrap-table-zh-CN.js"&gt;&lt;/script&gt;</code></pre><p>Bootstrap-table 在页面中的使用，可以分为两种，一种是纯粹用 HTML5 的写法，通过 data-* 的方式指定各种属性设置，一种是 HTML + JS 方式实现弹性设置。</p><p>如果我们采用 HTML5 标识的方式初始化 HTML 代码，则是下面的代码。</p><pre><code>1 &lt;table data-toggle="table" data-url="data1.json"&gt;2     &lt;thead&gt;3         &lt;tr&gt;4             &lt;th data-field="id"&gt;Item ID&lt;/th&gt;5             &lt;th data-field="name"&gt;Item Name&lt;/th&gt;6             &lt;th data-field="price"&gt;Item Price&lt;/th&gt;7         &lt;/tr&gt;8     &lt;/thead&gt;9 &lt;/table&gt;</code></pre><p> 如果我们采用 JS 代码方式来初始化表格插件，那么只需要在 HTML 上声明一个表格对象即可，如下代码。</p><pre><code>1 &lt;table id="table"&gt;&lt;/table&gt;</code></pre><p>JS 代码如下：</p><pre><code> 1 $('#table').bootstrapTable({ 2     url: 'data1.json', 3     columns: [{ 4         field: 'id', 5         title: 'Item ID' 6     }, { 7         field: 'name', 8         title: 'Item Name' 9     }, {10         field: 'price',11         title: 'Item Price'12     }, ]13 });</code></pre><h2 id="三、详解"><a href="#三、详解" class="headerlink" title="三、详解"></a>三、详解</h2><h4 id="1）JS-属性配置"><a href="#1）JS-属性配置" class="headerlink" title="1）JS 属性配置"></a>1）JS 属性配置</h4><pre><code> 1 var $table; 2         //初始化bootstrap-table的内容 3         function InitMainTable () { 4             //记录页面bootstrap-table全局变量$table，方便应用 5             var queryUrl = '/TestUser/FindWithPager?rnd=' + Math.random() 6             $table = $('#grid').bootstrapTable({ 7                 url: queryUrl,                      //请求后台的URL（*） 8                 method: 'GET',                      //请求方式（*） 9                 //toolbar: '#toolbar',              //工具按钮用哪个容器10                 striped: true,                      //是否显示行间隔色11                 cache: false,                       //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*）12                 pagination: true,                   //是否显示分页（*）13                 sortable: true,                     //是否启用排序14                 sortOrder: "asc",                   //排序方式15                 sidePagination: "server",           //分页方式：client客户端分页，server服务端分页（*）16                 pageNumber: 1,                      //初始化加载第一页，默认第一页,并记录17                 pageSize: rows,                     //每页的记录行数（*）18                 pageList: [10, 25, 50, 100],        //可供选择的每页的行数（*）19                 search: false,                      //是否显示表格搜索20                 strictSearch: true,21                 showColumns: true,                  //是否显示所有的列（选择显示的列）22                 showRefresh: true,                  //是否显示刷新按钮23                 minimumCountColumns: 2,             //最少允许的列数24                 clickToSelect: true,                //是否启用点击选中行25                 //height: 500,                      //行高，如果没有设置height属性，表格自动根据记录条数觉得表格高度26                 uniqueId: "ID",                     //每一行的唯一标识，一般为主键列27                 showToggle: true,                   //是否显示详细视图和列表视图的切换按钮28                 cardView: false,                    //是否显示详细视图29                 detailView: false,                  //是否显示父子表30                 //得到查询的参数31                 queryParams : function (params) {32                     //这里的键的名字和控制器的变量名必须一致，这边改动，控制器也需要改成一样的33                     var temp = {   34                         rows: params.limit,                         //页面大小35                         page: (params.offset / params.limit) + 1,   //页码36                         sort: params.sort,      //排序列名  37                         sortOrder: params.order //排位命令（desc，asc） 38                     };39                     return temp;40                 },41                 columns: [{42                     checkbox: true,  43                     visible: true                  //是否显示复选框  44                 }, {45                     field: 'Name',46                     title: '姓名',47                     sortable: true48                 }, {49                     field: 'Mobile',50                     title: '手机',51                     sortable: true52                 }, {53                     field: 'Email',54                     title: '邮箱',55                     sortable: true,56                     formatter: emailFormatter57                 }, {58                     field: 'Homepage',59                     title: '主页',60                     formatter: linkFormatter61                 }, {62                     field: 'Hobby',63                     title: '兴趣爱好'64                 }, {65                     field: 'Gender',66                     title: '性别',67                     sortable: true68                 }, {69                     field: 'Age',70                     title: '年龄'71                 }, {72                     field: 'BirthDate',73                     title: '出生日期',74                     formatter: dateFormatter75                 }, {76                     field: 'Height',77                     title: '身高'78                 }, {79                     field: 'Note',80                     title: '备注'81                 }, {82                     field:'ID',83                     title: '操作',84                     width: 120,85                     align: 'center',86                     valign: 'middle',87                     formatter: actionFormatter88                 }, ],89                 onLoadSuccess: function () {90                 },91                 onLoadError: function () {92                     showTips("数据加载失败！");93                 },94                 onDblClickRow: function (row, $element) {95                     var id = row.ID;96                     EditViewById(id, 'view');97                 },98             });99         };</code></pre><h4 id="2）查询及分页"><a href="#2）查询及分页" class="headerlink" title="2）查询及分页"></a>2）查询及分页</h4><p>这里的表格数据分页是采用服务器分页的方式，根据搜索条件从服务器返回数据记录的，并使用了排序的处理方式，这里的 queryParams 参数就是提交到服务器端的参数了。</p><pre><code> 1 //得到查询的参数 2 queryParams : function (params) { 3 //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的 4      var temp = {    5            rows: params.limit,                         //页面大小 6            page: (params.offset / params.limit) + 1,   //页码 7            sort: params.sort,      //排序列名   8            sortOrder: params.order //排位命令（desc，asc）  9      };10    return temp;11 },</code></pre><p> 另外我们看到返回数据的URL地址接口是FindWithPager，我们来看看这个MVC控制器方法是如何处理数据返回的。</p><pre><code> 1 /// &lt;summary&gt; 2         /// 根据条件查询数据库,并返回对象集合(用于分页数据显示) 3         /// &lt;/summary&gt; 4         /// &lt;returns&gt;指定对象的集合&lt;/returns&gt; 5         public override ActionResult FindWithPager() 6         { 7             //检查用户是否有权限，否则抛出MyDenyAccessException异常 8             base.CheckAuthorized(AuthorizeKey.ListKey); 9 10             string where = GetPagerCondition();11             PagerInfo pagerInfo = GetPagerInfo();12             var sort = GetSortOrder();13 14             List&lt;TestUserInfo&gt; list = null;15             if (sort != null &amp;&amp; !string.IsNullOrEmpty(sort.SortName))16             {17                 list = baseBLL.FindWithPager(where, pagerInfo, sort.SortName, sort.IsDesc);18             }19             else20             {21                 list = baseBLL.FindWithPager(where, pagerInfo);22             } 23 24             //Json格式的要求{total:22,rows:{}}25             //构造成Json的格式传递26             var result = new { total = pagerInfo.RecordCount, rows = list };27             return ToJsonContent(result);28         }</code></pre><p>处理了两个部分的对象信息，一个是分页实体类信息，一个是排序信息，然后根据这些条件获取记录，返回类似</p><pre><code>{total:22,rows:{}}</code></pre><p>格式的 JSON 数据记录。</p><pre><code>1 var result = new { total = pagerInfo.RecordCount, rows = list };2 return ToJsonContent(result);</code></pre><p> 获取分页的参数信息如下所示：</p><pre><code> 1 /// &lt;summary&gt; 2         /// 根据Request参数获取分页对象数据 3         /// &lt;/summary&gt; 4         /// &lt;returns&gt;&lt;/returns&gt; 5         protected virtual PagerInfo GetPagerInfo() 6         { 7             int pageIndex = Request["page"] == null ? 1 : int.Parse(Request["page"]); 8             int pageSize = Request["rows"] == null ? 10 : int.Parse(Request["rows"]); 9 10             PagerInfo pagerInfo = new PagerInfo();11             pagerInfo.CurrenetPageIndex = pageIndex;12             pagerInfo.PageSize = pageSize;13 14             return pagerInfo;15         }</code></pre><p> 获取排序参数信息的代码如下所示：</p><pre><code> 1 /// &lt;summary&gt; 2         /// 获取排序的信息 3         /// &lt;/summary&gt; 4         /// &lt;returns&gt;&lt;/returns&gt; 5         protected SortInfo GetSortOrder() 6         { 7             var name = Request["sort"]; 8             var order = Request["sortOrder"]; 9             return new SortInfo(name, order);10         }</code></pre><p> 最后就是具体实现具体条件、具体页码、具体排序条件下的数据记录了，这部分可以根据自己的要求实现逻辑，这里只是给出一个封装好的处理调用即可。</p><pre><code>baseBLL.FindWithPager(where, pagerInfo, sort.SortName, sort.IsDesc);</code></pre><p>实际情况下，我们列表的展示，一般需要使用不同的条件进行数据的查询的，虽然这个 Bootstrap-table 控件提供了一个默认的查询按钮，不过一般是在客户端分页的情况下使用，而且略显简单，我们一般使用自己查询条件进行处理。</p><p>那么这样对于上面的 JS 属性就需要调整下接受查询条件参数 queryParams 了：</p><pre><code> 1 //得到查询的参数 2                 queryParams : function (params) { 3                     //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的 4                     var temp = {    5                         rows: params.limit,                         //页面大小 6                         page: (params.offset / params.limit) + 1,   //页码 7                         sort: params.sort,      //排序列名   8                         sortOrder: params.order //排位命令（desc，asc）  9                     }; 10                     return temp; 11                 },</code></pre><p> 对于自定义查询条件，我们可以用下面的常规方式增加参数，如下所示：</p><p><img src="3.1.png"></p><p>但是查询条件的参数我们不方便一一设置，我们想通过一种较为快捷的方式来处理，那么就需要对这个处理方式进行一个特别的修改了，首先添加一个扩展函数来处理表单的条件（参考博客<a href="http://www.cnblogs.com/zcsj/p/6635677.html%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%89">http://www.cnblogs.com/zcsj/p/6635677.html的介绍）</a></p><pre><code> 1 //自定义函数处理queryParams的批量增加 2         $.fn.serializeJsonObject = function () { 3             var json = {}; 4             var form = this.serializeArray(); 5             $.each(form, function () { 6                 if (json[this.name]) { 7                     if (!json[this.name].push) { 8                         json[this.name] = [json[this.name]]; 9                     }10                     json[this.name].push();11                 } else {12                     json[this.name] = this.value || '';13                 }14             });15             return json;16         }</code></pre><p> 然后我们就可以批量处理表单的查询条件了。</p><pre><code> 1 queryParams : function (params) { 2                     //这里的键的名字和控制器的变量名必须一直，这边改动，控制器也需要改成一样的 3                     var temp = $("#ffSearch").serializeJsonObject(); 4                     temp["rows"] = params.limit;                        //页面大小 5                     temp["page"] = (params.offset / params.limit) + 1;  //页码 6                     temp["sort"] = params.sort;                         //排序列名 7                     temp["sortOrder"] = params.order;                   //排位命令（desc，asc）  8  9                     //特殊格式的条件处理10                     temp["WHC_Age"] = $("#WHC_Age").val() + "~" + $("#WHC_Age2").val();11                     temp["WHC_BirthDate"] = $("#WHC_BirthDate").val() + "~" + $("#WHC_BirthDate2").val();12 13                     return temp;14                 },</code></pre><p>然后后端统一按照逻辑处理查询参数即可。</p><h4 id="3）格式化输出函数及其他"><a href="#3）格式化输出函数及其他" class="headerlink" title="3）格式化输出函数及其他"></a>3）格式化输出函数及其他</h4><p>对于上面JS的配置信息，我们再来回顾一下，例如对于数据转义函数，可以格式化输出的内容的，如下界面代码。</p><p><img src="3.2.png"></p><p>格式化的数据转义函数如下，主要就是根据内容进行格式化输出的 JS 函数，好像是需要放在一个文件内。</p><pre><code> 1 //连接字段格式化 2         function linkFormatter(value, row, index) {                 3             return "&lt;a href='" + value + "' title='单击打开连接' target='_blank'&gt;" + value + "&lt;/a&gt;"; 4         } 5         //Email字段格式化 6         function emailFormatter(value, row, index) { 7             return "&lt;a href='mailto:" + value + "' title='单击打开连接'&gt;" + value + "&lt;/a&gt;"; 8         } 9         //性别字段格式化10         function sexFormatter(value) {11             if (value == "女") { color = 'Red'; }12             else if (value == "男") { color = 'Green'; }13             else { color = 'Yellow'; }14 15             return '&lt;div  style="color: ' + color + '"&gt;' + value + '&lt;/div&gt;';16         }</code></pre><p> 另外，我们看到行记录的最后增加了几个操作按钮，方便对当前记录的查看、编辑和删除操作，如下效果图所示。</p><p><img src="3.3.png"></p><p>这部分我们也是通过格式化函数进行处理的：</p><p><img src="3.4.png"></p><pre><code> 1 //操作栏的格式化 2         function actionFormatter(value, row, index) { 3             var id = value; 4             var result = ""; 5             result += "&lt;a href='javascript:;' class='btn btn-xs green' onclick=\"EditViewById('" + id + "', view='view')\" title='查看'&gt;&lt;span class='glyphicon glyphicon-search'&gt;&lt;/span&gt;&lt;/a&gt;"; 6             result += "&lt;a href='javascript:;' class='btn btn-xs blue' onclick=\"EditViewById('" + id + "')\" title='编辑'&gt;&lt;span class='glyphicon glyphicon-pencil'&gt;&lt;/span&gt;&lt;/a&gt;"; 7             result += "&lt;a href='javascript:;' class='btn btn-xs red' onclick=\"DeleteByIds('" + id + "')\" title='删除'&gt;&lt;span class='glyphicon glyphicon-remove'&gt;&lt;/span&gt;&lt;/a&gt;"; 8  9             return result;10         }</code></pre><p> 如果我们需要双击弹出编辑界面的层，我们可以处理表格的双击事件，如下代码所示。</p><pre><code>1 onDblClickRow: function (row, $element) {2                     var id = row.ID;3                     EditViewById(id, 'view');4                 },</code></pre><p> <img src="3.5.png"></p><p>如果我们需要设置行的不同的样式展示，可以通过增加 rowStyle 的 JS 处理函数即可，如下代码所示：</p><pre><code>1 rowStyle: function (row, index) { //设置行的特殊样式2                     //这里有5个取值颜色['active', 'success', 'info', 'warning', 'danger'];3                     var strclass = "";4                     if (index == 0) {5                         strclass = "warning";6                     }7                     return { classes: strclass }8                 }</code></pre><p> 对于表格记录的获取，我们可以通过下面的代码进行获取：$table.bootstrapTable(‘getSelections’)</p><pre><code>1   var rows = $table.bootstrapTable('getSelections');2             if (rows.length &gt; 0) {3                 ID = rows[0].ID;4             }</code></pre><p> 如果是多条记录的处理，例如删除记录。</p><pre><code> 1 //实现删除数据的方法 2         function Delete() { 3             var ids = "";//得到用户选择的数据的ID 4             var rows = $table.bootstrapTable('getSelections'); 5             for (var i = 0; i &lt; rows.length; i++) { 6                 ids += rows[i].ID + ','; 7             } 8             ids = ids.substring(0, ids.length - 1); 9 10             DeleteByIds(ids);11         }</code></pre><p> 如果需要设置显示列显示，如下界面所示：</p><p><img src="3.6.png"></p><p>以及排序处理：</p><p><img src="3.7.png"></p><p>这些需要在 JS 代码开启相关的属性即可。</p><p><img src="3.8.png"></p><p>还有就是一种 CardView 的卡片视图格式，如下所示：</p><p><img src="3.9.png"></p><p>另外一种是父子表的展开明细的格式，如下所示：</p><p><img src="3.10.png"></p><p>以上就是 Bootstrap-table 插件在我实际项目中的应用情况，基本上对 JS 各个属性的使用进行了一些介绍了，具体的应用我们可以参考它的文档，获取对应属性、方法、事件的详细说明，这样我们就可以更加详细的应用这个插件的各种功能了。</p><p> <a href="http://bootstrap-table.wenzhixin.net.cn/documentation/">http://bootstrap-table.wenzhixin.net.cn/documentation/</a></p><p>PS：以上为转载内容，经过自己的梳理后重新发布，感谢原作者<a href="https://home.cnblogs.com/u/wuhuacong/">伍华聪</a>，原文路径：<a href="https://www.cnblogs.com/wuhuacong/p/7284420.html">https://www.cnblogs.com/wuhuacong/p/7284420.html</a></p><h2 id="四、分页"><a href="#四、分页" class="headerlink" title="四、分页"></a>四、分页</h2><p>在 Spring MVC 及 SpringBoot 项目中使用 Bootstrap-table 进行分页。</p><p><strong>前端代码块：</strong></p><pre><code>　　页面： 1 &lt;table id="test-table" class="col-xs-12" data-toolbar="#toolbar"&gt;　　JS: 2 function initTable(){ 3             $('#test-table').bootstrapTable({ 4                 method: 'get', 5                 toolbar: '#toolbar',    //工具按钮用哪个容器 6                 striped: true,      //是否显示行间隔色 7                 cache: false,      //是否使用缓存，默认为true，所以一般情况下需要设置一下这个属性（*） 8                 pagination: true,     //是否显示分页（*） 9                 sortable: false,      //是否启用排序10                 sortOrder: "asc",     //排序方式11                 pageNumber:1,      //初始化加载第一页，默认第一页12                 pageSize: 10,      //每页的记录行数（*）13                 pageList: [10, 25, 50, 100],  //可供选择的每页的行数（*）14                 url: "/testProject/page4list.json",//这个接口需要处理bootstrap table传递的固定参数15                 queryParamsType:'', //默认值为 'limit' ,在默认情况下 传给服务端的参数为：offset,limit,sort16                                     // 设置为 ''  在这种情况下传给服务器的参数为：pageSize,pageNumber17 18                 //queryParams: queryParams,//前端调用服务时，会默认传递上边提到的参数，如果需要添加自定义参数，可以自定义一个函数返回请求参数19                 sidePagination: "server",   //分页方式：client客户端分页，server服务端分页（*）20                 //search: true,      //是否显示表格搜索，此搜索是客户端搜索，不会进服务端，所以，个人感觉意义不大21                 strictSearch: true,22                 //showColumns: true,     //是否显示所有的列23                 //showRefresh: true,     //是否显示刷新按钮24                 minimumCountColumns: 2,    //最少允许的列数25                 clickToSelect: true,    //是否启用点击选中行26                 searchOnEnterKey: true,27                 columns: [{28                     field: 'id',29                     title: 'id',30                     align: 'center'31                 }, {32                     field: 'testkey',33                     title: '测试标识',34                     align: 'center'35                 }, {36                     field: 'testname',37                     title: '测试名字',38                     align: 'center'39                 },{40                     field: 'id',41                     title: '操作',42                     align: 'center',43                     formatter:function(value,row,index){44                         //通过formatter可以自定义列显示的内容45                         //value：当前field的值，即id46                         //row：当前行的数据47                         var a = '&lt;a href="" &gt;测试&lt;/a&gt;';48                     } 49                 }],50                 pagination:true51             });52         }</code></pre><p>在前端通过请求获取 table 数据时，Bootstrap table会默认拼一个 searchText 的参数，来支持查询功能。</p><p><strong>服务端代码：</strong></p><pre><code> 1  @RequestMapping(value = "/page4list.json") 2 public void page4list(Integer pageSize, Integer pageNumber, String searchText, HttpServletRequest request, 3             HttpServletResponse response) { 4  5         //搜索框功能 6         //当查询条件中包含中文时，get请求默认会使用ISO-8859-1编码请求参数，在服务端需要对其解码 7         if (null != searchText) { 8             try { 9                 searchText = new String(searchText.getBytes("ISO-8859-1"), "UTF-8");10             } catch (Exception e) {11                 e.printStackTrace();12             }13         }14         //在service通过条件查询获取指定页的数据的list15         List&lt;MwmsgType&gt; list = mwMsgQueueService.page4List(pageSize, pageNumber, searchText);16         //根据查询条件，获取符合查询条件的数据总量17         int total = mwMsgQueueService.queryCountBySearchText(searchText);18         //自己封装的数据返回类型，bootstrap-table要求服务器返回的json数据必须包含：totlal，rows两个节点19         PageResultForBootstrap page = new PageResultForBootstrap();20         page.setTotal(total);21         page.setRows(list);22         //page就是最终返回给客户端的数据结构，可以直接返回给前端23 24         //下边这段，只是我自己的代码有自定义的spring HandlerInterceptor处理返回值，可以忽略。25         request.setAttribute(Constants.pageResultData, page);26 27     }</code></pre><p>完成上述代码，就可以实现服务器端自动分页，Bootstrap-table 根据服务器端返回的 total，以及 table 设定的 pageSize，自动生成分页的页面元素，每次点击下一页或者指定页码，Bootstrap-table 会自动给参数 pageNumber 赋值，服务器返回指定页的数据。</p><p><strong>如果发送的是 post 请求，因为 Bootstap table 使用的是 ajax 方式获取数据，这时会将请求的 content type 默认设置为  text/plain，这样在服务端直接通过 @RequestParam 参数映射是获取不到的。</strong></p><p><strong>这时就需要在 Bootstrap-table 的参数列表中显式设置：</strong></p><pre><code>1 contentType: "application/x-www-form-urlencoded"</code></pre><p><strong>设置成 form 表单的形式，tomcat 内部就会自动将 requset payload 中的数据部分解析放到 request.getParameter() 中，之后就可以直接通过 @RequestParam 映射参数获取。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea 热部署</title>
      <link href="/2021/01/18/24.idea-re-bu-shu/"/>
      <url>/2021/01/18/24.idea-re-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>热部署就是正在运行状态的应用，<strong>修改源码后，在不重新启动的情况下能够自动把增量内容编译并部署到服务器上，使得修改立即生效</strong>。热部署解决的问题有两个， 一是在开发的时候，修改代码后不需要重启应用就能看到效果，提升开发效率；二是生产上运行的程序，可以在不停止运行的情况下进行升级，不影响用户使用。</p><p>用 Idea 的人大多数都是用来开发 Java 程序，当前流行的 Java 程序主要有两种，第一种是传统的 Web 应用，依赖 Tomcat 这种 Web 容器运行；第二种是 SpringBoot 程序， 内嵌了运行环境。我只记录配置 SpringBoot 热部署的方法。</p><h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h2><p><strong>开启自动编译：</strong></p><ul><li><strong>Ctrl+Alt+S 打开配置</strong></li><li><strong>设置自动编译</strong><br><strong>File-Settings-Compiler-Build Project automatically</strong></li></ul><p><img src="2.1.png"></p><ul><li><strong>Ctrl+Shift+Alt+/ 选择 Registry</strong></li></ul><p><img src="2.2.png"></p><ul><li>找到选项 <strong>Compiler autoMake allow when app running</strong> 打勾</li></ul><p><img src="2.3.png"></p><p><strong>设置项目启动加载方式：</strong></p><ul><li>菜单栏选择 <strong>Run-&gt;Edit Configurations…</strong></li></ul><p><img src="2.4.png"></p><p>找到 <strong>SpringBoot</strong>下的 <strong>On Update action</strong> 和 <strong>On frame deactivation</strong> ，选择 <strong>Update classes and resources</strong>。</p><p><img src="2.5.png"></p><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>修改代码，查看 Idea 最下方的提示条，出现 <strong>build</strong> 后 紧接着出现 <strong>parsing java…</strong> 表示正在重新编译，值得注意的是热部署也是要一定时间的，更新会有一个短暂的延迟。</p><p><img src="2.6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 React</title>
      <link href="/2021/01/12/23.chu-shi-react/"/>
      <url>/2021/01/12/23.chu-shi-react/</url>
      
        <content type="html"><![CDATA[<h2 id="一、jQuery"><a href="#一、jQuery" class="headerlink" title="一、jQuery"></a>一、jQuery</h2><p>JS 的函数库，对原生 JS 的 API 进行了封装，只是语法简单了<strong>本质还是用选择器（$）在操作 DOM。</strong></p><p><strong>可以进行选中元素、操作 CSS、遍历 DOM、事件、JS 动画、AJAX 等一些增删改查、筛选的操作。</strong></p><blockquote><p><strong>缺点：</strong>数据和视图耦合，<strong>频繁操作 DOM（导致页面频繁重绘）</strong>，影响页面性能。</p></blockquote><h2 id="二、Vue"><a href="#二、Vue" class="headerlink" title="二、Vue"></a>二、Vue</h2><h4 id="2-2-1-特点"><a href="#2-2-1-特点" class="headerlink" title="2.2.1 特点"></a>2.2.1 特点</h4><p>渐进式 JavaScript 框架，易上手，包含大量插件（全家桶）。</p><p><strong>Vue</strong> 基于 <strong>MVVM</strong> 模式，<strong>将数据层和视图层完全解耦分离</strong>（开放封闭原则），以数据驱动视图，只关心数据，DOM操作被封装。</p><p>React 只支持内存到界面的单向变化，Vue 支持内存和界面数据的双向交流：</p><blockquote><p>通过数据劫持结合发布者-订阅者模式，通过 Object.defineProperty() 将 data 的属性代理到 vm 上，劫持各个属性的 setter、getter，一旦数据变动（修改 data）立马发布消息给订阅者，触发相应的监听回调响应式的更新视图层。</p></blockquote><p>拓展：属性都有两个对应的方法，一个是 get 方法，一个是 set 方法，都是回调函数。</p><ul><li>get：当需要读取当前属性值时执行回调，根据相关数据计算并返回当前属性的值。</li><li>set：用来监视属性值的变化，一旦属性值改变就调用 set 更新相关属性数据。</li></ul><h4 id="2-2-2-我对-MVVM-的理解"><a href="#2-2-2-我对-MVVM-的理解" class="headerlink" title="2.2.2 我对 MVVM 的理解"></a>2.2.2 <strong>我对 MVVM 的理解</strong></h4><p>看了 Vue 的源码我发现 Vue 的 MVVM 实现<strong>包含了两个重要的技术：a. 模板解析 b. 数据绑定</strong></p><ul><li><p><strong>模板解析用来初始化组件界面，解析两个部分：大括号表达式和指令</strong></p></li><li><p><strong>数据绑定用来实现更新数据，界面就自动变化的功能，主要靠的是数据劫持</strong></p></li></ul><p><img src="2.2.2.png"></p><p><strong>分析：</strong>我们写代码的时候 Vue 底层相当于 new 了一个 MVVM，它会创建两个对象，先是创建一个 Observe，用来劫持（或者叫监视）data 中所有层次的属性，同时还为每一个属性创建了另外一种对象，叫 Dep，几个属性就对应几个 Dep。</p><p>这些准备工作完成 MVVM 会再创建一个叫 Compile 的对象，它有两个作用，最重要的是去编译模板（也就是编译大括号表达式和指令），这时会去调用一个叫 Updater 的对象来初始化页面，同时 Compile 还会为模板的每个表达式（事件指令表达式除外）创建一个 Watcher，并指定更新节点的回调函数，一旦创建了 Watcher，就会去建立 Watcher 和 Dep 之间的相互关系，将 Watcher 添加到所有对应的 Dep 中从而让 Dep 可以通过 Watcher 去调用 Updater 更新视图，将 Dep 添加到 Watcher 只是为了防止重复建立。</p><p>其实到这里初始化的整个流程就完了，它做了两件事：实现初始化显示，为更新做了准备（实现了数据劫持并创建了对应的 Watcher 和 Dep）</p><p>接下来比如我们点击了一个按钮来更新某一个属性，这会被 Observe 里面的 set 知道，set 会先去通知该属性对应的那一个 Dep，Dep 再去通知所有相关的 Watcher，由于前面初始化阶段指定了更新节点的回调函数，Watcher 就调用回调函数去找 Updater 里面的方法去更新界面。</p><h2 id="三、React"><a href="#三、React" class="headerlink" title="三、React"></a>三、React</h2><p>用于构建用户界面的 JavaScript 库，<strong>严格上只针对 MVC 的 view 层。</strong></p><h4 id="3-3-1-特点"><a href="#3-3-1-特点" class="headerlink" title="3.3.1 特点"></a>3.3.1 特点</h4><ul><li>申明式编码：不用再操作 DOM，只需要更新数据，数据更新，界面就自动变化（数据驱动视图变化）</li><li>组件化编码：将界面的每个功能模块拆分为组件进行封装，组件复用（props 传递复用）、方便维护</li><li>跨平台：可用 Node 进行服务器渲染，或使用 <a href="https://reactnative.dev/">React Native</a> 开发原生移动应用，支持客户端和服务器渲染</li><li>高效</li><li>单向数据流</li></ul><h4 id="3-3-2-React高效原因"><a href="#3-3-2-React高效原因" class="headerlink" title="3.3.2 React高效原因"></a>3.3.2 React高效原因</h4><ul><li><strong>虚拟（Virtual）DOM，不总是直接操作 DOM</strong></li><li><strong>DOM Diff 算法，最小化页面重绘</strong></li></ul><h2 id="四、尤大阐述两大框架"><a href="#四、尤大阐述两大框架" class="headerlink" title="四、尤大阐述两大框架"></a>四、尤大阐述两大框架</h2><p><strong>Vue 设计者尤雨溪亲自回答：</strong></p><p>虽然 Vue 和 React 两者在定位上有一些交集，但差异也是很明显的。</p><p><strong>Vue 使用的是 web 开发者更熟悉的模板与特性</strong>，Vue 的 API 跟传统 web 开发者熟悉的模板契合度更高，比如 Vue 的单文件组件是以模板 + JavaScript + CSS 的组合模式呈现，它跟 web 现有的 HTML、JavaScript、CSS 能够更好地配合。<strong>React 的特色在于函数式编程的理念和丰富的技术选型</strong>。Vue 比起 React 更容易被前端工程师接受，这是一个直观的感受；React 则更容易吸引在 FP 上持续走下去的开发者。</p><p>从<strong>使用习惯和思维模式</strong>上考虑，对于一个没有任何 Vue 和 React 基础的 web 开发者来说， Vue 会更友好，更符合他的思维模式。React 对于拥有函数式编程背景的开发者以及一些并不是以 web 为主要开发平台的开发人员而言，React 更容易接受。这并不意味着他们不能接受 Vue，Vue 和 React 之间的差异对他们来说就没有 web 开发者那么明显。可以说，<strong>Vue 更加注重 web 开发者的习惯</strong>。</p><p><strong>实现上，Vue 跟 React 的最大区别在于数据的 reactivity，就是反应式系统上。</strong>Vue提供反应式的数据，当数据改动时，界面就会自动更新，而 React 里面需要调用方法 SetState。我把两者分别称为 <strong>Push-based</strong> 和 <strong>Pull-based</strong>。所谓 Push-based 就是说，改动数据之后，数据本身会把这个改动推送出去，告知渲染系统自动进行渲染。在 React 里面，它是一个 Pull 的形式，用户要给系统一个明确的信号说明现在需要重新渲染了，这个系统才会重新渲染。两者并没有绝对的优劣之分，更多的也是思维模式和开发习惯的不同。</p><p>两者不是完全互斥的，比如说在 React 里面，你也可以用一些第三方的库像 MobX 实现 Push-based 的系统，同时你也可以在 Vue2.0 里面，通过一些手段，比如把数据 freeze 起来，让数据不再具有反应式特点，或者通过手动调用组件更新的方法来做一个 pull-based 系统。所以两者并没有一个绝对的界限，只是默认的倾向性不同而已。</p><blockquote><p>以上回答摘自图灵社区对尤雨溪的访谈：《以匠人的态度不断打磨完善Vue》</p></blockquote><p>感觉尤大说得很中肯，虽然有些地方暂时看不明白在说啥，但还是有种恍然大悟豁然开朗如拨云雾而见青天的赶脚。</p><h2 id="五、Flag"><a href="#五、Flag" class="headerlink" title="五、Flag"></a>五、Flag</h2><p>年后对 React 进行一个系统的学习，从文档到小 demo，初步掌握其基本语法并使用它的全家桶完成一个实战项目。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
            <tag> Vue </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 项目优化及部署</title>
      <link href="/2021/01/10/22.vue-xiang-mu-you-hua-ji-bu-shu/"/>
      <url>/2021/01/10/22.vue-xiang-mu-you-hua-ji-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、小问题解决"><a href="#一、小问题解决" class="headerlink" title="一、小问题解决"></a>一、小问题解决</h2><h3 id="1-1-问题完善"><a href="#1-1-问题完善" class="headerlink" title="1.1 问题完善"></a>1.1 问题完善</h3><p>项目如果刚开发完肯定存在一些不足之处需要完善，先处理一下 Vue CLI 脚手架的可视化面板中存在的报错和警告。</p><h3 id="1-2-NProgress-进度条"><a href="#1-2-NProgress-进度条" class="headerlink" title="1.2 NProgress 进度条"></a>1.2 NProgress 进度条</h3><p><strong>通过 NProgress 给项目添加进度条效果。</strong></p><p>安装：<code>npm install --save nprogress</code></p><p>也可以在 Vue CLI 的可视化 UI 面板的<strong>运行依赖</strong>中搜索 nprogress 下载安装</p><p>导入 nprogress 包后会得到一个全局的对象 NProgress，通过调用它的 API 实现显示隐藏：</p><pre><code>NProgress.start(); // 展示进度条NProgress.done(); // 隐藏进度条</code></pre><p><strong>这里需要基于 ajax 发起请求的 request 拦截器以及请求完毕的 response 拦截器来实现显示隐藏效果。</strong></p><p>在 main.js 中导入进度条 NProgress 包对应的 JS 和 CSS</p><pre><code>import NProgress from 'nprogress'import 'nprogress/nprogress.css'</code></pre><p>完整代码：</p><pre><code>// 导入进度条NProgress包对应的JS和CSSimport NProgress from 'nprogress'import 'nprogress/nprogress.css'// 导入axiosimport axios from 'axios'// 设置请求的根路径axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/'// 设置请求拦截器预处理请求添加token验证，为每一次API请求挂载一个Authorization请求头// 并在request拦截器中，展示进度条 NProgress.start()axios.interceptors.request.use(config =&gt; {  NProgress.start()  config.headers.Authorization = window.sessionStorage.getItem('token')  return config})// 在response拦截器中，隐藏进度条 NProgress.done()axios.interceptors.response.use(config =&gt; {  NProgress.done()  return config})// 将axios挂载到Vue的原型对象上，每一个Vue组件都能通过this访问到$http发ajax请求Vue.prototype.$http = axios</code></pre><p>此时进度条的 loading 效果就实现了！</p><p><img src="1.2.png"></p><h3 id="1-3-serve-中-ESLint-警告"><a href="#1-3-serve-中-ESLint-警告" class="headerlink" title="1.3 serve 中 ESLint 警告"></a>1.3 serve 中 ESLint 警告</h3><p>在 Vue CLI 的可视化面板的 <strong>任务 - serve -运行</strong> 后有一些 ESLint 的语法错误：</p><p><img src="1.3.png"></p><p>例如<strong>这个是 prettier 格式化工具和 ESLint 规则不符</strong>：中括号要在同一行显示找到报错的代码位置并修改到同一行即可。</p><p>也可以在根目录的 .prettierrc 文件下做下配置修改：</p><pre><code>{  "semi": false,   "singleQuote": true,  "printWidth": 200 // 自动换行所需字符数，默认80，改到200即可}</code></pre><p>下面这个报错是定义了变量没有使用，只需要找到对应变量删掉就行。</p><pre><code>“xxx” is defined but never used</code></pre><h3 id="1-4-build-命令警告"><a href="#1-4-build-命令警告" class="headerlink" title="1.4 build 命令警告"></a>1.4 build 命令警告</h3><h4 id="1-4-1-移除-console-log"><a href="#1-4-1-移除-console-log" class="headerlink" title="1.4.1 移除 console.log()"></a>1.4.1 移除 console.log()</h4><p>在 Vue CLI 的可视化面板的 <strong>任务 - build -运行</strong> 后有一些警告：</p><p><img src="1.4.1.png"></p><p>在 <strong>输出</strong> 面板查看具体警告信息：大部分是 <strong>Unexpected console statement</strong> 警告。</p><p>即<strong>生产环境打包不要出现开发环境时调试时用的 <code>console.log()</code> 语句</strong>。</p><p>需要对自己的项目配置一个 babel 的插件，实现不同开发环境下的 <code>console.log()</code> 语句的显示移除。</p><p>（1）在 Vue CLI 的可视化面板的<strong>开发依赖</strong>中搜索安装：<strong>babel-plugin-transform-remove-console</strong></p><p>（2）<code>npm install babel-plugin-transform-remove-console --save-dev</code></p><p><strong>引入：</strong></p><p>在项目根目录的 <strong>babel.config.js</strong> 文件的 <strong>plugins</strong> 中新增节点：</p><pre><code>'transform-remove-console'</code></pre><p>但是这种方式存在问题，<strong>babel.config.js</strong> 文件是全局共享的，不管是项目开发阶段还是发布阶段都会生效。</p><h4 id="1-4-2-解决方案"><a href="#1-4-2-解决方案" class="headerlink" title="1.4.2 解决方案"></a>1.4.2 解决方案</h4><p>思路：可以在 <strong>babel.config.js</strong> 文件的 <strong>module.exports</strong> 前定义一个常量数组存放发布阶段需要用到的一些插件。</p><p>然后判断当前的开发处于哪种阶段，如果是发布阶段就向数组中 <strong>push</strong> 对应的插件名称即可。</p><p>完整代码：</p><pre><code>// 项目发布阶段需要用到的 babel 插件const prodPlugins = []// 判断当前的开发阶段if(process.env.NODE_ENV === 'production') {  prodPlugins.push('transform-remove-console')}module.exports = {  'presets': [    '@vue/app'  ],  'plugins': [    [      'component',      {        'libraryName': 'element-ui',        'styleLibraryName': 'theme-chalk'      }    ],    // 发布产品时候的插件数组    ...prodPlugins,    '@babel/plugin-syntax-dynamic-import'  ]}</code></pre><p>这样就实现了只在项目发布阶段移除所有 <code>console</code> ！</p><h2 id="二、项目优化"><a href="#二、项目优化" class="headerlink" title="二、项目优化"></a>二、项目优化</h2><h3 id="2-1-项目优化策略"><a href="#2-1-项目优化策略" class="headerlink" title="2.1 项目优化策略"></a>2.1 项目优化策略</h3><ol><li>生成打包报告 （根据报告发现项目中存在的问题并进行解决）</li><li>第三方库启用 CDN （提高页面加载效率）</li><li>Element-UI 组件按需加载 </li><li>路由懒加载</li><li>首页内容定制</li></ol><h3 id="2-2-生成打包报告"><a href="#2-2-生成打包报告" class="headerlink" title="2.2 生成打包报告"></a>2.2 生成打包报告</h3><p>打包时，为了直观地发现项目中存在的问题，可以在打包时生成报告。</p><p>生成报告的方式有两种：</p><p> ① 通过命令行参数的形式生成报告</p><p>通过 vue-cli 的命令选项可以生成打包报告 </p><p>–report 选项可以生成 report.html 以帮助分析包内容 vue-cli-service build –report</p><p>② 通过可视化的UI面板直接查看报告（推荐）</p><p>在可视化的UI面板中，通过控制台和分析面板，可以方便地看到项目中所存在的问题。</p><p>在可视化的UI面板的 <strong>任务 - build - 运行</strong> 后会生成一些对应的报告信息，在控制台和分析面板查看报告：</p><p><img src="2.2.1.png"></p><p><img src="2.2.2.png"></p><p><img src="2.2.3.png"></p><p>由于我的已经优化处理过了看不出来效果，之前将体积大的文件和依赖性压缩处理了…</p><h3 id="2-3-修改-Webpack-默认配置"><a href="#2-3-修改-Webpack-默认配置" class="headerlink" title="2.3 修改 Webpack 默认配置"></a>2.3 修改 Webpack 默认配置</h3><p><strong>通过 vue.config.js 修改 Webpack 的默认配置。</strong></p><p>通过 vue-cli 3.0 工具生成的项目，默认隐藏了所有 webpack 的配置项，目的是为了屏蔽项目的配置过程，让程序员把工作的重心，放到具体功能和业务逻辑的实现上。</p><p>如果程序员有修改 webpack 默认配置的需求，可以在项目根目录中，按需创建 <strong>vue.config.js</strong> 这个配置文件，从而对项目的打包发布过程做自定义的配置（具体配置参考 <a href="https://cli.vuejs.org/zh/config/#vue-config-js%EF%BC%89%E3%80%82">https://cli.vuejs.org/zh/config/#vue-config-js）。</a></p><pre><code>// vue.config.js // 这个文件中，应该导出一个包含了自定义配置选项的对象 module.exports = {     // 选项...}</code></pre><h4 id="2-3-1-为开发-发布模式指定不同的打包入口"><a href="#2-3-1-为开发-发布模式指定不同的打包入口" class="headerlink" title="2.3.1 为开发/发布模式指定不同的打包入口"></a>2.3.1 为开发/发布模式指定不同的打包入口</h4><p>默认情况下，Vue项目的开发模式与发布模式，共用同一个打包的入口文件（即 src/main.js）。为了将项目 的开发过程与发布过程分离，我们可以为两种模式，各自指定打包的入口文件，即： </p><p>① 开发模式的入口文件为 src/main-dev.js</p><p>② 发布模式的入口文件为 src/main-prod.js</p><h4 id="2-3-2-configureWebpack-和-chainWebpack"><a href="#2-3-2-configureWebpack-和-chainWebpack" class="headerlink" title="2.3.2 configureWebpack 和 chainWebpack"></a>2.3.2 configureWebpack 和 chainWebpack</h4><p>在 vue.config.js 导出的配置对象中，新增 configureWebpack 或 chainWebpack 节点，来自定义 webpack 的打包配置。</p><p>在这里， configureWebpack 和 chainWebpack 的作用相同，唯一的区别就是它们修改 webpack 配置的方式不同： </p><p>① chainWebpack 通过链式编程的形式，来修改默认的 webpack 配置 </p><p>② configureWebpack 通过操作对象的形式，来修改默认的 webpack 配置</p><p>两者具体的使用差异，可参考如下网址：</p><p><a href="https://cli.vuejs.org/zh/guide/webpack.html#webpack-%E7%9B%B8%E5%85%B3">https://cli.vuejs.org/zh/guide/webpack.html#webpack-%E7%9B%B8%E5%85%B3</a></p><h4 id="2-3-3-chainWebpack-自定义打包入口"><a href="#2-3-3-chainWebpack-自定义打包入口" class="headerlink" title="2.3.3 chainWebpack 自定义打包入口"></a>2.3.3 chainWebpack 自定义打包入口</h4><pre><code>// vue.config.js module.exports = {  chainWebpack: config =&gt; {    // 发布模式    config.when(process.env.NODE_ENV === 'production', config =&gt; {      config        .entry('app')        .clear()        .add('./src/main-prod.js')      config.set('externals', {        vue: 'Vue',        'vue-router': 'VueRouter',        axios: 'axios',        lodash: '_',        echarts: 'echarts',        nprogress: 'NProgress',        'vue-quill-editor': 'VueQuillEditor'      })      config.plugin('html').tap(args =&gt; {        args[0].isProd = true        return args      })    })    // 开发模式    config.when(process.env.NODE_ENV === 'development', config =&gt; {      config        .entry('app')        .clear()        .add('./src/main-dev.js')      config.plugin('html').tap(args =&gt; {        args[0].isProd = false        return args      })    })  }}</code></pre><h3 id="2-4-externals-加载外部-CDN-资源"><a href="#2-4-externals-加载外部-CDN-资源" class="headerlink" title="2.4 externals 加载外部 CDN 资源"></a>2.4 externals 加载外部 CDN 资源</h3><p>默认情况下，通过 import 语法导入的第三方依赖包，最终会被打包合并到同一个文件中，从而导致打包成功 后，单文件体积过大的问题。</p><p><img src="2.4.1.png"></p><p>可以看到有一个 JS 文件有1.6m，这会导致加载速度特别慢。为了解决上述问题，可以通过 webpack 的 externals 节点，来配置并加载外部的 CDN 资源。<strong>凡是声明在externals中的第三方依赖包，都不会被打包。</strong></p><pre><code>// vue.config.js config.set('externals', {     vue: 'Vue',    'vue-router': 'VueRouter',    axios: 'axios',    lodash: '_',    echarts: 'echarts',    nprogress: 'NProgress',     'vue-quill-editor': 'VueQuillEditor'})</code></pre><p>同时，需要在 public/index.html 文件的头部，添加如下的 CDN 资源引用：</p><pre><code>&lt;!-- nprogress 的样式表文件 --&gt; &lt;link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" /&gt; &lt;!-- 富文本编辑器的样式表文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css"/&gt; &lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css"/&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css"/&gt;</code></pre><p>还需要在 public/index.html 文件的头部，添加如下的 CDN 资源引用：</p><pre><code>&lt;script src="https://cdn.staticfile.org/vue/2.5.22/vue.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.staticfile.org/vue-router/3.0.1/vue-router.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.staticfile.org/axios/0.18.0/axios.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.staticfile.org/lodash.js/4.17.11/lodash.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.staticfile.org/echarts/4.1.0/echarts.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"&gt;&lt;/script&gt; &lt;!-- 富文本编辑器的 js 文件 --&gt;&lt;script src="https://cdn.staticfile.org/quill/1.3.4/quill.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.4/dist/vue-quill-editor.js"&gt;&lt;/script&gt;</code></pre><p>此时再使用 build 打包体积就大大减小了！（从 1.6m 到 480k）</p><p><img src="2.4.2png"></p><h3 id="2-5-CDN-优化-ElementUI-打包"><a href="#2-5-CDN-优化-ElementUI-打包" class="headerlink" title="2.5 CDN 优化 ElementUI 打包"></a>2.5 CDN 优化 ElementUI 打包</h3><p>虽然在开发阶段，我们启用了 element-ui 组件的按需加载，尽可能的减少了打包的体积，但是那些被按需加载的组件，还是占用了较大的文件体积。此时，我们可以将 element-ui 中的组件，也通过 CDN 的形式来加<br>载，这样能够进一步减小打包后的文件体积。</p><p>具体操作流程如下：</p><p>① 在 main-prod.js 中，注释掉 element-ui 按需加载的代码 </p><p>② 在 index.html 的头部区域中，通过 CDN 加载 element-ui 的 js 和 css 样式</p><pre><code>&lt;!-- element-ui 的样式表文件 --&gt; &lt;link rel="stylesheet" href="https://cdn.staticfile.org/element-ui/2.8.2/themechalk/index.css" /&gt; &lt;!-- element-ui 的 js 文件 --&gt;&lt;script src="https://cdn.staticfile.org/element-ui/2.8.2/index.js"&gt;&lt;/script&gt;</code></pre><p><img src="2.5.png"></p><p>可以看到又瘦了不少。</p><h3 id="2-6-定制首页内容"><a href="#2-6-定制首页内容" class="headerlink" title="2.6 定制首页内容"></a>2.6 定制首页内容</h3><p>不同的打包环境下，首页内容可能会有所不同。我们可以通过插件的方式进行定制，插件配置如下：</p><pre><code>chainWebpack: config =&gt; {     config.when(process.env.NODE_ENV === 'production', config =&gt; {         config.plugin('html').tap(args =&gt; {             args[0].isProd = true             return args        })     })    config.when(process.env.NODE_ENV === 'development', config =&gt; {         config.plugin('html').tap(args =&gt; {             args[0].isProd = false             return args        })     })}</code></pre><p>在 public/index.html 首页中，可以根据 isProd 的值，来决定如何渲染页面结构：</p><pre><code>&lt;!– 按需渲染页面的标题 --&gt;&lt;title&gt;&lt;%= htmlWebpackPlugin.options.isProd ? '' : 'dev - ' %&gt;Title&lt;/title&gt;&lt;!– 按需加载外部的 CDN 资源 --&gt;&lt;% if(htmlWebpackPlugin.options.isProd) { %&gt;&lt;!—通过 externals 加载的外部 CDN 资源--&gt;&lt;% } %&gt;</code></pre><h3 id="2-7-路由懒加载"><a href="#2-7-路由懒加载" class="headerlink" title="2.7 路由懒加载"></a>2.7 路由懒加载</h3><p>当打包构建项目时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成 不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><p>具体需要 3 步：</p><p>① 安装 @babel/plugin-syntax-dynamic-import 包。 </p><p>② 在 babel.config.js 配置文件中声明该插件。</p><p>③ 将路由改为按需加载的形式，示例代码如下：</p><pre><code>const Foo = () =&gt; import(/* webpackChunkName: "group-foo" */ './Foo.vue') const Bar = () =&gt; import(/* webpackChunkName: "group-foo" */ './Bar.vue')const Baz = () =&gt; import(/* webpackChunkName: "group-boo" */ './Baz.vue')</code></pre><p>关于路由懒加载的详细文档，可参考如下链接：</p><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><p>完整代码：</p><pre><code>// router.jsimport Vue from 'vue'import Router from 'vue-router'// import Login from './components/Login.vue'const Login = () =&gt; import(/* webpackChunkName: "login_home_welcome" */ './components/Login.vue')// import Home from './components/Home.vue'const Home = () =&gt; import(/* webpackChunkName: "login_home_welcome" */ './components/Home.vue')// import Welcome from './components/Welcome.vue'const Welcome = () =&gt; import(/* webpackChunkName: "login_home_welcome" */ './components/Welcome.vue')// import Users from './components/user/Users.vue'const Users = () =&gt; import(/* webpackChunkName: "Users_Rights_Roles" */ './components/user/Users.vue')// import Rights from './components/power/Rights.vue'const Rights = () =&gt; import(/* webpackChunkName: "Users_Rights_Roles" */ './components/power/Rights.vue')// import Roles from './components/power/Roles.vue'const Roles = () =&gt; import(/* webpackChunkName: "Users_Rights_Roles" */ './components/power/Roles.vue')// import Cate from './components/goods/Cate.vue'const Cate = () =&gt; import(/* webpackChunkName: "Cate_Params" */ './components/goods/Cate.vue')// import Params from './components/goods/Params.vue'const Params = () =&gt; import(/* webpackChunkName: "Cate_Params" */ './components/goods/Params.vue')// import GoodsList from './components/goods/List.vue'const GoodsList = () =&gt; import(/* webpackChunkName: "GoodsList_Add" */ './components/goods/List.vue')// import Add from './components/goods/Add.vue'const Add = () =&gt; import(/* webpackChunkName: "GoodsList_Add" */ './components/goods/Add.vue')// import Order from './components/order/Order.vue'const Order = () =&gt; import(/* webpackChunkName: "Order_Report" */ './components/order/Order.vue')// import Report from './components/report/Report.vue'const Report = () =&gt; import(/* webpackChunkName: "Order_Report" */ './components/report/Report.vue')Vue.use(Router)const router = new Router({  routes: [    { path: '/', redirect: '/login' },    { path: '/login', component: Login },    {      path: '/home',      component: Home,      redirect: '/welcome',      children: [        { path: '/welcome', component: Welcome },        { path: '/users', component: Users },        { path: '/rights', component: Rights },        { path: '/roles', component: Roles },        { path: '/categories', component: Cate },        { path: '/params', component: Params },        { path: '/goods', component: GoodsList },        { path: '/goods/add', component: Add },        { path: '/orders', component: Order },        { path: '/reports', component: Report }      ]    }  ]})// 挂载路由导航守卫router.beforeEach((to, from, next) =&gt; {  // to 将要访问的路径  // from 代表从哪个路径跳转而来  // next 是一个函数，表示放行  //     next()  放行    next('/login')  强制跳转  if (to.path === '/login') return next()  // 获取token  const tokenStr = window.sessionStorage.getItem('token')  if (!tokenStr) return next('/login')  next()})export default router</code></pre><h2 id="三、项目上线"><a href="#三、项目上线" class="headerlink" title="三、项目上线"></a>三、项目上线</h2><h3 id="3-1-项目上线相关配置"><a href="#3-1-项目上线相关配置" class="headerlink" title="3.1 项目上线相关配置"></a>3.1 项目上线相关配置</h3><ol><li>通过 node 创建 web 服务器。 </li><li>开启 gzip 配置。 </li><li>配置 https 服务。</li><li>使用 pm2 管理应用。</li></ol><h3 id="3-2-通过-node-创建-web-服务器"><a href="#3-2-通过-node-创建-web-服务器" class="headerlink" title="3.2 通过 node 创建 web 服务器"></a>3.2 通过 node 创建 web 服务器</h3><p>创建 node 项目，并安装 express，通过 express 快速创建 web 服务器，将 vue 打包生成的 dist 文件夹， 托管为静态资源即可，关键代码如下：</p><pre><code>const express = require('express')// 创建 web 服务器 const app = express()// 托管静态资源 app.use(express.static('./dist'))// 启动 web 服务器 app.listen(80, () =&gt; {     console.log('web server running at http://127.0.0.1')})</code></pre><p>先在项目文件夹下新建文件如 <strong>“xxx_server”</strong>，VSCode 打开文件夹终端运行：</p><p><code>npm init -y</code> ：初始化一个包管理配置文件</p><p><code>npm i express -S</code>：安装 express</p><p>将之前项目打包生成的 dist 文件夹粘贴到新建文件夹 <strong>“xxx_server”</strong> 下</p><p>回到 VSCode 新建 app.js 文件</p><p>导入express：</p><p><code>const express = require('express')</code></p><p>调用 express 得到真正的服务器：</p><p><code>const app = express()</code></p><p>注册 static 中间件把目录托管为静态资源：</p><p><code>app.use(express.static('./dist'))</code></p><p>启动服务器：</p><pre><code>app.listen(80, () =&gt; {  console.log('server running at http://127.0.0.1')})</code></pre><h3 id="3-3-开启-gzip"><a href="#3-3-开启-gzip" class="headerlink" title="3.3 开启 gzip"></a>3.3 开启 gzip</h3><p>使用 gzip 可以减小文件体积，使传输速度更快。</p><p>通过服务器端使用 Express 做 gzip 压缩。其配置如下：</p><pre><code>// 安装相应包 npm install compression -S // 导入包const compression = require('compression'); // 启用中间件app.use(compression());</code></pre><p>这是减肥前，文件有多大体积差不多就会在网络中传输多大体积：</p><p><img src="3.3.1.png"></p><p><strong>优化：</strong>在之前的新建文件夹 <strong>“xxx_server”</strong> 终端下下载包：</p><p><code>npm i compression -S</code></p><p><strong>导入：</strong></p><p><code>const compression = require('compression')</code></p><p><strong>注册：</strong></p><p><code>app.use(compression())</code></p><blockquote><p>注意：这行注册代码得放在 <code>app.use(express.static('./dist'))</code> 之前，即写到静态资源托管之前</p></blockquote><p>重新运行服务器，可以看到减肥大成功！压缩后只传输了 24.6k，文件打开速度更快！又双叒叕瘦了！</p><p><img src="3.3.2.png"></p><h3 id="3-4-配置-HTTPS-服务"><a href="#3-4-配置-HTTPS-服务" class="headerlink" title="3.4 配置 HTTPS 服务"></a>3.4 配置 HTTPS 服务</h3><p>为什么要启用 HTTPS 服务？</p><p>①传统的 HTTP 协议传输的数据都是明文，不安全</p><p>②采用 HTTPS 协议对传输的数据进行了加密处理，可以防止数据被中间人窃取，使用更安全</p><p><strong>申请 SSL 证书</strong>（<a href="https://freessl.org)/">https://freessl.org）</a></p><p>① 进入 <a href="https://freessl.cn/">https://freessl.cn/</a> 官网，输入要申请的域名并选择品牌。 </p><p>② 输入自己的邮箱并选择相关选项。 </p><p>③ 验证 DNS（在域名管理后台添加 TXT 记录）。</p><p>④ 验证通过之后，下载 SSL 证书（ full_chain.pem 公钥；private.key 私钥）。</p><p><strong>在后台项目中导入证书</strong></p><pre><code>const https = require('https'); const fs = require('fs'); const options = {     cert: fs.readFileSync('./full_chain.pem'),     key: fs.readFileSync('./private.key')}https.createServer(options, app).listen(443);</code></pre><p>完整代码：</p><pre><code>const express = require('express')const compression = require('compression')const https = require('https')const fs = require('fs')const app = express()const options = {  cert: fs.readFileSync('./full_chain.pem'),  key: fs.readFileSync('./private.key')}// 一定要把这一行代码，写到静态资源托管之前app.use(compression())app.use(express.static('./dist'))// app.listen(80, () =&gt; {//   console.log('server running at http://127.0.0.1')// })https.createServer(options, app).listen(443)</code></pre><h3 id="3-5-使用-pm2-管理应用"><a href="#3-5-使用-pm2-管理应用" class="headerlink" title="3.5 使用 pm2 管理应用"></a>3.5 使用 pm2 管理应用</h3><p>在后台文件夹 Shift + 右键 打开 Powershell 窗口，输入固定指令：本地运行 Web 服务器：<code>node .\app.js</code></p><p>此时一旦关闭 Powershell 服务器就关了，此时就需要借助 pm2：</p><p>① 在服务器中安装 pm2：npm i pm2 -g </p><p>② 启动项目：pm2 start 脚本 –name 自定义名称 </p><p>③ 查看运行项目：pm2 ls </p><p>④ 重启项目：pm2 restart 自定义名称 </p><p>⑤ 停止项目：pm2 stop 自定义名称</p><p>⑥ 删除项目：pm2 delete 自定义名称</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECharts 图表渲染</title>
      <link href="/2021/01/08/21.echarts/"/>
      <url>/2021/01/08/21.echarts/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装引入"><a href="#一、安装引入" class="headerlink" title="一、安装引入"></a>一、安装引入</h2><h3 id="1-1-安装方式"><a href="#1-1-安装方式" class="headerlink" title="1.1 安装方式"></a>1.1 安装方式</h3><p>（1）<strong>vue ui</strong> 可视化工具安装：进入依赖项面板 - 点击安装依赖 - 在运行依赖中搜索插件 <strong>echarts</strong> - 点击安装 echarts 。（推荐）</p><p>（2）<strong>npm</strong> 安装：<code>npm install echarts --save</code>（推荐）</p><p>（3）通过 <a href="https://www.jsdelivr.com/package/npm/echarts">jsDelivr</a> 等 CDN 引入。（推荐）</p><p>（4）在 ECharts 的 <a href="https://github.com/apache/incubator-echarts/releases">GitHub</a> 获取。</p><p>（5）从 <a href="https://echarts.apache.org/zh/download.html">Apache ECharts (incubating) 官网下载界面</a> 获取官方源码包后构建。</p><h3 id="1-2-引入项目"><a href="#1-2-引入项目" class="headerlink" title="1.2 引入项目"></a>1.2 引入项目</h3><p><strong>导入 ECharts：</strong></p><p>在文件的 <code>script</code> 节点导入 ECharts：</p><p><code>import echarts from 'echarts'</code></p><p>这里会<strong>报错：”export ‘default’ (imported as ‘echarts’) was not found in ‘echarts’</strong></p><p>摸了下头皮发现是版本太新导致的，我的是 5.0.0 版本，需要这样来引入：</p><p><code>import * as echarts from 'echarts'</code></p><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="2-1-页面放置图表区域"><a href="#2-1-页面放置图表区域" class="headerlink" title="2.1 页面放置图表区域"></a>2.1 页面放置图表区域</h3><pre><code>&lt;!-- 卡片视图区域 --&gt;&lt;el-card&gt;  &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 Dom --&gt;  &lt;div id="main" style="width: 750px;height:400px;"&gt;&lt;/div&gt;&lt;/el-card&gt;</code></pre><h3 id="2-2-渲染图表"><a href="#2-2-渲染图表" class="headerlink" title="2.2 渲染图表"></a>2.2 渲染图表</h3><p>首先调用 echarts 包的 init 函数将上面的 div 初始化为 echarts 实例，值得注意的是：</p><p><strong>初始化图表必须在页面的 dom 结构被渲染完毕后进行</strong>，在 <strong>mounted</strong> 生命周期钩子中初始化：</p><pre><code>mounted() {  // 3. 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('main'))}    </code></pre><h3 id="2-3-准备数据和配置项"><a href="#2-3-准备数据和配置项" class="headerlink" title="2.3 准备数据和配置项"></a>2.3 准备数据和配置项</h3><pre><code>// 指定图表的配置项和数据var option = {    title: {        text: 'ECharts 入门示例'    },    tooltip: {},    legend: {        data:['销量']    },    xAxis: {        data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]    },    yAxis: {},    series: [{        name: '销量',        type: 'bar',        data: [5, 20, 36, 10, 10, 20]    }]};</code></pre><h3 id="2-4-展示数据"><a href="#2-4-展示数据" class="headerlink" title="2.4 展示数据"></a>2.4 展示数据</h3><p>将 option 中的数据设置到 myChart 中，使用刚指定的配置项和数据显示图表：</p><pre><code>// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);</code></pre><p>此时网页中图表就渲染出来了！</p><p><img src="2.4.png"></p><h2 id="三、合并服务器数据"><a href="#三、合并服务器数据" class="headerlink" title="三、合并服务器数据"></a>三、合并服务器数据</h2><h3 id="3-1-调用接口"><a href="#3-1-调用接口" class="headerlink" title="3.1 调用接口"></a>3.1 调用接口</h3><p>接下来需要发 ajax 请求获取基于时间统计的折线图，调用接口成功服务器会返回一个折线图数据。</p><p>但该数据不能直接交给图表进行渲染，需要先<strong>将数据先和 options 对象合并成一个新对象后交给图表展示</strong>。</p><pre><code>// 此时页面上的元素已经被渲染完毕了async mounted() {  // 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('main'))  const { data: res } = await this.$http.get('reports/type/1')  if (res.meta.status !== 200) {    return this.$message.error('获取折线图数据失败！')  }  // 展示数据  myChart.setOption(res.data)}</code></pre><p>此时页面中多了一个折线图的图形：</p><p><img src="3.1.png"></p><h3 id="3-2-合并-options"><a href="#3-2-合并-options" class="headerlink" title="3.2 合并 options"></a>3.2 合并 options</h3><p>此时图表尚不完整，需要和官方文档提供的 options 选项做下合并。</p><p>将 options 放到 data 中：</p><pre><code>data() {    return {      // 需要合并的数据      options: {        title: {          text: '用户来源'        },        tooltip: {          trigger: 'axis',          axisPointer: {            type: 'cross',            label: {              backgroundColor: '#E9EEF3'            }          }        },        grid: {          left: '3%',          right: '4%',          bottom: '3%',          containLabel: true        },        xAxis: [          {            boundaryGap: false          }        ],        yAxis: [          {            type: 'value'          }        ]      }    }}</code></pre><h3 id="3-3-Lodash-合并对象"><a href="#3-3-Lodash-合并对象" class="headerlink" title="3.3 Lodash 合并对象"></a>3.3 Lodash 合并对象</h3><p><em>Lodash</em> 是一个一致性、模块化、高性能的 JavaScript 实用工具库，之前使用它进行过深拷贝，这次用它合并对象。</p><p>官方文档：<a href="https://lodash.com/">https://lodash.com/</a></p><p>导入 lodash</p><pre><code>import _ from 'lodash'</code></pre><p>调用 lodash 提供的 merge 函数合并对象：</p><pre><code>// 准备数据和配置项const result = _.merge(res.data, this.options)// 将合并的新对象交给图表去展示myChart.setOption(result)</code></pre><p>完整代码：</p><pre><code>&lt;script&gt;// 1. 导入 echartsimport * as echarts from 'echarts'import _ from 'lodash'export default {  data() {    return {      // 需要合并的数据      options: {        title: {          text: '用户来源'        },        tooltip: {          trigger: 'axis',          axisPointer: {            type: 'cross',            label: {              backgroundColor: '#E9EEF3'            }          }        },        grid: {          left: '3%',          right: '4%',          bottom: '3%',          containLabel: true        },        xAxis: [          {            boundaryGap: false          }        ],        yAxis: [          {            type: 'value'          }        ]      }    }  },  // 此时，页面上的元素，已经被渲染完毕了！  async mounted() {    // 3. 基于准备好的dom，初始化echarts实例    var myChart = echarts.init(document.getElementById('main'))    const { data: res } = await this.$http.get('reports/type/1')    if (res.meta.status !== 200) {      return this.$message.error('获取折线图数据失败！')    }    // 4. 准备数据和配置项    const result = _.merge(res.data, this.options)    // 5. 展示数据    myChart.setOption(result)  },}&lt;/script&gt;</code></pre><p>此时完整的图表就展示出来了！</p><p><img src="3.3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ECharts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sass 基础学习</title>
      <link href="/2021/01/06/20.sass/"/>
      <url>/2021/01/06/20.sass/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装和使用"><a href="#一、安装和使用" class="headerlink" title="一、安装和使用"></a>一、安装和使用</h2><p><a href="http://sass-lang.com/">Sass</a>是一种 CSS 的开发工具，提供了许多便利写法，大大节省了设计者的时间，使得 CSS 的开发，变得简单和可维护。</p><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p>SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先<a href="http://www.ruby-lang.org/zh_cn/downloads/">安装Ruby</a>，然后再安装SASS。</p><p>假定你已经安装好了Ruby，接着在命令行输入下面的命令：</p><blockquote><p>gem install sass</p></blockquote><p>然后，就可以使用了。</p><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><p>SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。</p><p>下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。）</p><blockquote><p>sass test.scss</p></blockquote><p>如果要将显示结果保存成文件，后面再跟一个.css文件名。</p><blockquote><p>sass test.scss test.css</p></blockquote><p>SASS提供四个<a href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#output_style">编译风格</a>的选项：</p><blockquote><ul><li><p>nested：嵌套缩进的css代码，它是默认值。</p></li><li><p>expanded：没有缩进的、扩展的css代码。</p></li><li><p>compact：简洁格式的css代码。</p></li><li><p>compressed：压缩后的css代码。</p></li></ul></blockquote><p>生产环境当中，一般使用最后一个选项。</p><blockquote><p>sass –style compressed test.sass test.css</p></blockquote><p>你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。</p><blockquote><p>// watch a file</p><p>sass –watch input.scss:output.css</p><p>// watch a directory</p><p>sass –watch app/sass:public/stylesheets</p></blockquote><p>SASS的官方网站，提供了一个<a href="http://sass-lang.com/try.html">在线转换器</a>。你可以在那里，试运行下面的各种例子。</p><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><h3 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h3><p>SASS允许使用变量，所有变量以$开头。</p><blockquote><p>$blue : #1875e7;　</p><p>div {<br>    color : $blue;<br>}</p></blockquote><p>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</p><blockquote><p>$side : left;</p><p>.rounded {<br>    border-#{$side}-radius: 5px;<br>}</p></blockquote><h3 id="2-2-计算功能"><a href="#2-2-计算功能" class="headerlink" title="2.2 计算功能"></a>2.2 计算功能</h3><p>SASS允许在代码中使用算式：</p><blockquote><p>body {<br>    margin: (14px/2);<br>　top: 50px + 100px;<br>　right: $var * 10%;<br>}</p></blockquote><h3 id="2-3-嵌套"><a href="#2-3-嵌套" class="headerlink" title="2.3 嵌套"></a>2.3 嵌套</h3><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p><blockquote><p>div h1 {<br>    color : red;<br>}</p></blockquote><p>可以写成：</p><blockquote><p>div {<br>　hi {<br>　　color:red;<br>　}<br>}</p></blockquote><p>属性也可以嵌套，比如border-color属性，可以写成：</p><blockquote><p>p {<br>　border: {<br>　　　color: red;<br>　}<br>}</p></blockquote><p>注意，border后面必须加上冒号。</p><p>在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成：</p><blockquote><p>a {<br>    &amp;:hover { color: #ffb3ff; }<br>}</p></blockquote><h3 id="2-4-注释"><a href="#2-4-注释" class="headerlink" title="2.4 注释"></a>2.4 注释</h3><p>SASS有两种注释风格。</p><p>标准的CSS注释 /* comment */ ，会保留到编译后的文件。</p><p>单行注释 // comment，只保留在SASS源文件中，编译后被省略。</p><p>在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可用于声明版权信息。</p><blockquote><p>/*!<br>    重要注释！<br>*/</p></blockquote><h2 id="三、代码的重用"><a href="#三、代码的重用" class="headerlink" title="三、代码的重用"></a>三、代码的重用</h2><h3 id="3-1-继承"><a href="#3-1-继承" class="headerlink" title="3.1 继承"></a>3.1 继承</h3><p>SASS允许一个选择器继承另一个选择器。比如，现有class1：</p><blockquote><p>.class1 {<br>    border: 1px solid #ddd;<br>}</p></blockquote><p>class2要继承class1，就要使用@extend命令：</p><blockquote><p>.class2 {<br>　@extend .class1;<br>　font-size:120%;<br>}</p></blockquote><h3 id="3-2-Mixin"><a href="#3-2-Mixin" class="headerlink" title="3.2 Mixin"></a>3.2 Mixin</h3><p>Mixin有点像C语言的宏（macro），是可以重用的代码块。</p><p>使用@mixin命令，定义一个代码块。</p><blockquote><p>@mixin left {<br>　float: left;<br>　margin-left: 10px;<br>}</p></blockquote><p>使用@include命令，调用这个mixin。</p><blockquote><p>div {<br>　@include left;<br>}</p></blockquote><p>mixin的强大之处，在于可以指定参数和缺省值。</p><blockquote><p>@mixin left($value: 10px) {<br>　float: left;<br>　margin-right: $value;<br>}</p></blockquote><p>使用的时候，根据需要加入参数：</p><blockquote><p>div {<br>    @include left(20px);<br>}</p></blockquote><p>下面是一个mixin的实例，用来生成浏览器前缀。</p><blockquote><p>@mixin rounded($vert, $horz, $radius: 10px) {<br>　border-#{$vert}-#{$horz}-radius: $radius;<br>　-moz-border-radius-#{$vert}#{$horz}: $radius;<br>　-webkit-border-#{$vert}-#{$horz}-radius: $radius;<br>}</p></blockquote><p>使用的时候，可以像下面这样调用：</p><blockquote><p>#navbar li { @include rounded(top, left); }</p><p>#footer { @include rounded(top, left, 5px); }</p></blockquote><h3 id="3-3-颜色函数"><a href="#3-3-颜色函数" class="headerlink" title="3.3 颜色函数"></a>3.3 颜色函数</h3><p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p><blockquote><p>lighten(#cc3, 10%) // #d6d65c<br>darken(#cc3, 10%) // #a3a329<br>grayscale(#cc3) // #808080<br>complement(#cc3) // #33c</p></blockquote><h3 id="3-4-插入文件"><a href="#3-4-插入文件" class="headerlink" title="3.4 插入文件"></a>3.4 插入文件</h3><p>@import命令，用来插入外部文件。</p><blockquote><p>@import “path/filename.scss”;</p></blockquote><p>如果插入的是.css文件，则等同于css的import命令。</p><blockquote><p>@import “foo.css”;</p></blockquote><p>四、高级用法</p><h3 id="4-1-条件语句"><a href="#4-1-条件语句" class="headerlink" title="4.1 条件语句"></a>4.1 条件语句</h3><p>@if可以用来判断：</p><blockquote><p>p {<br>　@if 1 + 1 == 2 { border: 1px solid; }<br>　@if 5 &lt; 3 { border: 2px dotted; }<br>}</p></blockquote><p>配套的还有@else命令：</p><blockquote><p>@if lightness($color) &gt; 30% {<br>　background-color: #000;<br>} @else {<br>　background-color: #fff;<br>}</p></blockquote><h3 id="4-2-循环语句"><a href="#4-2-循环语句" class="headerlink" title="4.2 循环语句"></a>4.2 循环语句</h3><p>支持for循环：</p><blockquote><p>@for $i from 1 to 10 {<br>　.border-#{$i} {<br>　　border: #{$i}px solid blue;<br>　}<br>}</p></blockquote><p>也支持while循环：</p><blockquote><p>$i: 6;</p><p>@while $i &gt; 0 {<br>　.item-#{$i} { width: 2em * $i; }<br>　$i: $i - 2;<br>}</p></blockquote><p>each命令，作用与for类似：</p><blockquote><p>@each $member in a, b, c, d {<br>　.#{$member} {<br>　　　background-image: url(“/image/#{$member}.jpg”);<br>　}<br>}</p></blockquote><h3 id="4-3-自定义函数"><a href="#4-3-自定义函数" class="headerlink" title="4.3 自定义函数"></a>4.3 自定义函数</h3><p>允许编写自己的函数。</p><blockquote><p>@function double($n) {<br>　@return $n * 2;<br>}</p><p>#sidebar {<br>　width: double(5px);<br>}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sass </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEO 站点优化</title>
      <link href="/2021/01/04/19.seo/"/>
      <url>/2021/01/04/19.seo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、百度收录"><a href="#一、百度收录" class="headerlink" title="一、百度收录"></a>一、百度收录</h2><blockquote><p>在这之前，<strong>需要注意：</strong></p><p><code>GitHub</code>是不允许百度的<code>Spider</code>（蜘蛛）爬取<code>GitHub</code>上的内容的，所以任何部署在GitHub上的静态博客都是不能百度爬取到的！</p></blockquote><h3 id="1-1-提交站点"><a href="#1-1-提交站点" class="headerlink" title="1.1 提交站点"></a>1.1 提交站点</h3><p>刚建完站在百度上是不可能搜索到我们的网站的，我们可以先试一下：在百度上搜索 <code>site:&lt;你的域名&gt;</code>，一般是搜不到的，然后点击 <code>提交网址</code> 来先将自己的网站提交给百度。</p><p><img src="1.1.png"></p><h3 id="1-2-添加站点"><a href="#1-2-添加站点" class="headerlink" title="1.2 添加站点"></a>1.2 添加站点</h3><p>登录<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>， 只要是百度旗下的账号就可以， 登录成功之后在站点管理中点击<a href="https://ziyuan.baidu.com/site/siteadd">添加网站</a>，输入域名，三步走。</p><p><img src="1.2.png"></p><p>第三步验证网站的时候， 验证网站所有权的方式有三种：</p><ul><li>文件验证</li><li><code>HTML</code>标签验证</li><li><code>CNAME</code>解析验证<strong>（推荐使用）</strong></li></ul><p>同理，百度的spider是爬取不到GitHub的内容的，所以<code>HTML标签验证</code>方式也是不太可取的。</p><p><img src="1.3.png"></p><h3 id="1-3-推送资源"><a href="#1-3-推送资源" class="headerlink" title="1.3 推送资源"></a>1.3 推送资源</h3><p>经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。</p><p>还是在百度资源搜索平台，找到数据引入-&gt;链接提交，可以看到向百度推送自己的内容有两个方式：</p><ol><li><p>自动提交</p><p>（分三种）</p><ul><li>主动推送</li><li>自动推送</li><li>sitemap（站点地图）</li></ul></li><li><p>手动提交</p><ul><li>即手动地将链接一次性提交给百度</li></ul></li></ol><p>一般自动提交比手动提交效果好一点，自动提交又从效率上来说：</p><p><strong>主动推送 &gt; 自动推送 &gt; sitemap</strong></p><p><strong>自动提交的三种方式</strong>：</p><ol><li><code>主动推送</code>：最为快速的提交方式。将站点当天新产出链接通过此方式推送给百度，以保证新链接可以及时被百度收录。</li><li><code>自动推送</code>：最为便捷的提交方式。将自动推送的JS代码部署在站点的每一个页面源代码中，当部署代码的页面在每次被浏览时，链接就会被自动推送给百度。可以与主动推送配合使用。</li><li><code>sitemap</code>：您可以定期将网站链接放到<code>sitemap文件</code>中，然后将<code>sitemap文件</code>提交给百度。百度会周期性的抓取检查您提交的<code>sitemap</code>，对其中的链接进行处理，但收录速度慢于主动推送。</li></ol><h4 id="1-3-1-sitemap推送"><a href="#1-3-1-sitemap推送" class="headerlink" title="1.3.1 sitemap推送"></a>1.3.1 sitemap推送</h4><p><strong>安装sitemap插件</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-sitemap --save <span class="token function">npm</span> <span class="token function">install</span> hexo-generator-baidu-sitemap --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个插件是用来生成 <code>Sitemap文件</code> 的插件，而 <code>Sitemap</code> 是用来告知搜索引擎我们的网站上有哪些可供抓取的网页的。</p><p><strong>注意一点：</strong><br><strong>hexo配置文件中的url一定要改成你的域名，这两个插件是根据你的url生成站点地图的。</strong></p><p>安装后直接执行<code>hexo cl&amp;&amp;hexo g</code>命令，然后就会在网站根目录生成<code>sitemap.xml</code>文件和<code>baidusitemap.xml文件</code>，其中<code>sitemap.xml</code>文件是搜索引擎通用的文件，<code>baidusitemap.xml</code>是百度专用的<code>sitemap</code>文件。</p><p>有<code>sitemap文件</code>之后，再将生成的<code>sitemap文件</code>提交给百度或者其他搜索引擎</p><p>百度方式：在自动提交的sitemap那里填写自己<code>sitemap文件</code>的URL地址即可</p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//你的域名/baidusitemap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交后会有状态提示等待，这里需要注意<strong>严格区分http和https：</strong></p><blockquote><p>http和https是不一样的，刚添加的站点是HTTP协议的，如果你网站开启了 <code>强制https</code>，是会报301重定向错误的，也就是百度不能抓取到你的sitemap</p><p>如果想用https，可以在<code>数据监控</code>-&gt;<code>HTTPS认证</code>进行认证</p><p>这个认证有时会很慢，可以在你的站点只留一个首页的<code>简单HTML</code>，然后再去百度认证，这样应该会快一点。</p></blockquote><p>如果是其他的搜索引擎，一般是在填写sitemap的地方，填写以下内容即可：</p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//你的域名/sitemap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-2-自动推送"><a href="#1-3-2-自动推送" class="headerlink" title="1.3.2 自动推送"></a>1.3.2 自动推送</h4><p>只要每个需要被百度爬取的HTML页面中加入一段JS代码即可：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> bp <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> curProtocol <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curProtocol <span class="token operator">===</span> <span class="token string">'https'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        bp<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'https://zz.bdstatic.com/linksubmit/push.js'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        bp<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://push.zhanzhang.baidu.com/push.js'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> s <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我所使用的matery主题可以自动给每个页面加上这段代码，只需在主题配置文件中配置：</p><pre class="line-numbers language-yml"><code class="language-yml"># 百度搜索资源平台提交链接baiduPush: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其他主题一般都有这个功能的实现，如果没有的话，想办法在每个页面加入以上JS代码即可，原理是一样。</p><h4 id="1-3-3-主动推送"><a href="#1-3-3-主动推送" class="headerlink" title="1.3.3 主动推送"></a>1.3.3 主动推送</h4><p>安装主动推送插件：<a href="https://github.com/huiwang/hexo-baidu-url-submit">hexo-baidu-url-submit</a></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-baidu-url-submit --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后打开<code>hexo配置文件</code>，在末尾加入以下配置：</p><pre class="line-numbers language-yml"><code class="language-yml"># hexo-baidu-url-submit  百度主动推送baidu_url_submit:  count: 80 # 提交最新的一个链接  host: adaichan.com # 在百度站长平台中注册的域名  token: xxxxxxx # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>密匙的获取是在百度的自动提交的主动推送那里。</p><p><img src="1.3.3.png"></p><p>再加入新的<code>deploy</code>：</p><pre class="line-numbers language-yml"><code class="language-yml">deploy:- type: baidu_url_submitter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样每次执行 <code>hexo d</code> 的时候，新的链接就会被推送了。<br>推送成功时,会有<code>deploy done!</code>终端提示。</p><p>各种不同的推送反馈字段说明<a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title12">点我</a>查看，一般来说，推送失败基本都是地址不相符造成的，我们只需对比<code>baidu_url_submit</code>在<code>public</code>中生成的<code>baidu_urls.txt</code>的地址,与自己填写在<code>host</code>字段中的地址对比看是否一样即可。</p><h2 id="二、谷歌收录"><a href="#二、谷歌收录" class="headerlink" title="二、谷歌收录"></a>二、谷歌收录</h2><p>相比于百度，google 的效率实在不能更快，貌似一天左右站点就被收录了，其实方法是和百度是一样的。</p><h3 id="2-1-具体步骤"><a href="#2-1-具体步骤" class="headerlink" title="2.1 具体步骤"></a>2.1 具体步骤</h3><ul><li>首先登录<a href="https://www.google.com/webmasters/">谷歌站长平台</a>，添加好自己的域名</li><li><code>DNS验证</code>（就是验证下网站是不是你的）就是域名解析那里添加一条TXT解析记录</li><li>然后点击验证即可</li><li>进入谷歌的<a href="https://search.google.com/search-console/">Search Console</a>，添加自己的<code>sitemap</code>地址</li><li>接下来，等就完事嘞</li></ul><h3 id="2-2-提交-robots-txt"><a href="#2-2-提交-robots-txt" class="headerlink" title="2.2 提交 robots.txt"></a>2.2 提交 robots.txt</h3><p><strong>robots.txt是干嘛的？</strong></p><p><code>robots.txt</code> 是一种存放于网站根目录下的 <code>ASCII</code> 编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。<br><code>robots.txt</code> 要放在 <code>Hexo根目录</code> 下的 <code>source</code> 文件夹中。</p><p>每个人站点目录可能不太一样，可以参考下我的 <code>robots.txt</code> 文件，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">User-agent</span><span class="token punctuation">:</span> *<span class="token key atrule">Allow</span><span class="token punctuation">:</span> /<span class="token key atrule">Allow</span><span class="token punctuation">:</span> /posts/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /about/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /archives/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /js/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /css/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /contact/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /fonts/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /friends/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /libs/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /medias/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /page/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /tags/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /categories/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多关于 <code>robots.txt</code> 的写法参见 <a href="https://blog.csdn.net/fanghua_vip/article/details/79535639">https://blog.csdn.net/fanghua_vip/article/details/79535639</a></p><p>编写完以上内容再重新部署一下，然后到百度资源平台的<code>数据监控</code>-&gt;<code>Robots</code>点击<code>检测并更新</code> 看能不能检测到。<br>同样注意：刚添加的站点没有进行 <code>HTTPS认证</code>，直接检测有可能会报301错误。</p><h3 id="2-3-配置-Nofollow"><a href="#2-3-配置-Nofollow" class="headerlink" title="2.3 配置 Nofollow"></a>2.3 配置 Nofollow</h3><ul><li>nofollow 是HTML页面中 <code>a标签</code> 的 属性值。</li><li>这个属性的作用是：告诉搜索引擎的爬虫不要追踪该链接，为了对抗博客垃圾留言信息</li></ul><h2 id="三、URL-优化"><a href="#三、URL-优化" class="headerlink" title="三、URL 优化"></a>三、URL 优化</h2><p>一般来说，SEO搜索引擎优化认为，网站的最佳结构是 <strong>用户从首页点击三次就可以到达任何一个页面</strong>，但是我们使用<code>Hexo</code>编译的站点结构的<code>URL</code>是：<code>域名/年/月/日/文章标题</code>四层的结构，这样的<code>URL</code>结构很不利于<code>SEO</code>，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章的<code>URL</code></p><h3 id="3-1-方案一"><a href="#3-1-方案一" class="headerlink" title="3.1 方案一"></a>3.1 方案一</h3><p>直接改成<code>域名/文章标题</code>的形式，在<code>Hexo配置文件</code>中修改<code>permalink</code>如下：</p><pre class="line-numbers language-yml"><code class="language-yml"># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://adaichan.comroot: /permalink: :title.htmlpermalink_defaults:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这个方式有个不好的地方：</strong></p><p>直接以<code>文章的标题</code>作为URL，而我们所写的文章的标题一般都是中文，但是URL只能用字母数字和标点符号表示，所以中文的URL只能被转义成一堆符号，而且还特别长。</p><h3 id="3-2-方案二"><a href="#3-2-方案二" class="headerlink" title="3.2 方案二"></a>3.2 方案二</h3><p>安装固定链接插件：<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a></p><p>插件作用：自动为每篇文章生成一串数字作每篇文章的URI地址。每篇文章的<code>Front-matter</code>中会自动增加一个配置项：<code>abbrlink: xxxxx</code>，该项的值就是当前文章的URI地址。</p><ol><li><p>Hexo根目录执行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>Hexo配置文件</code>末尾加入以下配置：</p><pre class="line-numbers language-yml"><code class="language-yml"># hexo-abbrlink config 、固定文章地址插件abbrlink:  alg: crc16  #算法选项：crc16、crc32，区别见之前的文章，这里默认为crc16丨crc32比crc16复杂一点，长一点  rep: dec    #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Hexo配置文件</code>中修改<code>permalink</code>如下：</p><pre class="line-numbers language-yml"><code class="language-yml"># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://adaichan.comroot: /permalink: posts/:abbrlink.htmlpermalink_defaults:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>这样站点结构就变成了：<code>域名/posts/xxx.html</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp 快速入门</title>
      <link href="/2021/01/01/18.gulp/"/>
      <url>/2021/01/01/18.gulp/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>在确保你的电脑里装了 Node 的情况下，打开命令行执行以下代码：</p><pre><code>npm install --global gulp</code></pre><p>全局安装 gulp，打开命令行输入 <code>gulp -v</code> 有版本号则证明安装成功了。<br>然后创建一个文件夹，名字随意，我们接下来的操作都在这个文件夹中进行。<br>我创建的文件夹叫 <code>gulpexample</code>，如果安装了 git 进入这个文件夹，右键选择 <code>git bash here</code>，没有安装就进入 <code>cmd</code> 然后进入相应的文件目录下。</p><ul><li>执行 <code>npm init</code> 之后填写名字、作者、描述之类的，剩下的就一顿回车，之后你的文件夹中就会自动生成一个 <code>package.json</code> 文件</li><li>然后在命令行中执行 <code>npm instal gulp --save-dev</code> 在当前项目中安装 gulp。</li></ul><p>好了，现在 gulp 就安装完毕了，接下来我们可以操作了：</p><ul><li>在根目录创建一个文件命名为 <code>gulpfile.js</code> （必须是这个，不能变）</li><li>在根目录创建一个文件夹 <code>src</code></li></ul><h2 id="二、Gulp-的-API"><a href="#二、Gulp-的-API" class="headerlink" title="二、Gulp 的 API"></a>二、Gulp 的 API</h2><pre><code>gulp.task -- 定义任务    gulp.task('任务名，命名随意',fn);gulp.src  -- 找到需要执行任务的文件    gulp.src('要执行的文件的目录').pipe(要执行的api)gulp.dest -- 执行任务的文件的去处    gulp.dest('文件的去处目录（若没有回创建文件夹）')gulp.watch -- 观察文件是否变化    gulp.watch('要监控的文件目录下的文件','变化后要执行的task')</code></pre><h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><ul><li>打开 <code>gulpfile.js</code> 输入如下代码：</li></ul><pre><code>var gulp = require('gulp');// 定义任务gulp.task('message',function(){    return console.log('gulp is running!');});</code></pre><ul><li>然后再当前文件夹目录下的命令行中执行 gulp message，可以看到 <code>gulp is running</code> 证明任务已经执行了。</li></ul><p><strong>拷贝文件，压缩合并 js，sass编译，压缩图片</strong>的用法：<br>首先来安装上述功能相对应的插件（同样也是在相应的目录下执行才可以）</p><pre><code>npm install gulp-sass gulp-concat gulp-uglify gulp-imagemin --save-dev</code></pre><p>安装可能会有些慢，如果实在受不了的话可以安装淘宝的镜像 cnpm 然后用 cnpm 执行。<br>cnpm 的安装如下：</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>安装完 gulp 的插件后在项目根目录新建文件夹 <code>src</code>，打开 <code>gulpfile.js</code> 开始配置：</p><ul><li><strong>第一步，引入插件：</strong></li></ul><pre><code>// 引入gulp及插件var gulp = require('gulp'); var imagemin = require('gulp-imagemin'); // 图片压缩var uglify = require('gulp-uglify'); // js压缩var sass = require('gulp-sass'); // sass编译var concat = require('gulp-concat'); // 代码合并</code></pre><ul><li><strong>第二步，定义任务：</strong></li></ul><p>先定义个简单的任务来熟悉一下 <code>gulp</code> 用法，下面定义一个拷贝 html 的任务：</p><p><strong>任务一， 拷贝html</strong></p><pre><code>// 任务：拷贝htmlgulp.task('copyHtml',function(){    // 选取到src目录下的所有html文件 （为了测试效果，请自己再src目录下随便创建两个html文件咯）    gulp.src('src/*.html')        .pipe(gulp.dest('dist')); // 将html拷贝到dist目录下，没有dist会自动生成});</code></pre><p>在命令行里执行 gulp copyHtml 即可。</p><p><strong>任务二， 图片压缩</strong></p><p>准备工作：在 src 目录下新建 images 文件夹，里面随便放几张图片。</p><pre><code>// 任务： 图片压缩gulp.task('imagemin',function(){    gulp.src('src/images/*')        .pipe(imagemin()) // 调用插件imagemin        .pipe(gulp.dest('dist/image')) // 压缩后的图片输出目录});</code></pre><p>同样命令行执行 gulp imagemin 即可完成输出，<br>基本了解了 gulp 的任务写法后，接下来几个任务就不细说了，直接上代码：</p><pre><code>// sass 编译 src目录下件文件夹sass然后在里面新建一个sass文件，按照sass的语法写一些样式gulp.task('sass',function(){    gulp.src('src/sass/*') // 获取sass文件（*.scss）        .pipe(sass().on('error',sass.logError)) // 执行sass插件，并检查错误        .pipe(gulp.dest('dist/css')); // 输出css文件的路径});// 合并压缩代码，src目录下新建文件夹js然后在里面创建几个js文件gulp.task('scripts',function(){    gulp.src('src/js/*.js') // 获取js文件        .pipe(concat('main.js')) // 合并文件为main.js        .pipe(uglify()) // 压缩js代码        .pipe(gulp.dest('dist/js')) // 输出合并压缩后的文件路径});</code></pre><p>现在4个 api 已经用了3个，还有一个监听的 <code>watch</code> 没有用，就是监听相应目录下的文件是否发生改变，如果改变执行某个任务，即一个参数为监听目录，另一个参数为要执行的任务，（watch 是一个持续执行的任务结束的话是不会停止的）代码如下：</p><pre><code>// 监听文件是否发生变化gulp.task('watch',function(){    gulp.watch('src/js/*.js',['scripts']); // 监听src/js/下的所有js文件，如果发生变化则执行任务scripts,下面同理    gulp.watch('src/sass/*',['sass']);    gulp.watch('src/*.html',['copyHtml']);    gulp.watch('src/images/*',['imageMin']);});</code></pre><p>现在就已经有了5个任务了（算上最开始的 <code>message</code> 就6个了）每一个任务都要执行一遍命令行很麻烦。如果任务多了就更烦了，不要担心，<code>gulp</code> 为我们准备了默认任务 <code>default</code></p><pre><code>// 定义默认任务 , 这里的默认任务default不能随便定义 只能是default,后面接受一个数组作为参数，传入默认执行的任务，后面还可以接受一个回调函数用以执行默认任务代码这里就不给做展示了gulp.task('default',['message','copyHtml','sass','scripts','imageMin','watch']);</code></pre><p>定义好默认任务如上后，在命令行中输入 <code>gulp</code> 回车即可按照参数中的任务顺序全部执行。</p><h2 id="四、压缩-HEXO"><a href="#四、压缩-HEXO" class="headerlink" title="四、压缩 HEXO"></a>四、压缩 HEXO</h2><p><strong>使用方法：</strong></p><p>进入站点根目录依次执行下面的命令：</p><pre><code># 全局安装gulp模块npm install gulp -g# 安装各种小功能模块,执行这步可能会提示权限的问题，最好以管理员模式执行npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save# 额外的功能模块npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save</code></pre><p>在 Hexo 根目录新建文件 <code>gulpfile.js</code>，并复制以下内容到文件，有中文注释，根据自己需求修改。（注意：文件名不能错，一定为 <code>gulpfile.js</code>，否则会出错！）</p><pre><code>var gulp = require("gulp");var debug = require("gulp-debug");var cleancss = require("gulp-clean-css"); // css压缩组件var uglify = require("gulp-uglify"); // js压缩组件var htmlmin = require("gulp-htmlmin"); // html压缩组件var htmlclean = require("gulp-htmlclean"); // html清理组件var imagemin = require("gulp-imagemin"); // 图片压缩组件var changed = require("gulp-changed"); // 文件更改校验组件var gulpif = require("gulp-if"); //任务 帮助调用组件var plumber = require("gulp-plumber"); // 容错组件（发生错误不跳出任务，并报出错误内容）var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)var isDebug = true; //是否调试显示 编译通过的文件var gulpBabel = require("gulp-babel");var es2015Preset = require("babel-preset-es2015");var del = require("del");var Hexo = require("hexo");var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象// 清除public文件夹gulp.task("clean", function () {    return del(["public/**/*"]);});// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return// 创建静态页面 （等同 hexo generate）gulp.task("generate", function () {    return hexo.init().then(function () {        return hexo            .call("generate", {                watch: false            })            .then(function () {                return hexo.exit();            })            .catch(function (err) {                return hexo.exit(err);            });    });});// 启动Hexo服务器gulp.task("server", function () {    return hexo        .init()        .then(function () {            return hexo.call("server", {});        })        .catch(function (err) {            console.log(err);        });});// 部署到服务器gulp.task("deploy", function () {    return hexo.init().then(function () {        return hexo            .call("deploy", {                watch: false            })            .then(function () {                return hexo.exit();            })            .catch(function (err) {                return hexo.exit(err);            });    });});// 压缩public目录下的js文件gulp.task("compressJs", function () {    return gulp        .src(["./public/**/*.js", "!./public/libs/**"]) //排除的js        .pipe(gulpif(!isScriptAll, changed("./public")))        .pipe(gulpif(isDebug, debug({ title: "Compress JS:" })))        .pipe(plumber())        .pipe(            gulpBabel({                presets: [es2015Preset] // es5检查机制            })        )        .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩        .pipe(gulp.dest("./public")); //输出到目标目录});// 压缩public目录下的css文件gulp.task("compressCss", function () {    var option = {        rebase: false,        //advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]        compatibility: "ie7" //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式]        //keepBreaks: true, //类型：Boolean 默认：false [是否保留换行]        //keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀    };    return gulp        .src(["./public/**/*.css", "!./public/**/*.min.css"]) //排除的css        .pipe(gulpif(!isScriptAll, changed("./public")))        .pipe(gulpif(isDebug, debug({ title: "Compress CSS:" })))        .pipe(plumber())        .pipe(cleancss(option))        .pipe(gulp.dest("./public"));});// 压缩public目录下的html文件gulp.task("compressHtml", function () {    var cleanOptions = {        protect: /&lt;\!--%fooTemplate\b.*?%--&gt;/g, //忽略处理        unprotect: /&lt;script [^&gt;]*\btype="text\/x-handlebars-template"[\s\S]+?&lt;\/script&gt;/gi //特殊处理    };    var minOption = {        collapseWhitespace: true, //压缩HTML        collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input /&gt;        removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt;        removeScriptTypeAttributes: true, //删除&lt;script&gt;的type="text/javascript"        removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type="text/css"        removeComments: true, //清除HTML注释        minifyJS: true, //压缩页面JS        minifyCSS: true, //压缩页面CSS        minifyURLs: true //替换页面URL    };    return gulp        .src("./public/**/*.html")        .pipe(gulpif(isDebug, debug({ title: "Compress HTML:" })))        .pipe(plumber())        .pipe(htmlclean(cleanOptions))        .pipe(htmlmin(minOption))        .pipe(gulp.dest("./public"));});// 压缩 public/medias 目录内图片gulp.task("compressImage", function () {    var option = {        optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级）        progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片        interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染        multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化    };    return gulp        .src("./public/medias/**/*.*")        .pipe(gulpif(!isScriptAll, changed("./public/medias")))        .pipe(gulpif(isDebug, debug({ title: "Compress Images:" })))        .pipe(plumber())        .pipe(imagemin(option))        .pipe(gulp.dest("./public"));});// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器gulp.task(    "build",    gulp.series(        "clean",        "generate",        "compressHtml",        "compressCss",        "compressJs",        "compressImage",        gulp.parallel("deploy")    ));// 默认任务gulp.task(    "default",    gulp.series(        "clean",        "generate",        gulp.parallel("compressHtml", "compressCss", "compressJs","compressImage")    ));//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数</code></pre><p>以后的执行方式有两种：</p><ul><li>直接在 Hexo 根目录执行 <code>gulp</code> 或者 <code>gulp default</code> ，这个命令相当于 <code>hexo cl&amp;&amp;hexo g</code> 并且再把代码和图片压缩。</li><li>在 Hexo 根目录执行 <code>gulp build</code> ，这个命令与第 1 种相比是：在最后又加了个 <code>hexo d</code> ，等于说生成、压缩文件后又帮你自动部署了。</li></ul><blockquote><p>注意：这个加入了图片压缩，不想用图片压缩可以把第 154 行的 <code>"compressImage"</code> 和第 165 行的 <code>"compressImage"</code> 去掉即可.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PR 重拾记录</title>
      <link href="/2020/12/31/17.pr/"/>
      <url>/2020/12/31/17.pr/</url>
      
        <content type="html"><![CDATA[<h2 id="一、导入素材"><a href="#一、导入素材" class="headerlink" title="一、导入素材"></a>一、导入素材</h2><p>打开 PR <strong>新建项目：</strong></p><p><img src="1.1.png"></p><p><strong>修改 名称、位置</strong>，其他不用变，点击确定</p><p><img src="1.2.png"></p><p><strong>进入界面如下：</strong></p><p><img src="1.3.png"></p><p><strong>认识、添加必要 窗口</strong></p><p><img src="1.4.png"></p><p><strong>导入媒体以开始，部分右键创建 素材箱</strong></p><p><img src="1.5.png"></p><p><strong>进入素材箱，右键选择导入，要导入的素材</strong></p><p><img src="1.6.png"></p><p><strong>将其拖到时间轴窗口</strong></p><p><img src="1.7.png"></p><h2 id="二、剪辑添加音乐"><a href="#二、剪辑添加音乐" class="headerlink" title="二、剪辑添加音乐"></a>二、剪辑添加音乐</h2><p><strong>使用剃刀工具（快捷键 C）</strong></p><p><img src="2.1.png"></p><p><strong>将视频剪成几部分，用选择工具拖拽</strong></p><p><img src="2.2.png"></p><p><strong>添加音乐，很简单，将音乐素材拖到时间轴窗口，注意M、S，M为静音轨道，S为独奏轨道</strong></p><p><img src="2.3.png"></p><p><strong>背景音乐声音大小调试，在剪辑混合器</strong></p><p><img src="2.4.png"></p><h2 id="三、添加字幕"><a href="#三、添加字幕" class="headerlink" title="三、添加字幕"></a>三、添加字幕</h2><p><strong>字幕 -&gt; 新建字幕 -&gt; 默认静态字幕</strong></p><p><img src="3.1.png"></p><p><strong>输入文字，可改变字体，颜色等等，自己想要的。CTRL+S 保存</strong></p><p><strong>然后将字幕拖到时间轴窗口，放到合适位置。</strong></p><p><img src="3.2.png"></p><h2 id="四、速度与持续时间"><a href="#四、速度与持续时间" class="headerlink" title="四、速度与持续时间"></a>四、速度与持续时间</h2><p><strong>右击，选择速度与持续时间，可改变视频播放速度</strong></p><p><img src="4.1.png"></p><p><img src="4.2.png"></p><p><strong>选中倒放速度是可以实现倒放效果的</strong></p><h2 id="五、过渡"><a href="#五、过渡" class="headerlink" title="五、过渡"></a>五、过渡</h2><p><strong>两个视频过度效果，选择一个拖到时间轴窗口。</strong></p><p><img src="5.1.png"></p><h2 id="六、移动、缩放"><a href="#六、移动、缩放" class="headerlink" title="六、移动、缩放"></a>六、移动、缩放</h2><p><strong>移动、缩放。选择效果控件窗口，打锚点</strong></p><p><img src="6.1.png"></p><h2 id="七、渲染"><a href="#七、渲染" class="headerlink" title="七、渲染"></a>七、渲染</h2><p><strong>不要有红色。应按回车，渲染，可以使视频更顺畅</strong></p><p><img src="7.1.png"></p><h2 id="八、创意"><a href="#八、创意" class="headerlink" title="八、创意"></a>八、创意</h2><p><strong>打开 Lumetri Clolor 窗口，点击创意，可选择视频颜色</strong></p><p><img src="8.1.png"></p><h2 id="九、视频导出"><a href="#九、视频导出" class="headerlink" title="九、视频导出"></a>九、视频导出</h2><p><strong>文件-&gt;导出-&gt;媒体，格式一般选择 H.264，点击导出。PR 能力有限，需要120帧得用到 DAINAPP、Topaz 等特别考验显卡性能的软件耗子尾汁。</strong></p><h2 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h2><p><a href="https://www.bilibili.com/video/BV1Vt411n7Bb">https://www.bilibili.com/video/BV1Vt411n7Bb</a></p><p><a href="https://www.bilibili.com/video/BV1kz411i76K">https://www.bilibili.com/video/BV1kz411i76K</a></p><p><a href="https://www.bilibili.com/video/BV1HJ411h78u">https://www.bilibili.com/video/BV1HJ411h78u</a></p><p><a href="https://www.bilibili.com/video/BV1R441177my">https://www.bilibili.com/video/BV1R441177my</a></p><p><a href="https://www.bilibili.com/video/BV1st411n75R">https://www.bilibili.com/video/BV1st411n75R</a></p><p>顺带放上 <strong>PS</strong> 的教程⑧：</p><p><a href="https://www.bilibili.com/video/BV1Xs411q7DW">https://www.bilibili.com/video/BV1Xs411q7DW</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lazyload 优化</title>
      <link href="/2020/12/28/16.lazyload/"/>
      <url>/2020/12/28/16.lazyload/</url>
      
        <content type="html"><![CDATA[<h2 id="一、懒加载和预加载"><a href="#一、懒加载和预加载" class="headerlink" title="一、懒加载和预加载"></a>一、懒加载和预加载</h2><p>图片加载方式有两种，一个是预加载，另一个就是懒加载。</p><ul><li>图片预加载：顾名思义，图片预加载就是在网页全部加载之前，提前加载图片。当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，这样浏览者可能以为图片预览慢而没兴趣浏览，把网页关掉，这时，就需要图片预加载。当然这种做法实际上牺牲了服务器的性能换取了更好的用户体验。</li><li>图片懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片。这样做的好处是减少不必要的访问数据库或延迟访问数据库的次数，因为每次访问数据库都是比较耗时的即只有真正使用该对象的数据时才会创建。懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</li></ul><p><strong>预加载与懒加载的区别之处：</strong></p><p>两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预载则会增加服务器前端压力。</p><p>使用图片懒加载需要安装插件：<a href="https://github.com/Troy-Yang/hexo-lazyload-image">hexo-lazyload-image</a></p><p>在站点根目录执行下面的命令：</p><pre><code>npm install hexo-lazyload-image --save</code></pre><p>之后在站点配置文件下添加下面的代码：</p><pre><code>lazyload:  enable: true  # 是否开启图片懒加载  onlypost: false  # 是否只对文章的图片做懒加载  loadingImg: # eg ./images/loading.gif</code></pre><p>最后执行 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> 就可以看到效果了。</p><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><ul><li>问题 1：查看大图，发现全部为 loading 加载图，原因是懒加载插件与 <strong>lightgallery 插件</strong>冲突，解决办法如下：</li></ul><p>修改主题文件下的 <strong>matery.js</strong>，在 108 行左右添加以下代码：</p><pre><code>$(document).find('img[data-original]').each(function(){    $(this).parent().attr("href", $(this).attr("data-original"));});</code></pre><ul><li>问题 2：点击首页 <strong>logo</strong> 不是跳转到首页，而是查看 <strong>logo</strong> 图片，解决办法如下：</li></ul><p>修改主题的 <strong>header.ejs</strong> 文件，原代码为：</p><pre><code>&lt;div class="brand-logo"&gt;    &lt;a href="&lt;%- url_for() %&gt;" class="waves-effect waves-light"&gt;         &lt;% if (theme.logo !== undefined &amp;&amp; theme.logo.length &gt; 0) { %&gt;         &lt;img src="&lt;%= theme.logo %&gt;" class="logo-img" alt="LOGO"&gt;         &lt;% } %&gt;         &lt;span class="logo-span"&gt;&lt;%- config.title %&gt;&lt;/span&gt;    &lt;/a&gt;&lt;/div&gt;</code></pre><p>修改为：</p><pre><code>&lt;div class="brand-logo"&gt;    &lt;a href="&lt;%- url_for() %&gt;" class="waves-effect waves-light"&gt;        &lt;div&gt;            &lt;% if (theme.logo !== undefined &amp;&amp; theme.logo.length &gt; 0) { %&gt;            &lt;img src="&lt;%= theme.logo %&gt;" class="logo-img" alt="LOGO"&gt;            &lt;% } %&gt;            &lt;span class="logo-span"&gt;&lt;%- config.title %&gt;&lt;/span&gt;        &lt;/div&gt;    &lt;/a&gt;&lt;/div&gt;</code></pre><h2 id="三、优化"><a href="#三、优化" class="headerlink" title="三、优化"></a>三、优化</h2><ul><li>第一次加载后本地都是有缓存的，每次都把 loading 显示出来不好看</li><li>得对插件进行魔改，让图片稍微提前加载，避开加载动画</li><li>打开 <code>Hexo根目录</code> &gt;<code>node_modules</code> &gt; <code>hexo-lazyload-image</code> &gt; <code>lib</code> &gt; <code>simple-lazyload.js</code> 文件</li><li>第 11 行修改为：</li></ul><pre><code>&amp;&amp; rect.top &lt;= (window.innerHeight +240 || document.documentElement.clientHeight +240)</code></pre><p>作用：提前 240 个像素加载图片，当然这个值也可以根据自己情况修改。</p><h2 id="四、添加-loading-pages"><a href="#四、添加-loading-pages" class="headerlink" title="四、添加 loading-pages"></a>四、添加 loading-pages</h2><p>在站点根目录下新建<strong>scripts</strong>文件夹，在该文件夹下新建名为 <strong>loading-pages</strong> 的 <strong>js</strong> 文件，加入下面代码：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/* global hexo */</span><span class="token string">"use strict"</span><span class="token punctuation">;</span>hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>filter<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'after_render:html'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>htmlContent<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">const</span> injectHead <span class="token operator">=</span> <span class="token template-string"><span class="token string">`&lt;style type="text/css" lang="css">    #loading-container{        position: fixed;        top: 0;        left: 0;        min-height: 100vh;        width: 100vw;        z-index: 9999;        display: flex;        flex-direction: column;        justify-content: center;        align-items: center;        background: #FFF;        text-align: center;        /* loader页面消失采用渐隐的方式*/        -webkit-transition: opacity 1s ease;        -moz-transition: opacity 1s ease;        -o-transition: opacity 1s ease;        transition: opacity 1s ease;    }    .loading-image{        width: 120px;        height: 50px;        transform: translate(-50%);    }        .loading-image div:nth-child(2) {        -webkit-animation: pacman-balls 1s linear 0s infinite;        animation: pacman-balls 1s linear 0s infinite    }    .loading-image div:nth-child(3) {        -webkit-animation: pacman-balls 1s linear .33s infinite;        animation: pacman-balls 1s linear .33s infinite    }    .loading-image div:nth-child(4) {        -webkit-animation: pacman-balls 1s linear .66s infinite;        animation: pacman-balls 1s linear .66s infinite    }    .loading-image div:nth-child(5) {        -webkit-animation: pacman-balls 1s linear .99s infinite;        animation: pacman-balls 1s linear .99s infinite    }       .loading-image div:first-of-type {        width: 0;        height: 0;        border: 25px solid #49b1f5;        border-right-color: transparent;        border-radius: 25px;        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;        animation: rotate_pacman_half_up .5s 0s infinite;    }    .loading-image div:nth-child(2) {        width: 0;        height: 0;        border: 25px solid #49b1f5;        border-right-color: transparent;        border-radius: 25px;        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;        animation: rotate_pacman_half_down .5s 0s infinite;        margin-top: -50px;    }    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}        @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}           .loading-image div:nth-child(3),    .loading-image div:nth-child(4),    .loading-image div:nth-child(5),    .loading-image div:nth-child(6){        background-color: #49b1f5;        width: 15px;        height: 15px;        border-radius: 100%;        margin: 2px;        width: 10px;        height: 10px;        position: absolute;        transform: translateY(-6.25px);        top: 25px;        left: 100px;    }    .loading-text{        margin-bottom: 20vh;        text-align: center;        color: #2c3e50;        font-size: 2rem;        box-sizing: border-box;        padding: 0 10px;        text-shadow: 0 2px 10px rgba(0,0,0,0.2);    }    @media only screen and (max-width: 500px) {         .loading-text{            font-size: 1.5rem;         }    }    .fadeout {        opacity: 0;        filter: alpha(opacity=0);    }    /* logo出现动画 */    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}} &lt;/style> &lt;script>(function () {    const loaded = function(){       setTimeout(function(){            const loader = document.getElementById("loading-container");            loader.className="fadeout" ;//使用渐隐的方法淡出loading page            // document.getElementById("body-wrap").style.display="flex";            setTimeout(function(){                loader.style.display="none";            },1000);         },1000);//强制显示loading page 1s      };    loaded();})() &lt;/script>`</span></span><span class="token punctuation">;</span>     <span class="token keyword">const</span> injectBody <span class="token operator">=</span> <span class="token template-string"><span class="token string">` &lt;div id="loading-container">     &lt;p class="loading-text">玩命加载中 . . . &lt;/p>      &lt;div class="loading-image">         &lt;div>&lt;/div>         &lt;div>&lt;/div>         &lt;div>&lt;/div>         &lt;div>&lt;/div>          &lt;div>&lt;/div>     &lt;/div> &lt;/div>`</span></span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/&lt;\/head>/gi</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>htmlContent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> htmlContent<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'&lt;/head>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         htmlContent <span class="token operator">=</span> htmlContent<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> lastIndex<span class="token punctuation">)</span> <span class="token operator">+</span> injectHead <span class="token operator">+</span> htmlContent<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lastIndex<span class="token punctuation">,</span> htmlContent<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/&lt;body>/gi</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>htmlContent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">let</span> index <span class="token operator">=</span> htmlContent<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'&lt;body>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         htmlContent <span class="token operator">=</span> htmlContent<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">+</span> injectBody <span class="token operator">+</span> htmlContent<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> htmlContent<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> htmlContent<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lazyload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element UI 实战心得</title>
      <link href="/2020/12/26/15.element-ui/"/>
      <url>/2020/12/26/15.element-ui/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>这里首先得下载 Element UI 才能在项目中使用，方式有很多种，我是在项目初始化时先安装 Vue 脚手架：</p><ol><li><p>控制台输入：<code>vue ui</code> </p></li><li><p>点击创建，设置好存放路径后点击在此创建新项目、项目取名、初始化 git </p></li><li><p>填写：<strong>init project</strong>、点击下一步进行预设配置（preset）</p></li><li><p>点亮 <strong>babel、router、linter/formatter、</strong>使用配置文件，点击下一步</p></li><li><p>取消 <strong>history 模式</strong>路由（hash模式兼容性更好）</p></li><li><p>选 <strong>eslint+standard confit</strong>，选 <strong>lint on save</strong>（ctrl+s就会对所写代码进行格式校验）</p></li><li><p>保存配置好的预设并取名</p></li><li><p>配置 Vue 路由</p></li><li><p>配置 Element-UI 组件库：在可视面板的插件中添加 Element-UI，搜索：<strong>vue-cli-plugin-element</strong>，配置插件：将 fully import 改成 <strong>import on demand</strong>（按需引入）</p></li><li><p>配置 axios 库：在安装依赖中搜索 <strong>axios</strong> 并安装，点击创建项目。</p></li><li><p>初始化 git 远程仓库并将本地项目托管到 GitHub：确认项目根目录有 <strong>.gitignore</strong> 文件，有 **node_modules、.idea **文件。</p></li><li><p>后台项目的环境安装配置（数据库、Node 环境等安装配置不一一赘述）。</p></li></ol><h2 id="二、引入"><a href="#二、引入" class="headerlink" title="二、引入"></a>二、引入</h2><blockquote><p>当然文档中推荐使用 CDN 引入 Element 的用户在链接地址上锁定版本，以免将来 Element 升级时受到非兼容性更新的影响。锁定版本的方法请查看 <a href="https://unpkg.com/">unpkg.com</a>。</p></blockquote><p>这里 2.14.1 版本需要在 main.js 中引入 Element UI 的 js 和 css 文件即可开始使用。（我的初始化过程漏掉了一个 css 文件需要自己导入样式文件，这里官方文档有补充说明）<br>相关组件按需引入即可，完整引入项目体积太大了：</p><p><strong>按需引入：</strong></p><p>借助 <a href="https://github.com/QingWei-Li/babel-plugin-component">babel-plugin-component</a>，我们可以只引入需要的组件，达到减小项目体积的目的。</p><p>首先，安装 babel-plugin-component：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> babel-plugin-component -D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，将 .babelrc 修改为：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"presets"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"es2015"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token property">"modules"</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>      <span class="token string">"component"</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"libraryName"</span><span class="token operator">:</span> <span class="token string">"element-ui"</span><span class="token punctuation">,</span>        <span class="token property">"styleLibraryName"</span><span class="token operator">:</span> <span class="token string">"theme-chalk"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果只希望引入部分组件，比如 Button 和 Select，需要在 element.js 中写入以下内容：</p><pre><code>import Vue from 'vue'import {  Breadcrumb,  Card,  Row,  Tooltip,  Pagination,  Dialog,  Tree,  Cascader} from 'element-ui'Vue.use(Breadcrumb)Vue.use(Card)Vue.use(Row)Vue.use(Tooltip)Vue.use(Pagination)Vue.use(Dialog)Vue.use(Tree)Vue.use(Cascader)// 导入弹框提示组件 Message、MessageBox，该类组件和其他不同需要全局挂载Vue.prototype.$message = MessageVue.prototype.$confirm = MessageBox.confirm</code></pre><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><p>先查看自己需要什么类型的组件，在 Element UI 的文档中筛选查找，找到对应的代码模板，在自己项目的对应位置粘贴上文档中的代码，根据具体情况做下调整修改就可以了，如：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript"><template>  <div>    <!-- 面包屑导航区域 -->    <el-breadcrumb separator-class="el-icon-arrow-right">      <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>      <el-breadcrumb-item>权限管理</el-breadcrumb-item>      <el-breadcrumb-item>权限列表</el-breadcrumb-item>    </el-breadcrumb>    <!-- 卡片视图 -->    <el-card>      <el-table :data="rightsList" border stripe>        <el-table-column type="index"></el-table-column>        <el-table-column label="权限名称" prop="authName"></el-table-column>        <el-table-column label="路径" prop="path"></el-table-column>        <el-table-column label="权限等级" prop="level">          <!-- 通过作用域插槽的形式自定义该栏的输出格式 -->          <template slot-scope="scope">            <el-tag v-if="scope.row.level === '0'">一级</el-tag>            <el-tag type="success" v-else-if="scope.row.level === '1'">二级</el-tag>            <el-tag type="warning" v-else>三级</el-tag>          </template>        </el-table-column>      </el-table>    </el-card>  </div></template><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在 Element UI 中的标签名默认为对应的类名，添加样式时可以直接拿来使用，如：</p><pre class="line-numbers language-JavaScript"><code class="language-JavaScript">.el-breadcrumb {  margin-bottom: 15px;  font-size: 12px;}.el-card {  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.15) !important;}.el-table {  margin-top: 15px;  font-size: 12px;}.el-pagination {  margin-top: 15px;}.el-cascader-menu {  height: 228px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Element UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 继承汇总</title>
      <link href="/2020/12/24/14.js-ji-cheng/"/>
      <url>/2020/12/24/14.js-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// child name: son</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要是原型链中出现的原型，都可以说是该原型链派生的实例的原型。</p><p>这里存在两个缺点：</p><ol><li>子类型无法给超类型传递参数，在面向对象的继承中，我们总希望通过 var child = new Child(‘son’, ‘father’); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent(‘father’) 去调用父类。</li><li>Child.prototype.sayName 必须写在 Child.prototype = new Parent(‘father’); 之后，不然就会被覆盖掉。</li></ol><h2 id="二、类式继承"><a href="#二、类式继承" class="headerlink" title="二、类式继承"></a>二、类式继承</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>doSomthing <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent do something!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// child name: son</span>child<span class="token punctuation">.</span><span class="token function">doSomthing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// TypeError: child.doSomthing is not a function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相当于 Parent 这个函数在 Child 函数中执行了一遍，并且将所有与 this 绑定的变量都切换到了 Child 上，这样就克服了第一种方式带来的问题。</p><p>缺点：</p><ol><li>没有原型，每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。</li></ol><h2 id="三、组合式继承：结合前两种"><a href="#三、组合式继承：结合前两种" class="headerlink" title="三、组合式继承：结合前两种"></a>三、组合式继承：结合前两种</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>doSomething <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent do something!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// child name: son</span>child<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// parent do something!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p><p>这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p><p><strong>组合式继承是 JS 最常用的继承模式，但组合继承使用过程中会被调用两次：一次是创建子类型的时候，另一次是在子类型构造函数的内部。</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>doSomething <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent do something!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 第二次调用</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 第一次调用</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      child<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然从上述的代码中可以看出，第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了，所以这时候你可能会这样写：</p><pre class="line-numbers language-js"><code class="language-js">Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样写显然是不对的：</p><ol><li>首先，你这样写的话相当于是子类和父类都指向同一个对象，这时候如果你添加了新的方法给 Child 但实际上 Parent 并不需要，相当于强行给 Parent 添加了一个未知的方法。</li><li>其次，仔细想想，这样体现不出继承的多态性，比如此时子类想要重写父类的 getName 的方法，那么父类的方法也就会随之修改，这显然违背了多态性。</li></ol><p>也就是说我们第一次调用构造函数的时候，其实是不管构造函数里面的内容，所以我们何不 new 一个空函数，将其 prototype 指向 Parent.prototype，代码如下：</p><h2 id="四、寄生组合式继承"><a href="#四、寄生组合式继承" class="headerlink" title="四、寄生组合式继承"></a>四、寄生组合式继承</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> proto<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parent<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// parent name: father</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">,</span> <span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// child name: son</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是所谓的<strong>寄生组合式继承方式</strong>，跟组合式继承的区别在于，他不需要在一次实例中调用两次父类的构造函数，假如说父类的构造器代码很多，还需要调用两次的话对系统肯定会有影响，<strong>寄生组合式继承的思想在于：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</strong></p><p>在上面的代码中，我们手动创建了一个 create 函数，但是其实是存在于 Object 对象中，不需要我们手动去创建，所以上面的代码可以改为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Parent<span class="token punctuation">,</span> Child<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//修改</span>    Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Parent<span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parent<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// parent name: father</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">,</span> <span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// child name: son</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、ES6-继承"><a href="#五、ES6-继承" class="headerlink" title="五、ES6 继承"></a>五、ES6 继承</h2><p>ES6 写继承就特别简单，如果你学过 Java 就会发现，ES6 中的继承跟 Java 太像了，上述的代码可改为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent do something!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">,</span> <span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// child name: son</span>child<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// parent do something!</span><span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parent<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// parent name: father</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ES5 继承和 ES6 继承的区别</strong></p><p>es5 继承首先是在子类中创建自己的 this 指向，最后将方法添加到 this 中</p><p><code>Child.prototype=new Parent() || Parent.apply(this) || Parent.call(this)</code></p><p>es6 继承是使用关键字先创建父类的实例对象 this，最后在子类 class 中修改 this。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 协议相关</title>
      <link href="/2020/12/22/13.http-xie-yi/"/>
      <url>/2020/12/22/13.http-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、请求报文和响应报文"><a href="#一、请求报文和响应报文" class="headerlink" title="一、请求报文和响应报文"></a>一、请求报文和响应报文</h2><p>http请求报文组成: 请求行+请求头+请求体</p><p>http响应报文组成: 响应行+响应头+响应体</p><p>请求行: 请求方法(HEAD/GET/POST) + 请求URL + HTTP协议版本</p><p>响应行: HTTP协议版本 + 状态码 + 状态码描述</p><p>请求头: 比如客户端的Cookie和User-Agent就放在这里</p><p>响应头: 比如服务器的Set-Cookie和Server信息就放在这里</p><p>请求体: 比如客户端POST的数据就放在这里(对比:GET的数据放在请求行的URL里)</p><p>响应体: 比如服务器返回的HTML和JSON数据就放在这里</p><h2 id="二、输入地址到展示过程"><a href="#二、输入地址到展示过程" class="headerlink" title="二、输入地址到展示过程"></a>二、输入地址到展示过程</h2><p>（1）浏览器输入url,先解析url地址是否合法</p><p>（2）浏览器检查是否有缓存(浏览器缓存-系统缓存-路由器缓存)如果有,直接显示.如果没有,跳到第三步</p><p>（3）在发送http请求前,需要域名解析(DNS解析),解析获取对应过的ip地址</p><p>（4）浏览器向服务器发起tcp链接,与浏览器简历tcp三次握手</p><p>（5）握手成功后,浏览器向服务器发送http请求,请求数据包</p><p>（6）服务器收到处理的请求,将数据返回至浏览器</p><p>（7）浏览器收到http响应</p><p>（8）浏览器解析响应.如果响应可以缓存,则存入缓存</p><p>（9）浏览器发送请求获取嵌入在HTML中的资源(html,css,JavaScript,图片,音乐等),对于未知类型,会弹出对话框</p><p>（10）浏览器发送异步请求</p><p>（11）页面全部渲染结束</p><h2 id="三、HTTP-请求方式-类型"><a href="#三、HTTP-请求方式-类型" class="headerlink" title="三、HTTP 请求方式/类型"></a>三、HTTP 请求方式/类型</h2><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。向服务器读取数据，数据暴露在url中。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h2 id="四、HTTP-状态码"><a href="#四、HTTP-状态码" class="headerlink" title="四、HTTP 状态码"></a>四、HTTP 状态码</h2><p>下面是常见的HTTP状态码：</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><p>HTTP状态码共分为5种类型：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="五、HTTPS-和-SSL-加密"><a href="#五、HTTPS-和-SSL-加密" class="headerlink" title="五、HTTPS 和 SSL 加密"></a>五、HTTPS 和 SSL 加密</h2><p>（1）http是直接和tcp通信,https=http+ssl加密</p><p>（2）https有ca证书,http一般没有</p><p>（3）http默认端口号为80,https默认端口号为443</p><p>（4）https基于传输层,http基于应用层</p><p>（5）https对于搜索引擎更友好,利于seo,百度,谷歌等搜索引擎优先索引https网页</p><p>ssl加密: 发送密文的一方使用对方的公钥进行加密处理”对称的密钥”,然后对方用自己的私钥解密拿到”对称的密钥”,这样可以确保交换的密钥是安全的前提下,使用对称加密方式进行通信。</p><p>所以,https采用对称加密和非对称加密两者并用的混合加密机制。</p><h2 id="六、cookie-和-session"><a href="#六、cookie-和-session" class="headerlink" title="六、cookie 和 session"></a>六、cookie 和 session</h2><ol><li>cookies数据保存在客户端,session数据保存在服务端</li><li>cookie可以减轻服务器压力但不是很安全,别人可以进行cookie欺骗,考虑到安全应当使用session</li><li>session会在一定时间内保存在服务器上,当访问增多,会比较占用你服务器的性能,考虑到减轻服务器性能方面,应当使用cookie</li><li>单个的cookie保存的数据不能超过4K,很多浏览器都限制一个站点最多保存20个cookie</li><li>所以个人建议: </li></ol><p>将登陆信息等重要信息存放为session;其他信息如果需要保留,可以放在cookie中</p><p>通过Web Server或者浏览器来获取Cookie.多数浏览器能够配置允许用户访问Cookies,但是不同站点之间的Cookie不能共享</p><p>cookie有一个属性expires,设置其值为一个时间,那么当到达此时间后,此cookie失效.通过Okhttp的拦截器去进行持久化cookie</p><h2 id="七、HTTP-缓存机制"><a href="#七、HTTP-缓存机制" class="headerlink" title="七、HTTP 缓存机制"></a>七、HTTP 缓存机制</h2><pre><code>http缓存主要分为两种: 强缓存和协商缓存    a. 强缓存基本原理是: 所请求的数据在缓存数据库中尚未过期时,不与服务器进行交互,直接使用缓存数据库中的数据.    Expire指定了一个日期/时间,在这个日期/时间之后,http响应被认为是过时的.但是它本身是一个HTTP1.0标准下的字段,所以如果请求中还有一个置了"max-age"或者"s-max-age"指令的Cache-Control响应头,那么Expires 头就会被忽略.    Cache-Control通用消息头用于在http请求和响应中通过指定指令来实现缓存机制,其常用的几个取值有：    private: 客户端可以缓存    public: 客户端和代理服务器都可以缓存    max-age=xxx: 缓存的内容将在xxx 秒后失效    s-max-age=xxx: 同s-max-age,但仅适用于共享缓存(比如各个代理),并且私有缓存中忽略    no-cache: 需要使用协商缓存来验证缓存数据    no-store: 所有内容都不会缓存,强缓存和协商缓存都不会触发    must-revalidate: 缓存必须在使用之前验证旧资源的状态,并且不可使用过期资源    b. 当强缓存过期未命中或者响应报文Cache-Control中有must-revalidate标识必须每次请求验证资源的状态时,便使用协商缓存的方式去处理缓存文件    协商缓存主要原理是从缓存数据库中取出缓存的标识,然后向浏览器发送请求验证请求的数据是否已经更新,如果已更新则返回新的数据,若未更新则使用缓存数据库中的缓存数据</code></pre><h2 id="八、正-反向代理、中间人攻击"><a href="#八、正-反向代理、中间人攻击" class="headerlink" title="八、正/反向代理、中间人攻击"></a>八、正/反向代理、中间人攻击</h2><p><img src="8.png"></p><p>正向代理即是客户端代理,代理客户端,服务端不知道实际发起请求的客户端</p><p>反向代理即是服务端代理,代理服务端,客户端不知道实际提供服务的服务端</p><p>正向代理的用途:</p><p>（1）访问原来无法访问的资源,如google</p><p>（2）可以做缓存,加速访问资源</p><p>（3）对客户端访问授权,上网进行认证</p><p>（4）代理可以记录用户访问记录(上网行为管理),对外隐藏用户信息</p><p>反向代理的作用：</p><p>（1）保证内网的安全,阻止web攻击,大型网站,通常将反向代理作为公网访问地址,Web服务器是内网</p><p>（2）负载均衡,通过反向代理服务器来优化网站的负载</p><p>中间人攻击：</p><p>中间人攻击(Man-in-the-Middle Attack, MITM)是一种由来已久的网络入侵手段,并且当今仍然有着广泛的发展空间,如SMB会话劫持,DNS欺骗等攻击都是典型的MITM攻击.简而言之,所谓的MITM攻击就是通过拦截正常的网络通信数据,并进行数据篡改和嗅探,而通信的双方却毫不知情。</p><h2 id="九、３次握手与４次挥手"><a href="#九、３次握手与４次挥手" class="headerlink" title="九、３次握手与４次挥手"></a>九、３次握手与４次挥手</h2><p><img src="9.png"></p><blockquote><p>3次握手,保障通讯双方有通信的基础;4次挥手,保障通讯双方可以安全的回收TCP通信的系统资源.HTTP是基于TCP的协议,TCP是可靠的传输层协议</p></blockquote><p>具体内容:</p><p>三次握手: 是指在建立TCP连接协议时,需要在客户端和服务器之间发三个包,传送的包里不含数据,握手完毕后客户端和服务器才开始正式传送数据</p><p>第一次握手: 客户端发第一个包,SYN标志位为1,ACK=0,发送顺序号Seq=X(随机int).客户端进入SYN发送状态,等待服务器确认</p><p>第二次握手: 服务器收到包后发第二个包,包的SYN,ACK标志位=1,发送顺序号Seq=Y(随机int),接收顺序号ACK=X+1,此时服务器进入SYN接收状态</p><p>第三次握手: 客户端收到包后发第三个,SYN=0,ACK=1,接收顺序号ACK=Y+1,发送顺序号seq=X+1.客户端和服务器进入ESTABLISHED建立成功状态,完成三次握手</p><p>四次挥手: 是指终止TCP连接协议时,需要在客户端和服务器之间发送四个包</p><p>第一次挥手: 主动关闭方发送第一个包,其中FIN标志位为1,发送顺序号Seq=X</p><p>第二次挥手: 被动关闭方收到FIN包后发送第二个包,其中发送顺序号Seq=Z,接收顺序号ACK=X+1</p><p>第三次挥手: 被动关闭方再发送第三个包,其中FIN标志位为1,发送顺序号Seq=Y,接收顺序号ACK=X</p><p>第四次挥手: 主动关闭方发送第四个包,其中发送顺序号Seq=X,接收顺序号ACK=Y,完成四次挥手</p><blockquote><p>TCP为什么是三次握手,而不是两次或四次?</p></blockquote><p>TCP既要保证数据可靠传输,又要提高传输的效率,两次握手容易死锁,四次又浪费资源</p><p>TCP需要seq序列号做可靠重传或接收,防止连接复用时无法分辨seq是延迟的还是旧链接的,因此需要三次握手来确定双方的ISN(初始seq序列号）</p><p>比如一个seq过来了,跟现在记住的seq不一样,我不知道它是上条延迟的,还是上上条延迟的,所以接收方一定需要跟发送方确认SYN</p><blockquote><p>为什么建立连接协议是三次握手,而关闭连接却是四次握手呢?</p></blockquote><p>建立TCP连接时,ACK和SYN可以放在一个报文里发送.而关闭连接时,被动关闭方可能还需要发送一些数据后再发送FIN报文表示同意现在可以关闭连接了,所以它这里的ACK报文和FIN报文多数情况下都是分开发送的</p><blockquote><p>为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态?</p></blockquote><p>无法保证最后发送的ACK报文会一定被对方收到,所以需要重发可能丢失的ACK报文<br>关闭连接后可能在相同的IP地址和端口建立新连接,为了防止旧连接的重复分组在新连接再现,2MSL足以让分组最多存活2msl秒被丢弃</p><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><p><strong>URI和URL</strong></p><p>URI是统一资源标识符,而URL是统一资源定位符.每个URL都是URI,但不一定每个URI都是URL.这是因为URI还包括一个子类,即统一资源名称(URN),它命名资源但不指定如何定位资源</p><p><strong>TCP和UDP</strong></p><p>（1）TCP是面向连接的(在客户端和服务器之间传输数据之前要先建立连接),UDP是无连接的(发送数据之前不需要先建立连接)</p><p>（2）TCP提供可靠的服务(通过TCP传输的数据,无差错,不丢失,不重复,且按序到达);UDP提供面向事务的简单的不可靠的传输</p><p>（3）UDP具有较好的实时性,工作效率比TCP高,适用于对高速传输和实时性比较高的通讯或广播通信.随着网速的提高,UDP使用越来越多</p><p>（4）每一条TCP连接只能是点到点的,UDP支持一对一,一对多和多对多的交互通信</p><p>（5）TCP对系统资源要求比较多,UDP对系统资源要求比较少</p><p>（6）UDP程序结构更加简单</p><p>（7）TCP是流模式,UDP是数据报模式</p><p><strong>请求头内容</strong></p><p>1）Accept 作用: 浏览器端可以接受的媒体类型 例: Accept: text/html </p><p>2）Accept-Encoding 作用: 浏览器申明自己接收的编码方法,通常指定压缩方法,是否支持压缩,支持什么压缩方法(gzip,deflate)</p><p>3）Accept-Language 作用: 浏览器申明自己接收的语言.例: Accept-Language: en-us</p><p>4）Connection 例如: Connection: keep-alive 当一个网页打开完成后,客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭,如果客户端再次访问这个服务器上的网页,会继续使用这一条已经建立的连接</p><p>5）Host(发送请求时,该报头域是必需的) 作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号,它通常从HTTP URL中提取出来的</p><p>6）Referer 作用: 当浏览器向web服务器发送请求的时候,一般会带上Referer,告诉服务器我是从哪个页面链接过来的</p><p>7）User-Agent 作用: 告诉HTTP服务器,客户端使用的操作系统和浏览器的名称和版本</p><p><strong>浏览器f5和强制刷新ctrl+f5</strong></p><ol><li>F5使用缓存,并且只有在资源内容发生变化的时候才会去更新资源.</li></ol><p>当刷新一个页面的时,浏览器会尝试使用各种类型的缓存,并发送If-Modified-Since头到服务器,如果服务器返回304 Not Modified,那么浏览器会使用本地的缓存;如果服务器返回200 OK和资源内容,那么浏览器会使用返回的资源内容,并把资源内容进行缓存,待下次使用.</p><ol start="2"><li>CTRL-F5 强制更新页面资源的缓存</li></ol><p>MSIE会发送Cache-Control: no-cache头,Firefox和Chrome除了发送Cache-Control: no-cache头之外,还会发送Pragma: no-cache头.Opera比较另类,不发送任何和缓存相关的头</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 初步了解</title>
      <link href="/2020/12/20/12.webpack-ru-men/"/>
      <url>/2020/12/20/12.webpack-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Webpack 是一种前端资源构建工具，一个静态模块打包器。当 Webpack 处理应用程序时，前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理，它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源。</p><p><img src="1.jpg"></p><h2 id="二、Webpack-五个核心概念"><a href="#二、Webpack-五个核心概念" class="headerlink" title="二、Webpack 五个核心概念"></a>二、Webpack 五个核心概念</h2><h3 id="2-1-Entry"><a href="#2-1-Entry" class="headerlink" title="2.1 Entry"></a>2.1 Entry</h3><p>入口(Entry)指示Webpack以哪个文件作为入口起点分析构建内部依赖图并进行打包。</p><h3 id="2-2-Output"><a href="#2-2-Output" class="headerlink" title="2.2 Output"></a>2.2 Output</h3><p>输出(Output)指示Webpack打包后的资源bundles输出到哪里去，以及如何命名。</p><h3 id="2-3-Loader"><a href="#2-3-Loader" class="headerlink" title="2.3 Loader"></a>2.3 Loader</h3><p>Loader让Webpack能够去处理那些非JavaScript语言的文件，Webpack本身只能理解JavaScript。</p><h3 id="2-4-Plugin"><a href="#2-4-Plugin" class="headerlink" title="2.4 Plugin"></a>2.4 Plugin</h3><p>插件(Plugins)可以用于执行范围更广的任务，插件的范围包括从打包和压缩，一直到重新定义环境中的变量等。</p><h3 id="2-5-Mode"><a href="#2-5-Mode" class="headerlink" title="2.5 Mode"></a>2.5 Mode</h3><p>模式(Mode)指示Webpack使用相应模式的配置。分为development和production两种模式，下面分别进行简述。</p><ul><li><strong>development:</strong> 开发模式，能让代码本地运行的环境，会将process.env.NODE_ENV的值设为development，同时启用NamedChunksPlugin和NamedModulesPlugin插件；</li><li><strong>production:</strong> 生产模式，能让代码优化运行的环境，会将process.env.NODE_ENV的值设为production，同时启用FlagDependencyUsagePlugin、FlagIncludedChunksPlugin、ModuleConcatenationPlugin、NoEmitreplaceStringsPlugin、OccurrenceOrderPlugin、SideEffectsFlagPlugin和UglifyJsPlugin插件。</li></ul><h2 id="三、Webpack-配置"><a href="#三、Webpack-配置" class="headerlink" title="三、Webpack 配置"></a>三、Webpack 配置</h2><h3 id="3-1-webpack-config-js-文件"><a href="#3-1-webpack-config-js-文件" class="headerlink" title="3.1 webpack.config.js 文件"></a>3.1 webpack.config.js 文件</h3><p>webpack.config.js是webpack的配置文件，用来指示webpack工作，运行webpack指令时，会加载里面的配置，所有构建工具都是基于nodejs平台运行的，默认采用commonjs模块化。</p><p><img src="3.1.jpg"></p><h3 id="3-2-devServer-配置"><a href="#3-2-devServer-配置" class="headerlink" title="3.2 devServer 配置"></a>3.2 devServer 配置</h3><p>开发服务器(devServer)用来实现自动化(自动编译、自动打开浏览器、自动刷新浏览器)，只会在内存中编译打包，不会有任何文件输出，本地安装webpack-dev-server后，通过npx webpack-dev-server命令启动devServer。</p><p><img src="3.2.jpg"></p><h3 id="3-3-打包-html-样式-图片-其它资源"><a href="#3-3-打包-html-样式-图片-其它资源" class="headerlink" title="3.3 打包 html/样式/图片/其它资源"></a>3.3 打包 html/样式/图片/其它资源</h3><p>打包不同的资源会使用不同的loader和插件，打包html/样式/图片/其它资源的流程如下所述。</p><h4 id="3-3-1-打包-html-资源"><a href="#3-3-1-打包-html-资源" class="headerlink" title="3.3.1 打包 html 资源"></a>3.3.1 打包 html 资源</h4><p>1.下载html-webpack-plugin插件；</p><p>2.引入html-webpack-plugin插件；</p><p>3.使用html-webpack-plugin插件，并进行相应配置。</p><h4 id="3-3-2-打包样式资源"><a href="#3-3-2-打包样式资源" class="headerlink" title="3.3.2 打包样式资源"></a>3.3.2 打包样式资源</h4><p>不同的样式文件需要配置不同的loader</p><p>1.下载loader；</p><p>2.配置loader，css样式文件使用css-loader和style-loader，less文件使用less-loader、css-loader和style-loader。其中css-loader的作用是将css文件变成commonjs模块加载到js文件中，style-loader的作用是创建style标签，将js中的样式资源插入进去，添加到head中生效。</p><h4 id="3-3-3-打包图片资源"><a href="#3-3-3-打包图片资源" class="headerlink" title="3.3.3 打包图片资源"></a>3.3.3 打包图片资源</h4><p>1.下载url-loader，file-loader</p><p>2.配置loader</p><h4 id="3-3-4-打包其它资源"><a href="#3-3-4-打包其它资源" class="headerlink" title="3.3.4 打包其它资源"></a>3.3.4 打包其它资源</h4><ol><li><p>下载file-loader</p></li><li><p>配置loader，配置该loader作用于不为html/css/less/js的其他文件</p></li></ol><h3 id="3-4-提取css成单独文件-css兼容性处理-压缩css"><a href="#3-4-提取css成单独文件-css兼容性处理-压缩css" class="headerlink" title="3.4 提取css成单独文件/css兼容性处理/压缩css"></a>3.4 提取css成单独文件/css兼容性处理/压缩css</h3><h4 id="3-4-1-提取-css-成单独文件"><a href="#3-4-1-提取-css-成单独文件" class="headerlink" title="3.4.1 提取 css 成单独文件"></a>3.4.1 提取 css 成单独文件</h4><p>样式文件打包后会默认和js文件一起输出，可以通过插件将打包后的css文件单独输出，流程如下所述。</p><p>1.下载mini-css-extract-plugin插件</p><p>2.引用该插件</p><p>3.配置</p><h4 id="3-4-2-css-兼容性处理"><a href="#3-4-2-css-兼容性处理" class="headerlink" title="3.4.2 css 兼容性处理"></a>3.4.2 css 兼容性处理</h4><p>1.下载postcss-loader和postcss-preset-env</p><p>2.在package.json中browsetslist属性中分别对开发环境和生产环境进行兼容性配置，设置支持样式的浏览器版本</p><p>3.通过postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式。</p><h4 id="3-4-3-压缩-css"><a href="#3-4-3-压缩-css" class="headerlink" title="3.4.3 压缩 css"></a>3.4.3 压缩 css</h4><p>1.下载optimize-css-assets-webpack-plugin插件</p><p>2.引用该插件</p><p>3.使用该插件</p><h3 id="3-5-js语法检查eslint-js兼容性处理-js压缩"><a href="#3-5-js语法检查eslint-js兼容性处理-js压缩" class="headerlink" title="3.5 js语法检查eslint/js兼容性处理/js压缩"></a>3.5 js语法检查eslint/js兼容性处理/js压缩</h3><h4 id="3-5-1-js-语法检查-eslint"><a href="#3-5-1-js-语法检查-eslint" class="headerlink" title="3.5.1 js 语法检查 eslint"></a>3.5.1 js 语法检查 eslint</h4><p>1.下载eslint-loader和eslint</p><p>2.在package.json中的eslintConfig中进行配置</p><p>3.配置eslint-loader，其中只需检测js文件并要排除第三方库，只检测自己写的源代码，同时可在options配置中设置fix:true，自动修复eslint的错误。</p><h4 id="3-5-2-js-兼容性处理"><a href="#3-5-2-js-兼容性处理" class="headerlink" title="3.5.2 js 兼容性处理"></a>3.5.2 js 兼容性处理</h4><ol><li><p>下载babel-loader、@babel/core、@babel/preset-env，通过@babel/preset-env做基本的js兼容性处理，然后通过corejs做前面无法实现的兼容性处理，并实现按需加载</p></li><li><p>配置loader</p></li></ol><p><img src="3.5.2.jpg"></p><h4 id="3-5-3-js-压缩"><a href="#3-5-3-js-压缩" class="headerlink" title="3.5.3 js 压缩"></a>3.5.3 js 压缩</h4><p>mode设置为production生产环境时会自动压缩js代码。</p><h2 id="四、webpack-性能优化"><a href="#四、webpack-性能优化" class="headerlink" title="四、webpack 性能优化"></a>四、webpack 性能优化</h2><p>可以从开发环境和生产环境分别对webpack进行性能优化。开发环境主要考虑从打包构建速度和代码调试两个方面进行优化，生产环境主要考虑从打包构建速度和代码运行性能两个方面进行优化。下面简单介绍下开发环境上通过HMR提升构建速度。</p><h3 id="4-1-HMR"><a href="#4-1-HMR" class="headerlink" title="4.1 HMR"></a>4.1 HMR</h3><p>HMR(热模块替换)，作用是一个模块发生变化后，只会更新打包这一个模块而不是所有模块，通过在devServer中设置hot:true属性启动HMR功能。</p><p>对于样式文件，可用HMR功能，因为style-loader内部实现了；</p><p>对于js文件，默认不能用HMR功能，解决方法：修改入口文件js代码，添加支持HMR功能的代码，另外HMR只能处理非入口js文件的其他文件，对入口文件不生效，因为一旦入口文件更新，入口文件引入的其他文件一定会被重新加载；</p><p>对于html文件，默认不能使用HMR功能，同时会导致html文件不能热更新，解决方法：修改entry入口文件，将html文件引入，只能解决html文件不能热更新的问题。</p><p><img src="4.1.jpg"></p><h3 id="4-2-HMR-效果"><a href="#4-2-HMR-效果" class="headerlink" title="4.2 HMR 效果"></a>4.2 HMR 效果</h3><p>在入口index.js文件中引入print.js文件，运行npx webpack-devserver后，页面如图：</p><p><img src="4.2.1.jpg"></p><p>修改print.js文件后，只会重新加载print.js文件，不会重新加载index.js文件，HMR效果如图：</p><p><img src="4.2.2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6特性语法汇总</title>
      <link href="/2020/12/18/11.es6/"/>
      <url>/2020/12/18/11.es6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、兼容性"><a href="#一、兼容性" class="headerlink" title="一、兼容性"></a>一、兼容性</h2><p>目前各大浏览器基本上都支持 ES6 的新特性，其中 Chrome 和 Firefox 浏览器对 ES6 新特性最友好，IE7~11 基本不支持 ES6。</p><p>以下是各大浏览器支持情况及开始时间：</p><p><img src="1.png"></p><h2 id="二、let-与-const"><a href="#二、let-与-const" class="headerlink" title="二、let 与 const"></a>二、let 与 const</h2><blockquote><p>let声明变量，const声明常量：两个都有块级作用域，ES5没有块级作用域。</p></blockquote><p>①变量提升(变量可在声明前使用,值为undefined): let,const不行,var可以,并将申明的变量挂载在window上。</p><p>②块级作用域: let和const只在块级作用域中有效,存在暂存死区,var不是。</p><p>③重复声明: 同一作用域下let和const命令都不允许重复声明同一个变量,var可以但不建议这么做。</p><p>④初始值: const一旦声明必须赋初始值,且声明后不许改变,如果声明的是复合类型数据,可以修改其属性,因为const只是指向对象的地址,地址不变,地址指向的内容是可以改变的。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// var: 输出十个10</span><span class="token comment" spellcheck="true">// 因为所有j都使用同一个引用,而j最终会被更新为10</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出: 0123456789</span><span class="token comment" spellcheck="true">// let不会在栈内存里预分配内存空间,在栈内存分配变量时检查是否存在相同变量名,有就报错,也就是暂时性死区</span><span class="token comment" spellcheck="true">// 块级作用域中let命令所声明的变量不受外部影响</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出 0</span><span class="token comment" spellcheck="true">// const声明后不许改变,所以为初始赋值0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、解构赋值"><a href="#三、解构赋值" class="headerlink" title="三、解构赋值"></a>三、解构赋值</h2><blockquote><p>针对<strong>数组</strong>或<strong>对象</strong>进行匹配，然后对其中的变量进行赋值。常用于交换变量值，取函数返回值，设置默认值。</p></blockquote><h3 id="3-1-数组的解构赋值（Array）"><a href="#3-1-数组的解构赋值（Array）" class="headerlink" title="3.1 数组的解构赋值（Array）"></a>3.1 数组的解构赋值（Array）</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 基本</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1  b = 2  c = 3</span><span class="token comment" spellcheck="true">// 可嵌套</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1  b = 2  c = 3</span><span class="token comment" spellcheck="true">// 可忽略</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1  b = 3</span><span class="token comment" spellcheck="true">// 不完全解构</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1, b = undefined</span><span class="token comment" spellcheck="true">// 剩余运算符</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a = 1  b = [2, 3]</span><span class="token comment" spellcheck="true">// 字符串等</span><span class="token comment" spellcheck="true">// 在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 'h'  b = 'e'  c = 'l'  d = 'l'  e = 'o'</span><span class="token comment" spellcheck="true">// 解构默认值</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>undefined<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 2</span><span class="token comment" spellcheck="true">// 当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 3, b = 3 </span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1, b = 1 </span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1, b = 2</span><span class="token comment" spellcheck="true">// a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3</span><span class="token comment" spellcheck="true">// a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a = 1</span><span class="token comment" spellcheck="true">// a 与 b 正常解构赋值，匹配结果：a = 1，b = 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-对象的解构赋值（Object）"><a href="#3-2-对象的解构赋值（Object）" class="headerlink" title="3.2 对象的解构赋值（Object）"></a>3.2 对象的解构赋值（Object）</h3><p><strong>基本</strong></p><p><code>let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; // foo = 'aaa' // bar = 'bbb'  let { baz : foo } = { baz : 'ddd' }; // foo = 'ddd'</code></p><p><strong>可嵌套可忽略</strong></p><p><code>let obj = {p: ['hello', {y: 'world'}] }; let {p: [x, { y }] } = obj; // x = 'hello' // y = 'world' let obj = {p: ['hello', {y: 'world'}] }; let {p: [x, {  }] } = obj; // x = 'hello'</code></p><p><strong>不完全解构</strong></p><p><code>let obj = {p: [{y: 'world'}] }; let {p: [{ y }, x ] } = obj; // x = undefined // y = 'world'</code></p><p><strong>剩余运算符</strong></p><p><code>let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}; // a = 10 // b = 20 // rest = {c: 30, d: 40}</code></p><p><strong>解构默认值</strong></p><p><code>let {a = 10, b = 5} = {a: 3}; // a = 3; b = 5; let {a: aa = 10, b: bb = 5} = {a: 3}; // aa = 3; bb = 5;</code></p><h2 id="四、Symbol"><a href="#四、Symbol" class="headerlink" title="四、Symbol"></a>四、Symbol</h2><blockquote><p>ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。</p></blockquote><p><strong>作为属性名：</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> sy <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 写法1 </span><span class="token keyword">let</span> syObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> syObject<span class="token punctuation">[</span>sy<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"kk"</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>syObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {Symbol(key1): "kk"} </span><span class="token comment" spellcheck="true">// 写法2 </span><span class="token keyword">let</span> syObject <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>sy<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"kk"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>syObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {Symbol(key1): "kk"} </span><span class="token comment" spellcheck="true">// 写法3 </span><span class="token keyword">let</span> syObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>syObject<span class="token punctuation">,</span> sy<span class="token punctuation">,</span> <span class="token punctuation">{</span>value<span class="token punctuation">:</span> <span class="token string">"kk"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>syObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {Symbol(key1): "kk"}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、Map-与-Set"><a href="#五、Map-与-Set" class="headerlink" title="五、Map 与 Set"></a>五、Map 与 Set</h2><p><strong>应用场景：Set用于数据重组，Map用于数据储存</strong></p><p>　　<strong>Set:</strong>　</p><p>　　<strong>（1）成员不能重复</strong></p><p>　　<strong>（2）只有键值没有键名,类似数组</strong></p><p>　　<strong>（3）可以遍历,方法有add,delete,has</strong></p><p>　　<strong>Map:</strong></p><p>　　<strong>（1）本质上是健值对的集合,类似集合</strong></p><p>　　<strong>（2）可以遍历,可以跟各种数据格式转换</strong></p><h3 id="5-1-Map-对象"><a href="#5-1-Map-对象" class="headerlink" title="5.1 Map 对象"></a>5.1 Map 对象</h3><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><p><strong>Maps 和 Objects 的区别：</strong></p><ul><li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li><li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li><li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li><li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul><h3 id="5-2-Map-中的-key"><a href="#5-2-Map-中的-key" class="headerlink" title="5.2 Map 中的 key"></a>5.2 Map 中的 key</h3><p><strong>key 是字符串</strong></p><pre><code>var myMap = new Map(); var keyString = "a string";   myMap.set(keyString, "和键'a string'关联的值");  myMap.get(keyString); // "和键'a string'关联的值" myMap.get("a string"); // "和键'a string'关联的值" 因为 keyString === 'a string'</code></pre><p><strong>key 是对象</strong></p><pre><code>var myMap = new Map(); var keyObj = {},   myMap.set(keyObj, "和键 keyObj 关联的值");  myMap.get(keyObj); // "和键 keyObj 关联的值" myMap.get({}); // undefined, 因为 keyObj !== {}</code></pre><p><strong>key 是函数</strong></p><pre><code>var myMap = new Map(); var keyFunc = function () {}, // 函数 myMap.set(keyFunc, "和键 keyFunc 关联的值");  myMap.get(keyFunc); // "和键 keyFunc 关联的值" myMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}</code></pre><p><strong>key 是 NaN</strong></p><pre><code>var myMap = new Map(); myMap.set(NaN, "not a number");  myMap.get(NaN); // "not a number"  var otherNaN = Number("foo"); myMap.get(otherNaN); // "not a number"</code></pre><p>虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。</p><h3 id="5-3-Map-的迭代"><a href="#5-3-Map-的迭代" class="headerlink" title="5.3 Map 的迭代"></a>5.3 Map 的迭代</h3><p>对 Map 进行遍历，以下两个最高级。</p><h4 id="5-3-1-for…of"><a href="#5-3-1-for…of" class="headerlink" title="5.3.1 for…of"></a>5.3.1 for…of</h4><p>可以遍历数组，Set和Map结构，某些类数组对象，以及字符串。</p><pre><code>var myMap = new Map(); myMap.set(0, "zero"); myMap.set(1, "one"); // 将会显示两个 log。 一个是 "0 = zero" 另一个是 "1 = one" for (var [key, value] of myMap) {    console.log(key + " = " + value);} for (var [key, value] of myMap.entries()) {   console.log(key + " = " + value); } /* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */  // 将会显示两个log。 一个是 "0" 另一个是 "1" for (var key of myMap.keys()) {    console.log(key); } /* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */  // 将会显示两个log。 一个是 "zero" 另一个是 "one" for (var value of myMap.values()) {    console.log(value); } /* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。*/</code></pre><h4 id="5-3-2-forEach"><a href="#5-3-2-forEach" class="headerlink" title="5.3.2 forEach()"></a>5.3.2 forEach()</h4><pre><code>var myMap = new Map(); myMap.set(0, "zero"); myMap.set(1, "one");  // 将会显示两个 logs。 一个是 "0 = zero" 另一个是 "1 = one" myMap.forEach(function(value, key) {    console.log(key + " = " + value); }, myMap)</code></pre><h3 id="5-4-Map-对象的操作"><a href="#5-4-Map-对象的操作" class="headerlink" title="5.4 Map 对象的操作"></a>5.4 Map 对象的操作</h3><p><strong>Map 与 Array的转换</strong></p><pre><code>var kvArray = [["key1", "value1"], ["key2", "value2"]];  // Map 构造函数可以将一个二维键值对数组转换成一个 Map 对象 var myMap = new Map(kvArray);  // 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组var outArray = Array.from(myMap);</code></pre><p><strong>Map 的克隆</strong></p><pre><code>var myMap1 = new Map([["key1", "value1"], ["key2", "value2"]]); var myMap2 = new Map(myMap1);  console.log(original === clone);  // 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</code></pre><p><strong>Map 的合并</strong></p><pre><code>var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]); var second = new Map([[1, 'uno'], [2, 'dos']]);  // 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three var merged = new Map([...first, ...second]);</code></pre><h3 id="5-5-Set-对象"><a href="#5-5-Set-对象" class="headerlink" title="5.5 Set 对象"></a>5.5 Set 对象</h3><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p><h3 id="5-6-类型转换"><a href="#5-6-类型转换" class="headerlink" title="5.6 类型转换"></a>5.6 类型转换</h3><p><strong>Array</strong></p><pre><code>// Array 转 Set var mySet = new Set(["value1", "value2", "value3"]); // 用...操作符，将 Set 转 Array var myArray = [...mySet]; String // String 转 Set var mySet = new Set('hello'); // Set(4) {"h", "e", "l", "o"}// 注：Set 中 toString 方法是不能将 Set 转换成 String</code></pre><h3 id="5-7-数组去重"><a href="#5-7-数组去重" class="headerlink" title="5.7 数组去重"></a>5.7 数组去重</h3><pre><code>var mySet = new Set([1, 2, 3, 4, 4]); [...mySet]; // [1, 2, 3, 4]</code></pre><h3 id="5-8-并集"><a href="#5-8-并集" class="headerlink" title="5.8 并集"></a>5.8 并集</h3><pre><code>var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var union = new Set([...a, ...b]); // {1, 2, 3, 4}</code></pre><h3 id="5-9-交集"><a href="#5-9-交集" class="headerlink" title="5.9 交集"></a>5.9 交集</h3><pre><code>var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var intersect = new Set([...a].filter(x =&gt; b.has(x))); // {2, 3}</code></pre><h3 id="5-10-差集"><a href="#5-10-差集" class="headerlink" title="5.10 差集"></a>5.10 差集</h3><pre><code>var a = new Set([1, 2, 3]);var b = new Set([4, 3, 2]); var difference = new Set([...a].filter(x =&gt; !b.has(x))); // {1}</code></pre><h2 id="六、Reflect-与-Proxy"><a href="#六、Reflect-与-Proxy" class="headerlink" title="六、Reflect 与 Proxy"></a>六、Reflect 与 Proxy</h2><p>Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。</p><p>Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。</p><p>Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。</p><h3 id="6-1-Proxy"><a href="#6-1-Proxy" class="headerlink" title="6.1 Proxy"></a>6.1 Proxy</h3><p>一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p><pre><code>let target = {    name: 'Tom',    age: 24}let handler = {    get: function(target, key) {        console.log('getting '+key);        return target[key]; // 不是target.key    },    set: function(target, key, value) {        console.log('setting '+key);        target[key] = value;    }}let proxy = new Proxy(target, handler)proxy.name     // 实际执行 handler.getproxy.age = 25 // 实际执行 handler.set// getting name// setting age// 25// target 可以为空对象let targetEpt = {}let proxyEpt = new Proxy(targetEpt, handler)// 调用 get 方法，此时目标对象为空，没有 name 属性proxyEpt.name // getting name// 调用 set 方法，向目标对象中添加了 name 属性proxyEpt.name = 'Tom'// setting name// "Tom"// 再次调用 get ，此时已经存在 name 属性proxyEpt.name// getting name// "Tom"// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相// 影响targetEpt)// {name: "Tom"}// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象let targetEmpty = {}let proxyEmpty = new Proxy(targetEmpty,{})proxyEmpty.name = "Tom"targetEmpty) // {name: "Tom"}</code></pre><h3 id="6-2-Reflect"><a href="#6-2-Reflect" class="headerlink" title="6.2 Reflect"></a>6.2 Reflect</h3><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p><p>Reflect 对象对某些方法的返回结果进行了修改，使其更合理。</p><p>Reflect 对象使用函数的方式实现了 Object 的命令式操作。</p><p><strong>静态方法</strong></p><pre><code>Reflect.get(target, name, receiver)</code></pre><p>查找并返回 target 对象的 name 属性。</p><pre><code>let exam = {    name: "Tom",    age: 24,    get info(){        return this.name + this.age;    }}Reflect.get(exam, 'name'); // "Tom"// 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiverlet receiver = {    name: "Jerry",    age: 20}Reflect.get(exam, 'info', receiver); // Jerry20// 当 name 为不存在于 target 对象的属性时，返回 undefinedReflect.get(exam, 'birth'); // undefined// 当 target 不是对象时，会报错Reflect.get(1, 'name'); // TypeError</code></pre><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><p>ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。</p><ul><li>**includes()**：返回布尔值，判断是否找到参数字符串。</li><li>**startsWith()**：返回布尔值，判断参数字符串是否在原字符串的头部。</li><li>**endsWith()**：返回布尔值，判断参数字符串是否在原字符串的尾部。</li></ul><p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p><pre><code>let string = "apple,banana,orange";string.includes("banana");     // truestring.startsWith("apple");    // truestring.endsWith("apple");      // falsestring.startsWith("banana",6)  // true</code></pre><p><strong>注意点：</strong></p><ul><li>这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。</li><li>这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。</li></ul><h3 id="7-1-字符串重复"><a href="#7-1-字符串重复" class="headerlink" title="7.1 字符串重复"></a>7.1 字符串重复</h3><p>repeat()：返回新的字符串，表示将字符串重复指定次数返回。</p><pre><code>console.log("Hello,".repeat(2));  // "Hello,Hello,"</code></pre><p>如果参数是小数，向下取整</p><pre><code>console.log("Hello,".repeat(3.2));  // "Hello,Hello,Hello,"</code></pre><p>如果参数是 0 至 -1 之间的小数，会进行取整运算，0 至 -1 之间的小数取整得到 -0 ，等同于 repeat 零次</p><pre><code>console.log("Hello,".repeat(-0.5));  // "" </code></pre><p>如果参数是 NaN，等同于 repeat 零次</p><pre><code>console.log("Hello,".repeat(NaN));  // "" </code></pre><p>如果参数是负数或者 Infinity ，会报错:</p><pre><code>console.log("Hello,".repeat(-1));  // RangeError: Invalid count valueconsole.log("Hello,".repeat(Infinity));  // RangeError: Invalid count value</code></pre><p>如果传入的参数是字符串，则会先将字符串转化为数字</p><pre><code>console.log("Hello,".repeat("hh")); // ""console.log("Hello,".repeat("2"));  // "Hello,Hello,"</code></pre><h3 id="7-2-字符串补全"><a href="#7-2-字符串补全" class="headerlink" title="7.2 字符串补全"></a>7.2 字符串补全</h3><ul><li><strong>padStart</strong>：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</li><li><strong>padEnd</strong>：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。</li></ul><p>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</p><pre><code>console.log("h".padStart(5,"o"));  // "ooooh"console.log("h".padEnd(5,"o"));    // "hoooo"console.log("h".padStart(5));      // "    h"</code></pre><p>如果指定的长度小于或者等于原字符串的长度，则返回原字符串:</p><pre><code>console.log("hello".padStart(5,"A"));  // "hello"</code></pre><p>如果原字符串加上补全字符串长度大于指定长度，则截去超出位数的补全字符串:</p><pre><code>console.log("hello".padEnd(10,",world!"));  // "hello,worl"</code></pre><p>常用于补全位数：</p><pre><code>console.log("123".padStart(10,"0"));  // "0000000123"</code></pre><h3 id="7-3-模板字符串"><a href="#7-3-模板字符串" class="headerlink" title="7.3 模板字符串"></a>7.3 模板字符串</h3><p>模板字符串相当于加强版的字符串，<code>${}</code> 拼接参数，可以在字符串中加入变量和表达式。</p><p><strong>基本用法</strong></p><p>普通字符串</p><pre><code>let string = `Hello'\n'world`; console.log(string);  // "Hello'// 'world"</code></pre><p>多行字符串:</p><pre><code>let string1 =  `Hey, can you stop angry now?`; console.log(string1); // Hey, // can you stop angry now?</code></pre><p>字符串插入变量和表达式。</p><p>变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。</p><pre><code>let name = "Mike"; let age = 27; let info = `My Name is ${name},I am ${age+1} years old next year.` console.log(info); // My Name is Mike,I am 28 years old next year.</code></pre><p>字符串中调用函数：</p><pre><code>function f(){  return "have fun!"; } let string2= `Game start,${f()}`; console.log(string2);  // Game start,have fun!</code></pre><p><strong>注意要点</strong></p><p>模板字符串中的换行和空格都是会被保留的</p><p><strong>应用</strong></p><p>过滤 HTML 字符串，防止用户输入恶意内容。</p><pre><code>function f(stringArr,...values){ let result = ""; for(let i=0;i&lt;stringArr.length;i++){  result += stringArr[i];   if(values[i]){     result += String(values[i]).replace(/&amp;/g, "&amp;amp;")               .replace(/&lt;/g, "&amp;lt;")               .replace(/&gt;/g, "&amp;gt;");    } } return result;}name = '&lt;Amy&amp;MIke&gt;';f`&lt;p&gt;Hi, ${name}.I would like send you some message.&lt;/p&gt;`;// &lt;p&gt;Hi, &amp;lt;Amy&amp;amp;MIke&amp;gt;.I would like send you some message.&lt;/p&gt;</code></pre><p><strong>国际化处理（转化多国语言）</strong></p><pre><code>i18n`Hello ${name}, you are visitor number ${visitorNumber}.`;  // 你好**，你是第**位访问者</code></pre><h2 id="八、箭头函数"><a href="#八、箭头函数" class="headerlink" title="八、箭头函数"></a>八、箭头函数</h2><p>箭头函数：省去function关键字,用 () = &gt; 来定义，函数的参数放在箭头前的括号，函数体在箭头后的花括号。</p><p>它的 this 继承了外层执行环境的 this，不能被 call() apply() bind() 改变指向。</p><p>没有自己的arguments，用rest参数代替arguments对象，来访问箭头函数的参数列表。</p><p>没有原型prototype，打印显示undefined。</p><p>不能用作Generator函数，所以不能使用yeild关键字。</p><p>不能用作构造函数,也就是说不能使用new命令,否则报错</p><p><strong>适合使用的场景：</strong></p><p>ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。</p><p><strong>不适合使用的场景：</strong></p><p>定义函数的方法，且该方法中包含 this 或需要动态 this 的时候。</p><h2 id="九、…-拓展运算符"><a href="#九、…-拓展运算符" class="headerlink" title="九、… 拓展运算符"></a>九、… 拓展运算符</h2><p>将数组或对象里面的值展开,还可以将多个值收集为一个变量，代替argument对象。</p><h2 id="十、Iterator-迭代器"><a href="#十、Iterator-迭代器" class="headerlink" title="十、Iterator 迭代器"></a>十、Iterator 迭代器</h2><p>Iterator 是 ES6 引入的一种新的遍历机制，迭代器有两个核心概念：</p><ul><li>迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为Symbol.iterator 的方法来实现。</li><li>迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。</li></ul><p>迭代的过程如下：</p><ul><li>通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置</li><li>随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束</li><li>当 done 为 true 时则遍历结束<br>```javascript<br>const items = [“zero”, “one”, “two”];<br>const it = items<a href="">Symbol.iterator</a>;</li></ul><p>it.next();</p><blockquote><p>{value: “zero”, done: false}<br>it.next();<br>{value: “one”, done: false}<br>it.next();<br>{value: “two”, done: false}<br>it.next();<br>{value: undefined, done: true}</p></blockquote><pre><code>上面的例子，首先创建一个数组，然后通过 Symbol.iterator 方法创建一个迭代器，之后不断的调用 next 方法对数组内部项进行访问，当属性 done 为 true 时访问结束。迭代器是协议（使用它们的规则）的一部分，用于迭代。该协议的一个关键特性就是它是顺序的：迭代器一次返回一个值。这意味着如果可迭代数据结构是非线性的（例如树），迭代将会使其线性化。**可迭代的数据结构：**以下是可迭代的值:- Array- String- Map- Set- Dom元素（正在进行中）## 十一、Class 类在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。class 的本质是 function。它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。定义类更简便地实现类的继承。**类定义**类表达式可以为匿名或命名。</code></pre><p>// 匿名类<br>let Example = class {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}<br>// 命名类<br>let Example = class Example {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}</p><pre><code>**类声明**</code></pre><p>class Example {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}</p><pre><code>**注意要点：**不可重复声明。方法间不能加分号。类中方法不需要 function 关键字。类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。修饰器@: decorator是一个函数，用来修改类甚至于是方法的行为，修饰器本质就是编译时执行的函数。**属性**prototype，ES6 中，prototype 仍旧存在，虽然可以直接自类中定义方法，但是其实方法还是定义在 prototype 上的。 覆盖方法 / 初始化时添加方法。</code></pre><p>Example.prototype={<br>    //methods<br>}</p><pre><code>添加方法</code></pre><p>Object.assign(Example.prototype,{<br>    //methods<br>})</p><pre><code>静态属性：class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。</code></pre><p>class Example {<br>// 新提案<br>    static a = 2;<br>}<br>// 目前可行写法<br>Example.b = 2;</p><pre><code>公共属性</code></pre><p>class Example{}<br>Example.prototype.a = 2;</p><pre><code>实例属性：定义在实例对象（ this ）上的属性。</code></pre><p>class Example {<br>    a = 2;<br>    constructor () {<br>        console.log(this.a);<br>    }<br>}</p><pre><code>name 属性，返回跟在 class 后的类名(存在时)。</code></pre><p>let Example=class Exam {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}<br>console.log(Example.name); // Exam</p><p>let Example=class {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}<br>console.log(Example.name); // Example</p><pre><code>constructor 方法是类的默认方法，创建类的实例化对象时被调用。</code></pre><p>class Example{<br>    constructor(){<br>      console.log(‘我是constructor’);<br>    }<br>}<br>new Example(); // 我是constructor</p><pre><code>返回对象</code></pre><p>class Test {<br>    constructor(){<br>        // 默认返回实例对象 this<br>    }<br>}<br>console.log(new Test() instanceof Test); // true</p><p>class Example {<br>    constructor(){<br>        // 指定返回对象<br>        return new Test();<br>    }<br>}<br>console.log(new Example() instanceof Example); // false</p><pre><code>静态方法</code></pre><p>class Example{<br>    static sum(a, b) {<br>        console.log(a+b);<br>    }<br>}<br>Example.sum(1, 2); // 3</p><pre><code>原型方法</code></pre><p>class Example {<br>    sum(a, b) {<br>        console.log(a + b);<br>    }<br>}<br>let exam = new Example();<br>exam.sum(1, 2); // 3</p><pre><code>实例方法</code></pre><p>class Example {<br>    constructor() {<br>        this.sum = (a, b) =&gt; {<br>            console.log(a + b);<br>        }<br>    }<br>}</p><pre><code>## 十二、模块ES6 模块自动开启严格模式，即使没加 `use strict;`。模块中可以导入和导出各类型变量，如函数，对象，字符串，数字，布尔值，类等。每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。模块导入导出各种类型的变量，如字符串，数值，函数，类。- 导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 - 不仅能导出声明还能导出引用（例如函数）。- export 命令可以出现在模块的任何位置，但必需处于模块顶层。- import 命令会提升到整个模块的头部，首先执行。</code></pre><p>/<em>—–export [test.js]—–</em>/<br>let myName = “Tom”;<br>let myAge = 20;<br>let myfn = function(){<br>    return “My name is” + myName + “! I’m ‘“ + myAge + “years old.”<br>}<br>let myClass =  class myClass {<br>    static a = “yeah!”;<br>}<br>export { myName, myAge, myfn, myClass }</p><p>/<em>—–import [xxx.js]—–</em>/<br>import { myName, myAge, myfn, myClass } from “./test.js”;<br>console.log(myfn());// My name is Tom! I’m 20 years old.<br>console.log(myAge);// 20<br>console.log(myName);// Tom<br>console.log(myClass.a );// yeah!</p><pre><code>建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。不同模块导出接口名称命名重复， 使用 as 重新定义变量名。**export default 命令：**- 在一个文件或模块中，export、import 可以有多个，export default 仅有一个。- export default 中的 default 是对应的导出接口变量。- 通过 export 方式导出，在导入时要加{ }，export default 则不需要。- export default 向外暴露的成员，可以使用任意变量来接收。## 十三、Promise 对象是异步编程的一种解决方案。比传统的解决方案（回调函数和事件）更强大合理。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。**状态的缺点**无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。**then 方法**then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。**then 方法的特点**在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。注意总是返回或终止 Promise 链。</code></pre><p>const p1 = new Promise(function(resolve,reject){<br>  resolve(1);<br>}).then(function(result) {<br>  p2(result).then(newResult =&gt; p3(newResult));<br>}).then(() =&gt; p4());</p><pre><code>创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 `catch(error =&gt; console.log(error));`reject是用来抛出异常,catch是用来处理异常；reject是Promise的方法,而catch是Promise实例的方法；reject后的东西,一定会进入then中的第二个回调,如果then中没有写第二个回调,则进入catch；网络异常(比如断网),会直接进入catch而不会进入then的第二个回调。**手写 promise：**&gt; promise 的三种状态：pending、fulfilled、rejected。```javascriptclass Promise {  constructor(executor) {    // Promise接一个方法  （resolve，reject）=&gt;{}    // 开始的状态    this.state = 'pending'    // 成功的状态    this.value = undefined    // 失败的状态    this.result = undefined    // 状态执行的时候，要立即改变，且不可逆转    const resolve = (value) =&gt; {      if (this.state === 'pending') {        this.state = 'fulfilled'        this.value = value      }    }    const reject = (reason) =&gt; {      if (this.state === 'pending') {        this.state = 'rejected'        this.result = reason      }    }    executor(resolve, reject) //这个方法要立即执行  }  // then接受两个参数，都是方法  then(onFulfilled, onRejected) {    // 如果这样写是同步的，this.state一直是padding的状态    console.log(this.state)    // 如果成功，传入成功的参数    if (this.state === 'fulfilled') {      onFulfilled(this.value)    }    // 如果失败，传入失败的参数    if (this.state === 'rejected') {      onRejected(this.result)    }  }}</code></pre><blockquote><p>上面是同步的，执行 then 方法后，this.state 一直是 pending 的状态。</p><p>发布订阅者模式。</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Promise接一个方法  （resolve，reject）=>{}</span>    <span class="token comment" spellcheck="true">// 开始的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span>    <span class="token comment" spellcheck="true">// 成功的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> undefined    <span class="token comment" spellcheck="true">// 失败的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> undefined    <span class="token comment" spellcheck="true">// 成功的订阅者数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 失败的订阅者数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 状态执行的时候，要立即改变，且不可逆转</span>    <span class="token keyword">const</span> resolve <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value        <span class="token comment" spellcheck="true">// 执行resolve的时候，把 this.onResolvedCallbacks里面的方法全部执行一遍</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> reject <span class="token operator">=</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> reason        <span class="token comment" spellcheck="true">// 执行reject的时候，把 this.onRejectedCallbacks里面的方法全部执行一遍</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这个方法要立即执行</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// then接受两个参数，都是方法</span>  <span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果这样写是同步的，this.state一直是padding的状态</span>    <span class="token comment" spellcheck="true">// 如果成功，传入成功的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'fulfilled'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果失败，传入失败的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'rejected'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 发布订阅者模式</span>    <span class="token comment" spellcheck="true">// 如果状态是   pending</span>    <span class="token comment" spellcheck="true">// 就把要做的方法传入 待发布状态中去</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'padding'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>但是上面没有链式调用。then() 方法后面不能接 then()。</p><p>解决 then() 方法不返回 promise 的问题。</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Promise接一个方法  （resolve，reject）=>{}</span>    <span class="token comment" spellcheck="true">// 开始的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span>    <span class="token comment" spellcheck="true">// 成功的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> undefined    <span class="token comment" spellcheck="true">// 失败的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> undefined    <span class="token comment" spellcheck="true">// 成功的订阅者数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 失败的订阅者数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 状态执行的时候，要立即改变，且不可逆转</span>    <span class="token keyword">const</span> resolve <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value        <span class="token comment" spellcheck="true">// 执行resolve的时候，把 this.onResolvedCallbacks里面的方法全部执行一遍</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> reject <span class="token operator">=</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> reason        <span class="token comment" spellcheck="true">// 执行reject的时候，把 this.onRejectedCallbacks里面的方法全部执行一遍</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这个方法要立即执行</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// then接受两个参数，都是方法</span>  <span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果这样写是同步的，this.state一直是padding的状态</span>    <span class="token comment" spellcheck="true">// 如果成功，传入成功的参数</span>    <span class="token keyword">const</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 解决不能链式调用的问题。需要再返回一个promise</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'fulfilled'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 如果失败，传入失败的参数</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'rejected'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span>          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 发布订阅者模式</span>      <span class="token comment" spellcheck="true">// 如果状态是   padding</span>      <span class="token comment" spellcheck="true">// 就把要做的方法传入 待发布状态中去</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'padding'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> promise2  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义resolvePromise 方法</span><span class="token keyword">const</span> resolvePromise <span class="token operator">=</span> <span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// console.log(promise2, x, resolve, reject)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11111</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'循环引用！'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 判断 x 的类型</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 复杂类型</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 认为这个确实是一个promise</span>        then<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 只能解决一次，如果resolve里面嵌套n个promise</span>          <span class="token comment" spellcheck="true">// resolve(y)</span>          <span class="token comment" spellcheck="true">// 递归解析当前的x</span>          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 基本类型</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十四、Generator-函数"><a href="#十四、Generator-函数" class="headerlink" title="十四、Generator 函数"></a>十四、Generator 函数</h2><p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法：</p><p>Generator 有两个区分于普通函数的部分：</p><ul><li>一是在 function 后面，函数名之前有个 * 。</li><li>函数内部有 yield 表达式。</li></ul><p>其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。</p><pre><code>function* func(){ console.log("one"); yield '1'; console.log("two"); yield '2';  console.log("three"); return '3';}</code></pre><p>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。</p><h2 id="十五、async-函数"><a href="#十五、async-函数" class="headerlink" title="十五、async 函数"></a>十五、async 函数</h2><p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联。通过编写类似同步的代码来处理异步流程，提高代码的简洁性和可读性。</p><pre><code>async function name([param[, param[, ... param]]]) { statements }</code></pre><ul><li>name: 函数名称。</li><li>param: 要传递给函数的参数的名称。</li><li>statements: 函数体语句。</li></ul><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p><pre><code>async function helloAsync(){    return "helloAsync";  }  console.log(helloAsync())  // Promise {&lt;resolved&gt;: "helloAsync"} helloAsync().then(v=&gt;{   console.log(v);         // helloAsync})</code></pre><p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p><p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p><pre><code>function testAwait(){   return new Promise((resolve) =&gt; {       setTimeout(function(){          console.log("testAwait");          resolve();       }, 1000);   });} async function helloAsync(){   await testAwait();   console.log("helloAsync"); }helloAsync();// testAwait// helloAsync</code></pre><p>await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。</p><pre><code>[return_value] = await expression;</code></pre><p>expression: 一个 Promise 对象或者任何要等待的值。</p><p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p><p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</p><pre><code>function testAwait (x) {  return new Promise(resolve =&gt; {    setTimeout(() =&gt; {      resolve(x);    }, 2000);  });} async function helloAsync() {  var x = await testAwait ("hello world");  console.log(x); }helloAsync ();// hello world</code></pre><p>正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。</p><pre><code>function testAwait(){   console.log("testAwait");}async function helloAsync(){   await testAwait();   console.log("helloAsync");}helloAsync();// testAwait// helloAsync</code></pre><p>await针对所跟不同表达式的处理方式：</p><p>Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。<br>非 Promise 对象：直接返回对应的值。</p><p>async较Generator的优势：</p><p>　（1）内置执行器: Generator函数的执行必须依靠执行器,而 Aysnc函数自带执行器,调用方式跟普通函数的调用一样</p><p>　（2）更好的语义: async和await相较于*和yield更加语义化　　</p><p>　（3）更广的适用性: yield命令后面只能是Thunk函数或Promise对象,async函数的await后面可以是Promise也可以是原始类型的值</p><p>​    （4）返回值是 Promise: async函数返回的是Promise对象,比Generator函数返回的Iterator对象方便,可以直接使用then()方法进行调用</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多维数组转一维数组</title>
      <link href="/2020/12/16/10.duo-wei-shu-zu-zhuan-yi-wei/"/>
      <url>/2020/12/16/10.duo-wei-shu-zu-zhuan-yi-wei/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数组的-join"><a href="#一、数组的-join" class="headerlink" title="一、数组的 join()"></a>一、数组的 join()</h2><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、toString"><a href="#二、toString" class="headerlink" title="二、toString()"></a>二、toString()</h2><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、空字符串的方法"><a href="#三、空字符串的方法" class="headerlink" title="三、空字符串的方法"></a>三、空字符串的方法</h2><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"]</span>优化 数组中每项为字符串将其转换成nunber类型 <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"]</span><span class="token keyword">let</span> numberArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 用于存放新的number类型的数组</span>newArr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  numberArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">+</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>numberArr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出为：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、递归调用"><a href="#四、递归调用" class="headerlink" title="四、递归调用"></a>四、递归调用</h2><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 存放转化后的一维数组</span><span class="token keyword">function</span> arrConversion <span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">arrConversion</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      newArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">arrConversion</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、flat"><a href="#五、flat" class="headerlink" title="五、flat()"></a>五、flat()</h2><pre class="line-numbers language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3]</span><span class="token comment" spellcheck="true">// 指定转换的嵌套层数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3, [4, 5]]</span><span class="token comment" spellcheck="true">// 不管嵌套多少层</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3, 4, 5]</span><span class="token comment" spellcheck="true">// 自动跳过空位</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>p<span class="token operator">></span> <span class="token comment" spellcheck="true">// [1, 2, 3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>flatMap()</strong></p><p>先对数组中每个元素进行了的处理，再对数组执行 flat() 方法。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组 // 参数2：指定遍历函数中 this 的指向 </span><span class="token comment" spellcheck="true">// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组</span><span class="token comment" spellcheck="true">// 参数2：指定遍历函数中 this 的指向</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>n <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [2, 4, 6]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>递归调用优化</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">function</span> <span class="token function">change</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">typeof</span> item <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> newArr <span class="token operator">=</span> newArr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">change</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> newArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> newArr<span class="token punctuation">;</span> <span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">change</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Array的flat()实现方式</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1,2,3,4]</span>    <span class="token comment" spellcheck="true">//实现方式1 递归</span>    Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>flat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>idx<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          arr<span class="token operator">=</span>arr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>          arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> arr    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实现方式2</span><span class="token comment" spellcheck="true">//连接数组返回字符串用,进行分割，然后map映射将数组的string转换为number</span>arr<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>flat <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item<span class="token operator">=</span><span class="token operator">></span><span class="token operator">+</span>item<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// map映射: </span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token keyword">var</span> arr2<span class="token operator">=</span>arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">return</span> item<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九种跨域方式及其原理</title>
      <link href="/2020/12/14/09.kua-yu/"/>
      <url>/2020/12/14/09.kua-yu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h2><h3 id="1-1-什么是同源策略及其限制内容？"><a href="#1-1-什么是同源策略及其限制内容？" class="headerlink" title="1.1 什么是同源策略及其限制内容？"></a>1.1 什么是同源策略及其限制内容？</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><img src="1.1.png"></p><p><strong>同源策略限制内容有：</strong></p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求不能发送</li></ul><p>但是有<strong>三个标签是允许跨域加载资源</strong>：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><h3 id="1-2-常见的跨域场景"><a href="#1-2-常见的跨域场景" class="headerlink" title="1.2 常见的跨域场景"></a>1.2 常见的跨域场景</h3><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p><p><img src="1.2.png"></p><p>特别说明两点：</p><p><strong>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</strong></p><p><strong>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”</strong>。</p><p>这里你或许有个疑问：<strong>请求跨域了，那么请求到底发出去没有？</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="二、跨域解决方案"><a href="#二、跨域解决方案" class="headerlink" title="二、跨域解决方案"></a>二、跨域解决方案</h2><h3 id="2-1-jsonp"><a href="#2-1-jsonp" class="headerlink" title="2.1 jsonp"></a>2.1 jsonp</h3><p><strong>1) JSONP原理</strong></p><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><p><strong>2) JSONP和AJAX对比</strong></p><p>JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</p><p><strong>3) JSONP优缺点</strong></p><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<strong>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></p><p><strong>4) JSONP的实现流程</strong></p><ul><li>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个 <code>&lt;script&gt;</code> 标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show('xxx')</code>。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ul><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己来封装一个 JSONP 函数。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// index.html</span><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callback <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>    window<span class="token punctuation">[</span>callback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    params <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>params<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// wd=b&amp;callback=show</span>    <span class="token keyword">let</span> arrs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>      arrs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arrs<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  url<span class="token punctuation">:</span> <span class="token string">'http://localhost:3000/say'</span><span class="token punctuation">,</span>  params<span class="token punctuation">:</span> <span class="token punctuation">{</span> wd<span class="token punctuation">:</span> <span class="token string">'Iloveyou'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  callback<span class="token punctuation">:</span> <span class="token string">'show'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show('我xxx')</code>，最后会运行show()这个函数，打印出’xxx’</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// server.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/say'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> <span class="token punctuation">{</span> wd<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>query  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>wd<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Iloveyou</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// show</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">('我不爱你')`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5) jQuery的jsonp形式</strong></p><p><strong>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span><span class="token string">"http://crossdomain.com/jsonServerResponse"</span><span class="token punctuation">,</span>dataType<span class="token punctuation">:</span><span class="token string">"jsonp"</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//可以省略</span>jsonpCallback<span class="token punctuation">:</span><span class="token string">"show"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span>jsonp<span class="token punctuation">:</span><span class="token string">"callback"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//->把传递函数名的那个形参callback，可省略</span>success<span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-cors-跨域资源共享"><a href="#2-2-cors-跨域资源共享" class="headerlink" title="2.2 cors 跨域资源共享"></a>2.2 cors 跨域资源共享</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><p><strong>1) 简单请求</strong></p><p>只要同时满足以下两大条件，就属于简单请求</p><p>条件1：使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>条件2：Content-Type 的值仅限于下列三者之一：</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><p><strong>2) 复杂请求</strong></p><p>不符合以上条件的请求就肯定是复杂请求了。<br>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 允许哪个方法访问我</span>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 预检的存活时间</span>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Max-Age'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// OPTIONS请求不做任何处理</span><span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'OPTIONS'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义后台返回的内容</span>app<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// index.html</span><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">'name=xiamen'</span> <span class="token comment" spellcheck="true">// cookie不能跨域</span>xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 前端设置是否带cookie</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:4000/getData'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'xiamen'</span><span class="token punctuation">)</span>xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//得到响应头，后台需设置Access-Control-Expose-Headers</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span><span class="token function">getResponseHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//server1.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//server2.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> whitList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'http://localhost:3000'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//设置白名单</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> origin <span class="token operator">=</span> req<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>origin  <span class="token keyword">if</span> <span class="token punctuation">(</span>whitList<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置哪个源可以访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> origin<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许携带哪个头访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许哪个方法访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许携带cookie</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Credentials'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 预检的存活时间</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Max-Age'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许返回的头</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Expose-Headers'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'OPTIONS'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// OPTIONS请求不做任何处理</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'jw'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回一个响应头，后台需设置</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p><h3 id="2-3-postMessage"><a href="#2-3-postMessage" class="headerlink" title="2.3 postMessage"></a>2.3 postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p><p><code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。</p><pre class="line-numbers language-html"><code class="language-html">// a.html  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://localhost:4000/b.html<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>frame<span class="token punctuation">"</span></span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>load()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span> //等它加载完触发一个事件  //内嵌在http://localhost:3000/a.html    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">      <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> frame <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'frame'</span><span class="token punctuation">)</span>        frame<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'我爱你'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:4000'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//发送数据</span>        window<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//接受返回数据</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//我不爱你</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>// b.html  window.onmessage = function(e) {    console.log(e.data) //我爱你    e.source.postMessage('我不爱你', e.origin) }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-websocket"><a href="#2-4-websocket" class="headerlink" title="2.4 websocket"></a>2.4 websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据：</p><pre class="line-numbers language-html"><code class="language-html">// socket.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">let</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    socket<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      socket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'我爱你'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//向服务器发送数据</span>    <span class="token punctuation">}</span>    socket<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//接收服务器返回的数据</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>// server.jslet express = require('express');let app = express();let WebSocket = require('ws');//记得安装wslet wss = new WebSocket.Server({port:3000});wss.on('connection',function(ws) {  ws.on('message', function (data) {    console.log(data);    ws.send('我不爱你')  });})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-node中间件代理-两次跨域"><a href="#2-5-node中间件代理-两次跨域" class="headerlink" title="2.5 node中间件代理(两次跨域)"></a>2.5 node中间件代理(两次跨域)</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong><br>代理服务器，需要做以下几个步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li><li>将 响应 转发给客户端。</li></ul><p><img src="2.5.png"></p><p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p><pre class="line-numbers language-html"><code class="language-html">// index.html(http://127.0.0.1:5500) <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">      $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token punctuation">:</span> <span class="token string">'http://localhost:3000'</span><span class="token punctuation">,</span>        type<span class="token punctuation">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'xiamen'</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'123456'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        contentType<span class="token punctuation">:</span> <span class="token string">'application/json;charset=utf-8'</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {"title":"fontend","password":"123456"}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        error<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) => {  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段  response.writeHead(200, {    'Access-Control-Allow-Origin': '*',    'Access-Control-Allow-Methods': '*',    'Access-Control-Allow-Headers': 'Content-Type'  })  // 第二步：将请求转发给服务器  const proxyRequest = http    .request(      {        host: '127.0.0.1',        port: 4000,        url: '/',        method: request.method,        headers: request.headers      },      serverResponse => {        // 第三步：收到服务器的响应        var body = ''        serverResponse.on('data', chunk => {          body += chunk        })        serverResponse.on('end', () => {          console.log('The data is ' + body)          // 第四步：将响应结果转发给浏览器          response.end(body)        })      }    )    .end()})server.listen(3000, () => {  console.log('The proxyServer is running at http://localhost:3000')})// server2.js(http://localhost:4000)const http = require('http')const data = { title: 'fontend', password: '123456' }const server = http.createServer((request, response) => {  if (request.url === '/') {    response.end(JSON.stringify(data))  }})server.listen(4000, () => {  console.log('The server is running at http://localhost:4000')})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>{"title":"fontend","password":"123456"}</code></p><h3 id="2-6-nginx-反向代理"><a href="#2-6-nginx-反向代理" class="headerlink" title="2.6 nginx 反向代理"></a>2.6 nginx 反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>先下载<a href="http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// proxy服务器</span>server <span class="token punctuation">{</span>    listen       <span class="token number">81</span><span class="token punctuation">;</span>    server_name  www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>    location <span class="token operator">/</span> <span class="token punctuation">{</span>        proxy_pass   http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com<span class="token punctuation">:</span><span class="token number">8080</span><span class="token punctuation">;</span>  #反向代理        proxy_cookie_domain www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span> #修改cookie里域名        index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>        # 当用webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>  #当前端只跨域不带cookie时，可为<span class="token operator">*</span>        add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后通过命令行<code>nginx -s reload</code>启动nginx</p><pre class="line-numbers language-html"><code class="language-html">// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send();// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) {    var params = qs.parse(req.url.substring(2));    // 向前台写cookie    res.writeHead(200, {        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取    });    res.write(JSON.stringify(params));    res.end();});server.listen('8080');console.log('Server is running at port 8080...');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-window-name-iframe"><a href="#2-7-window-name-iframe" class="headerlink" title="2.7 window.name + iframe"></a>2.7 window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><pre class="line-numbers language-html"><code class="language-html"> // a.html(http://localhost:3000/b.html)  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://localhost:4000/c.html<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>load()<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>iframe<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token comment" spellcheck="true">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span>    <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 第1次onload(跨域页)成功后，切换到同域代理页面</span>        <span class="token keyword">let</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/b.html'</span><span class="token punctuation">;</span>        first <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b.html为中间代理页，与a.html同域，内容为空。</p><pre class="line-numbers language-html"><code class="language-html"> // c.html(http://localhost:4000/c.html)  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    window<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'我不爱你'</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="2-8-location-hash-iframe"><a href="#2-8-location-hash-iframe" class="headerlink" title="2.8 location.hash + iframe"></a>2.8 location.hash + iframe</h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。<br>同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><pre class="line-numbers language-html"><code class="language-html"> // a.html  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://localhost:4000/c.html#iloveyou<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    window<span class="token punctuation">.</span>onhashchange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//检测hash的变化</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span> // b.html  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash     <span class="token comment" spellcheck="true">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span> // c.html console.log(location.hash);  let iframe = document.createElement('iframe');  iframe.src = 'http://localhost:3000/b.html#idontloveyou';  document.body.appendChild(iframe);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-9-document-domain-iframe"><a href="#2-9-document-domain-iframe" class="headerlink" title="2.9 document.domain + iframe"></a>2.9 document.domain + iframe</h3><p><strong>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式</strong>。<br>只需要给页面添加 <code>document.domain ='test.com'</code> 表示二级域名都相同就可以实现跨域。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p><pre class="line-numbers language-html"><code class="language-html">// a.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span> helloa  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://b.zf1.cn:3000/b.html<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>load()<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>frame<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'zf1.cn'</span>    <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>frame<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>// b.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>   hellob   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">     document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'zf1.cn'</span>     <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><ul><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案。</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除 Github 仓库文件夹</title>
      <link href="/2020/12/12/08.github/"/>
      <url>/2020/12/12/08.github/</url>
      
        <content type="html"><![CDATA[<h2 id="一、删除已有仓库"><a href="#一、删除已有仓库" class="headerlink" title="一、删除已有仓库"></a>一、删除已有仓库</h2><ol><li>进入到我们需要删除的仓库里面，找到 <strong>“settings”</strong> 仓库设置。</li><li>然后，在仓库设置里拉到最底部，找到 <strong>“Danger Zone”</strong> 危险区域。</li><li>点击 <strong>“Delete this repository”</strong> 这样就可以删除该仓库了。</li></ol><h2 id="二、删除某个文件"><a href="#二、删除某个文件" class="headerlink" title="二、删除某个文件"></a>二、删除某个文件</h2><p>我们知道，在 Github 上我们只能删除仓库，并不能删除文件夹，所以只能采用命令来解决。</p><h3 id="2-1-新建文件夹"><a href="#2-1-新建文件夹" class="headerlink" title="2.1 新建文件夹"></a>2.1 新建文件夹</h3><p>在桌面上新建一个文件夹 <code>delete</code>，叫啥名都行。</p><h3 id="2-2-git-bash-here"><a href="#2-2-git-bash-here" class="headerlink" title="2.2 git bash here"></a>2.2 git bash here</h3><p>在新建的文件夹里右键<code>git bash here</code>打开终端，并执行<code>git init</code>初始化仓库。</p><h3 id="2-3-git-clone-仓库地址"><a href="#2-3-git-clone-仓库地址" class="headerlink" title="2.3 git clone 仓库地址"></a>2.3 git clone 仓库地址</h3><p>找到 Github 上要删除的仓库地址，并复制，在终端里输入<code>git clone + 地址</code></p><h3 id="2-4-git-bash-here"><a href="#2-4-git-bash-here" class="headerlink" title="2.4 git bash here"></a>2.4 git bash here</h3><p>然后你会发现多了一个文件夹，打开并在该文件夹下右键 <code>git bash here</code> 打开终端，注意这里是一个新的终端了。</p><h3 id="2-5-dir"><a href="#2-5-dir" class="headerlink" title="2.5 dir"></a>2.5 dir</h3><p>在终端里输入<code>dir</code>查看此文件夹下的文件和目录（文件夹）</p><h3 id="2-6-git-rm-filename"><a href="#2-6-git-rm-filename" class="headerlink" title="2.6 git rm filename"></a>2.6 git rm filename</h3><p>删除本地仓库文件 <code>git rm &lt;filename&gt;</code>，<code>&lt;filename&gt;</code> 是你要删除的文件名字。</p><h2 id="三、删除某个文件夹"><a href="#三、删除某个文件夹" class="headerlink" title="三、删除某个文件夹"></a>三、删除某个文件夹</h2><h3 id="3-1-git-rm-r-filename"><a href="#3-1-git-rm-r-filename" class="headerlink" title="3.1 git rm -r filename"></a>3.1 git rm -r filename</h3><p>文件夹的删除和文件不一样，需要多一个参数，如下：<br>删除本地仓库文件夹 <code>git rm -r &lt;filename&gt;</code>，<code>&lt;filename&gt;</code>是你要删除的文件夹名字。</p><h3 id="3-2-git-commit-m-“备注”"><a href="#3-2-git-commit-m-“备注”" class="headerlink" title="3.2 git commit -m “备注”"></a>3.2 git commit -m “备注”</h3><p>删除完你需要删除的文件和文件夹以后，在终端里提交本次修改 <code>git commit -m "备注"</code>。</p><h3 id="3-3-git-checkout"><a href="#3-3-git-checkout" class="headerlink" title="3.3 git checkout"></a>3.3 git checkout</h3><p>把删除的文件恢复到最新版本： <code>git checkout</code>。</p><h3 id="3-4-git-push"><a href="#3-4-git-push" class="headerlink" title="3.4 git push"></a>3.4 git push</h3><p>将本地推送到远程仓库 <code>git push</code>。</p><h3 id="3-5-大功告成！"><a href="#3-5-大功告成！" class="headerlink" title="3.5 大功告成！"></a>3.5 大功告成！</h3><p>刷新 Github 仓库，看到选定删除的文件没有了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESLint 使用和配置</title>
      <link href="/2020/12/11/07.eslint/"/>
      <url>/2020/12/11/07.eslint/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>ESLint 是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误并统一代码风格。ESLint 被设计为完全可配置的，主要有两种方式：</p><ul><li>在注释中配置：使用 JavaScript 注释直接把配置嵌入到 JS 文件中。</li><li>配置文件：使用下面任一的文件来为全部的目录和它的子目录指定配置信息。<ul><li>javascript：使用<code>.eslintrc.js</code>文件并导出一个包含配置的对象。</li><li>YAML：<code>.eslintrc.yaml</code>或者<code>.eslintrc.yml</code></li><li>JSON：<code>.eslintrc.json</code>，并且此文件允许使用JS形式的注释</li><li>废弃的用法：<code>.eslintrc</code>，此文件可以是JSON或者YAML</li><li>package.json：在<code>package.json</code>文件中创建<code>eslintConfig</code>属性，所有的配置包含在此属性中。</li></ul></li></ul><p>这些文件的优先级则是按照以上出现的顺序（<code>.eslintrc.js</code> &gt; <code>.eslintrc.yaml</code> &gt; <code>.eslintrc.yml</code> &gt; <code>.eslintrc.json</code> &gt; <code>.eslintrc</code> &gt; <code>package.json</code>）。</p><p>可以被配置的信息主要分为3类：</p><ul><li>Environments：你的 javascript 脚步将要运行在什么环境（如：nodejs，browser，commonjs 等）中。</li><li>Globals：执行代码时脚步需要访问的额外全局变量。</li><li>Rules：开启某些规则，也可以设置规则的等级。</li></ul><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><hr><ul><li>全局安装</li></ul><pre class="line-numbers language-undefined"><code class="language-undefined">npm i -g eslint<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>局部安装（推荐）</li></ul><pre class="line-numbers language-undefined"><code class="language-undefined">npm i -D eslint<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完毕后，接下来新建一个配置文件<code>.eslintrc.js</code>，或者使用如下的命令行来自动生成。</p><pre class="line-numbers language-kotlin"><code class="language-kotlin">eslint <span class="token operator">--</span><span class="token keyword">init</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><h3 id="3-1-指定执行环境"><a href="#3-1-指定执行环境" class="headerlink" title="3.1 指定执行环境"></a>3.1 指定执行环境</h3><p>JavaScript 代码可以运行在浏览器或 Node.js 等环境中，每个环境的全局变量都不尽相同（如 Node.js 中没有 DOM 相关的全局变量）。在配置文件中可以自由的指定执行环境。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// .eslintrc.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  env<span class="token operator">:</span> <span class="token punctuation">{</span>    browser<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    node<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的环境可在官网查询。</p><h3 id="3-2-指定全局变量"><a href="#3-2-指定全局变量" class="headerlink" title="3.2 指定全局变量"></a>3.2 指定全局变量</h3><p>可以在配置文件或注释中指定额外的全局变量，<code>false</code>表明变量只读：</p><ul><li>使用注释来配置：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">/* global var1, var2 *//* global var1:false, var2:false */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用配置文件来配置：</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// .eslintrc.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  globals<span class="token operator">:</span> <span class="token punctuation">{</span>    var1<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    var2<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-规则"><a href="#3-3-规则" class="headerlink" title="3.3 规则"></a>3.3 规则</h3><p>在配置文件中可以设置一些规则。</p><p>这些规则的等级有三种：</p><ul><li>“off” 或者 0：关闭规则。</li><li>“warn” 或者 1：打开规则，并且作为一个警告（不影响 exit code）。</li><li>“error” 或者 2：打开规则，并且作为一个错误（exit code 将会是1）。</li></ul><p>例如：</p><ul><li>使用配置文件来配置：</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// .eslintrc.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  rules<span class="token operator">:</span> <span class="token punctuation">{</span>    eqeqeq<span class="token operator">:</span> <span class="token string">'off'</span><span class="token punctuation">,</span>    curly<span class="token operator">:</span> <span class="token string">'error'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用注释来配置：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">/* eslint eqeqeq: <span class="token string">"off"</span>, curly: <span class="token string">"error"</span> *//* eslint eqeqeq: 0, curly: 2 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>具体的规则可以在官网上找到。</p><h2 id="四、使用方法"><a href="#四、使用方法" class="headerlink" title="四、使用方法"></a>四、使用方法</h2><h3 id="4-1-命令行"><a href="#4-1-命令行" class="headerlink" title="4.1 命令行"></a>4.1 命令行</h3><p>通过命令行使用 ESLint。</p><pre class="line-numbers language-css"><code class="language-css">eslint [options] file<span class="token number">.</span>js [file<span class="token number">.</span>js] [dir]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-编辑器"><a href="#4-2-编辑器" class="headerlink" title="4.2 编辑器"></a>4.2 编辑器</h3><p>使用 VSCode 配合相应的插件直接显示错误和警告。</p><p>除了上述，还可以配合 Gulp、Webpack 等工具使用。</p><h2 id="五、常见示例"><a href="#五、常见示例" class="headerlink" title="五、常见示例"></a>五、常见示例</h2><h3 id="5-1-一般示例"><a href="#5-1-一般示例" class="headerlink" title="5.1 一般示例"></a>5.1 一般示例</h3><p>在项目的根目录中添加文件 .prettierrc</p><pre><code>{ "semi": false, // 格式化消除所有分号  "singleQuote": true // 格式化字符串为单引号}</code></pre><p>找到 .eslintrc.js，在 rules 中</p><pre><code>rules: {  'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',  'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',  // fun () {} =&gt; fun() {}  'space-before-function-paren': 0 }</code></pre><h3 id="5-2-ESLint-忽略检查"><a href="#5-2-ESLint-忽略检查" class="headerlink" title="5.2 ESLint 忽略检查"></a>5.2 ESLint 忽略检查</h3><!-- eslint-disable --> 或 /* eslint-disable */ 后面的代码都不检查。<!-- eslint-disable --> … <!-- eslint-enable> 或 /* eslint-disable */ … /* eslint-enable */ 不检查某段代码。<p>eslint-disable-next-line：不检查下一行代码。</p><h3 id="5-3-其他配置规则"><a href="#5-3-其他配置规则" class="headerlink" title="5.3 其他配置规则"></a>5.3 其他配置规则</h3><ul><li><p><code>&quot;no-console&quot;:&quot;off&quot;</code> 禁用 console。</p></li><li><p><code>&quot;no-unused-vars&quot;:2</code> 禁止出现未使用过的变量。</p></li><li><p><code>&quot;no-use-before-define&quot;:2</code> 不允许在变量定义之前使用它们。</p></li><li><p><code>&quot;linebreak-style&quot;:[2, &quot;unix&quot;]</code> 强制使用一致的换行风格。</p></li><li><p><code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code> 强制使用一致的单引号。</p></li><li><p><code>&quot;semi&quot;:[&quot;error&quot;, &quot;always&quot;]</code> 控制行尾部分号。</p></li><li><p><code>&quot;curly&quot;:[&quot;error&quot;, &quot;all&quot;]</code> 强制所有控制语句使用一致的括号风格。</p></li><li><p><code>&quot;default-case&quot;: &quot;error&quot;</code> switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告。</p></li><li><p><code>&quot;no-else-return&quot;:&quot;error&quot;</code> 禁止 if 语句中有 return 之后有 else。</p></li><li><p><code>&quot;no-implicit-coercion&quot;: &quot;error&quot;</code> 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。</p></li><li><p><code>&quot;no-invalid-this&quot;: &quot;error&quot;</code> 禁止 this 关键字出现在类和类对象之外。</p></li><li><p><code>&quot;no-loop-func&quot;:&quot;error&quot;</code> 禁止在循环中出现 function 声明和表达式。</p></li><li><p><code>&quot;no-multi-spaces&quot;:&quot;error&quot;</code> 禁止使用多个空格。</p></li><li><p><code>&quot;no-new-func&quot;:&quot;error&quot;</code> 禁止对 空Function 对象使用 new 操作符。</p></li><li><p><code>&quot;no-useless-return&quot;:&quot;error&quot;</code> 禁止没有任何内容的return;</p></li><li><p><code>&quot;global-require&quot;: &quot;error&quot;</code> 要求 require() 出现在顶层模块作用域中。</p></li><li><p><code>&quot;no-path-concat&quot;: &quot;error&quot;</code> 禁止对 dirname 和 filename进行字符串连接</p></li><li><p><code>&quot;no-sync&quot;: &quot;error&quot;</code> 禁用同步方法。</p></li><li><p><code>&quot;array-bracket-spacing&quot;: [&quot;error&quot;, &quot;never&quot;]</code> 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格。</p></li><li><p><code>&quot;block-spacing&quot;: [&quot;error&quot;, &quot;always&quot;]</code> 禁止或强制在单行代码块中使用空格(禁用)。</p></li><li><p><code>&quot;brace-style&quot;: [&quot;error&quot;, &quot;1tbs&quot;]</code></p></li><li><p><code>&quot;camelcase&quot;: &quot;error&quot;</code> 强制驼峰法命名。</p></li><li><p><code>&quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always-multiline&quot;]</code> 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗,always-multiline：多行模式必须带逗号，单行模式不能带逗号号。</p></li><li><p><code>&quot;comma-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;]</code> 控制逗号前后的空格。</p></li><li><p><code>&quot;comma-style&quot;: [&quot;error&quot;, &quot;last&quot;]</code> 控制逗号在行尾出现还是在行首出现 (默认行尾)。</p></li><li><p><code>&quot;key-spacing&quot;: [&quot;error&quot;, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;]</code> 该规则规定了在对象字面量语法中，key和value之间的空白，冒号前不要空格，冒号后面需要一个空格。</p></li><li><p><code>&quot;lines-around-comment&quot;: [&quot;error&quot;, &#123; &quot;beforeBlockComment&quot;: true &#125;]</code> 要求在注释周围有空行 ( 要求在块级注释之前有一空行)。</p></li><li><p><code>&quot;newline-after-var&quot;: [&quot;error&quot;, &quot;always&quot;]</code> 要求或禁止 var 声明语句后有一行空行。</p></li><li><p><code>&quot;newline-before-return&quot;: &quot;error&quot;</code> 要求 return 语句之前有一空行。</p></li><li><p><code>&quot;no-multi-assign&quot;: &quot;error&quot;</code> 链接变量的赋值可能会导致意外的结果并难以阅读，不允许在单个语句中使用多个分配。</p></li><li><p><code>&quot;max-params&quot;: [1, 3] function</code> 定义中最多允许的参数数量。</p></li><li><p><code>&quot;new-cap&quot;: [&quot;error&quot;, &#123; &quot;newIsCap&quot;: true, &quot;capIsNew&quot;: false&#125;]</code> 构造函数首字母大写。</p></li><li><p><code>&quot;no-multiple-empty-lines&quot;: [&quot;error&quot;, &#123;&quot;max&quot;: 2&#125;]</code> 空行不能够超过2行。</p></li><li><p><code>&quot;no-shadow-restricted-names&quot;: &quot;error&quot;</code> 禁止对一些关键字或者保留字进行赋值操作，比如NaN、Infinity、undefined、eval、arguments等。</p></li><li><p><code>&quot;no-undef-init&quot;: &quot;error&quot;</code> 禁止把undefined赋值给一个变量。</p></li><li><p><code>&quot;keyword-spacing&quot;: &quot;error&quot;</code> keyword 前后需要空格。</p></li><li><p><code>&quot;space-before-blocks&quot;: [&quot;error&quot;,&quot;always&quot;]</code> 强制在块之前使用一致的空格。</p></li></ul>-->]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ESLint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 模块化标准</title>
      <link href="/2020/12/10/06.js-mo-kuai-hua/"/>
      <url>/2020/12/10/06.js-mo-kuai-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="一、模块化、组件化、工程化"><a href="#一、模块化、组件化、工程化" class="headerlink" title="一、模块化、组件化、工程化"></a>一、模块化、组件化、工程化</h2><p>（1）<strong>模块化：</strong>如果一个项目是用多个模块进行开发的就叫模块化项目。它是将一个大的 JS 文件根据相关规范（CommonJS，AMD，CMD，ES6）拆分成多个小的 JS,每个 JS 文件就对应一个模块。</p><p>模块化特点：</p><ol><li><p>每个 JS 文件中的数据是私有的，相对来说比较安全。</p></li><li><p>不互相干扰避免变量污染，命名冲突的问题。</p></li><li><p>方便代码的复用以及维护</p></li></ol><p>（2）<strong>组件化：</strong>一个项目是用多个组件进行开发的话就叫多组件项目。</p><p>   组件是一个局部的功能界面，页面上每一个独立的交互区域就是一个组件，由 JS，HTML，CSS 甚至 img 等资源组成。</p><p>   组件化将页面当做一个容器，页面中各个独立部分如：头部导航、中间轮播、侧边栏目、底部等都当做独立的组件共同来组成完整的页面。</p><p>每个组件对应一个文件目录，组件在这个目录下进行维护，当不需要某个组件或要替换组件时，可以将目录进行删除/替换</p><p>（3）<strong>工程化：</strong>就是要自成体系，用软件工程的思想对前端开发的流程、技术、经验进行规范和标准，提高效率降低成本。具体表现形式类似模块化和组件化。</p><p>总的来说这三种开发的核心思想或者说优点就是分而治之，方便开发和维护，提高代码的复用率。</p><h2 id="二、JS模块化"><a href="#二、JS模块化" class="headerlink" title="二、JS模块化"></a>二、JS模块化</h2><h3 id="2-1-模块化的理解"><a href="#2-1-模块化的理解" class="headerlink" title="2.1 模块化的理解"></a>2.1 模块化的理解</h3><ul><li><p>什么是模块？</p><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件)，并进行组合在一起。</li><li>块的内部数据/实现是私有的，只是向外部暴露一些接口(方法)与外部其它模块通信。</li></ul></li><li><p>一个模块的组成</p><ul><li>数据 =&gt; 内部的属性。</li><li>操作数据的行为 =&gt; 内部的函数。</li></ul></li><li><p>模块化</p><ul><li><p>编码时是按照模块一个一个编码的，整个项目就是一个模块化的项目。</p><h3 id="2-2-模块化的进化过程"><a href="#2-2-模块化的进化过程" class="headerlink" title="2.2 模块化的进化过程"></a>2.2 模块化的进化过程</h3></li><li><p><strong>全局 function 模式 :</strong> </p><ul><li>编码: 全局变量/函数。</li><li>问题: 污染全局命名空间，容易引起命名冲突/数据不安全。</li></ul></li><li><p><strong>namespace 模式 :</strong> </p><ul><li>编码: 将数据/行为封装到对象中。</li><li>解决: 命名冲突(减少了全局变量)。</li><li>问题: 数据不安全(外部可以直接修改模块内部的数据)。</li></ul></li><li><p><strong>IIFE 模式/增强</strong></p><ul><li>IIFE : 立即调用函数表达式—&gt;匿名函数自调用。</li><li>编码: 将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口。</li><li>引入依赖: 通过函数形参来引入依赖模块。<pre><code>(function(window, module2){  var data = 'atguigu.com'  function foo() {     module2.xxx()     console.log('foo()'+data)  }  function bar() {     console.log('bar()'+data)  }    window.module = {foo}})(window, module2)</code></pre></li><li>问题: 引入的 <code>script</code> 标签之间的依赖先后顺序不能出错，需要发多次请求增加服务器负担。<h3 id="2-3-模块化规范"><a href="#2-3-模块化规范" class="headerlink" title="2.3 模块化规范"></a>2.3 模块化规范</h3><h4 id="2-3-1-CommonJS"><a href="#2-3-1-CommonJS" class="headerlink" title="2.3.1 CommonJS"></a>2.3.1 CommonJS</h4><ul><li>Node.js: 服务器端</li><li>Browserify: 浏览器端，也称为js的打包工具</li><li>基本语法:<ul><li>定义暴露模块 : exports<br>exports.xxx = value<br>module.exports = value<br>引入模块 : require<br>var module = require(‘模块名/模块相对路径’)</li></ul></li><li>引入模块发生在什么时候?<ul><li>Node : 运行时, 动态同步引入</li><li>Browserify: 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了), <pre><code>        运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块。</code></pre><h4 id="2-3-2-AMD"><a href="#2-3-2-AMD" class="headerlink" title="2.3.2 AMD"></a>2.3.2 AMD</h4></li></ul></li><li>AMD: 浏览器端</li><li>require.js</li><li>基本语法<ul><li>定义暴露模块: define([依赖模块名], function(){return 模块对象})</li><li>引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象})</li><li>配置:<br>require.config({<br>  // 基本路径<br>  baseUrl : ‘js/‘,<br>  // 标识名称与路径的映射<br>  paths : {<pre><code>'模块1' : 'modules/模块1','模块2' : 'modules/模块2','angular' : 'libs/angular','angular-messages' : 'libs/angular-messages'</code></pre>  },<br>  // 非AMD的模块<br>  shim : {<pre><code>'angular' : {    exports : 'angular'},'angular-messages' : {    exports : 'angular-messages',    deps : ['angular']}</code></pre>  }<br>})<h4 id="2-3-3-CMD"><a href="#2-3-3-CMD" class="headerlink" title="2.3.3 CMD"></a>2.3.3 CMD</h4></li></ul></li><li>CMD: 浏览器端，好像阿里已经把该标准出售给国外了,应该不常用。</li><li>sea.js</li><li>基本语法<ul><li>定义暴露模块:<br>define(function(require, module, exports){<br>  通过require引入依赖模块<br>  通过module/exports来暴露模块<br>  exports.xxx = value<br>})</li><li>使用模块seajs.use([‘模块1’, ‘模块2’])<h4 id="2-3-4-ES6"><a href="#2-3-4-ES6" class="headerlink" title="2.3.4 ES6"></a>2.3.4 ES6</h4></li></ul></li><li>ES6内置了模块化的实现，语法简洁、推荐使用。</li><li>基本语法<ul><li>定义暴露模块 : export<ul><li>暴露一个对象:<br>export default 对象</li><li>暴露多个:<br>export var xxx = value1<br>export let yyy = value2var xxx = value1<br>let yyy = value2<br>export {xxx, yyy}   </li></ul></li><li>引入使用模块 : import<ul><li>default模块:<br>import xxx  from ‘模块路径/模块名’</li><li>其它模块<br>import {xxx, yyy} from ‘模块路径/模块名’<br>import * as module1 from ‘模块路径/模块名’</li></ul></li></ul></li><li>问题: 所有浏览器还不能直接的识别ES6模块化的语法。</li><li>解决:<ul><li>使用Babel将ES6—&gt;ES5(使用了CommonJS) —-浏览器还不能直接支行。</li><li>使用Browserify—&gt;打包处理—-浏览器可以运行。</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配方案汇总</title>
      <link href="/2020/12/09/05.yi-dong-duan-gua-pei/"/>
      <url>/2020/12/09/05.yi-dong-duan-gua-pei/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>由于手机的<strong>屏幕尺寸</strong>、<strong>分辨率</strong>不同，还要考虑<strong>横竖屏</strong>问题，为了使得 web 页面在不同移动设备上自适应，需要<strong>在开发过程中使用合理的适配方案</strong>。</p><p>早期网页设计采用<strong>静态布局</strong>，通过<code>&lt;meta&gt;</code>标签中的<code>applicable-device</code>应用设备标识识别移动设备，即<code>&lt;meta name = 'applicable-device' content = 'mobile'&gt;</code>，在<code>&lt;meta&gt;</code>标签中的<code>viewport</code>标签中设置<code>width</code>，通过<code>js</code>动态修改标签的<code>initial-scale</code>使得页面等比缩放，刚好占满整个屏幕。静态布局页面各个元素采用<code>px</code>为单位，这种方案实现简单，不存在兼容性问题，但用户体验很不友好。</p><p>后面出现<strong>流式布局</strong>，使用百分比<code>%</code>定义宽度，高度使用<code>px</code>固定，根据可视区域大小实时进行尺寸调整，通常使用<code>max-width/min-width</code>控制尺寸范围过大或者过小。这种方案实现比较简单，但在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化。</p><p>适应不同页面字体大小展现问题，出现了<strong>弹性布局</strong>。这种布局方案下，包裹文字的元素的尺寸采用<code>em/rem</code>为单位，页面主要划分区域依据情况使用<code>px</code>、百分数或者<code>em/rem</code>。如一些高校的网站，页面的主要划分区域使用<code>px</code>和百分比，包裹文字的元素和文字采用<code>em</code>。</p><p>上面这几种方案，页面元素的大小按照屏幕分辨率进行适配调整，但是整体布局不变，对于<strong>响应式web设计</strong>，网页布局会随着访问它的视口及设备的不同从而呈现不同的样式，在实现上可能会以上多种方案的结合，同时搭配<strong>媒体查询</strong>技术，使得一个页面在多个终端 (PC, mobile, pad) 呈现满意效果。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><h3 id="2-1-像素"><a href="#2-1-像素" class="headerlink" title="2.1 像素"></a>2.1 像素</h3><h4 id="px-pixel"><a href="#px-pixel" class="headerlink" title="px (pixel)"></a>px (pixel)</h4><p><strong>像素，是一个抽象的概念，用来显示图像的基本单元。</strong>不同设备的像素不同，不同分辨率下相同长度的<code>px</code>显示会不一样，因为像素点的个数相同情况下，不同分辨率下每个像素点对应像素宽度不同。比如同样是<code>14px</code>大小的字，在<code>1366×768</code>显示屏下会显示小些，在<code>1024×768</code>显示屏下会相对大。也称为 <strong>物理像素（设备像素</strong>），是分辨率的尺寸单位。</p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p><strong>分辨率：</strong>屏幕上纵横的像素点。</p><h4 id="CSS-像素"><a href="#CSS-像素" class="headerlink" title="CSS 像素"></a>CSS 像素</h4><p><strong>逻辑像素(逻辑分辨率) = 设备独立像素(DIP) = CSS像素：是非真实存在的，相对的，代码中用来衡量页面内容的大小。</strong>不同屏幕上，<code>css</code>像素呈现的物理尺寸一致，但<code>css</code>像素对应的物理像素具数不同。标准的显示密度下，<code>1</code>个<code>css</code>像素对应一个物理像素，缩放时，<code>1</code>个<code>css</code>像素对应的物理像素会减增。</p><h4 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h4><p><strong>物理像素(物理分辨率) = 设备像素(DP) ：</strong> 设备屏幕的显示单位，设计图一般给的是物理分辨率</p><h4 id="PPI-pixel-per-inch"><a href="#PPI-pixel-per-inch" class="headerlink" title="PPI (pixel per inch)"></a>PPI (pixel per inch)</h4><p><strong>屏幕像素密度(ppi)：</strong>屏幕每英寸可显示像素点的数量，与之类似的还有dpi。值越高，显示画面细节越丰富。计算公式为：</p><p><img src="2.1.1.png"></p><p>其中 <strong>W</strong> 和 <strong>H</strong> 是分辨率的宽高，<strong>S</strong> 是屏幕尺寸。</p><h4 id="DPI-dot-per-inch"><a href="#DPI-dot-per-inch" class="headerlink" title="DPI (dot per inch)"></a>DPI (dot per inch)</h4><p>打印设备每英寸印刷出来的点有多少个，值越高，图片越细腻。</p><h4 id="DPR-devicePixelRatio"><a href="#DPR-devicePixelRatio" class="headerlink" title="DPR (devicePixelRatio)"></a>DPR (devicePixelRatio)</h4><p><strong>设备像素比</strong>，即：</p><p><img src="2.1.2.png"></p><p>指用多少个物理像素来渲染一个css像素。js中通过<code>window.devicePixelRatio</code>获取，css中通过<code>-webkit-device-pixel-ratio</code>,<code>-webkit-min-device-pixel-ratio</code>,<code>-webkit-max-device-pixel-ratio</code>进行媒体查询。</p><p>dpr 的出现是苹果公司在 iphone4 产品中推出了所谓的 retina 视网膜屏幕。因为屏幕的 ppi 太高，达到了人类视网膜的分辨极限。它在保持屏幕大小尺寸不变的情况下将它物理分辨率提高了一倍，在同样大小的屏幕上，像素多了一倍。</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>大小<strong>取决于当前对象的 font-size</strong>，未设置的话则 1 em 默认为 16 px，此时 10 px = 0.625 em。</p><p>换算:</p><blockquote><p>1em = 16px =&gt; 62.5%em = 10px</p></blockquote><p>需要在 css 中的 body 选择器中声明 font-size = 62.5% ，使 1 em = 10 px，再把之前的 px 数值除以 10，然后换上 em 作为单位。</p><p>特点:</p><ol><li>em 的值并不是固定的,em <strong>会继承父级元素的字体大小</strong></li><li>比如要设置 p 标签内的文本为 12 px,但包裹 p 标签的 #content 中已经声明了 font-size = 1.2 em,在声明 p 的字体大小时就只能是 1 em</li></ol><h4 id="rem-root-em"><a href="#rem-root-em" class="headerlink" title="rem (root em)"></a>rem (root em)</h4><p>CSS3 新增的一个单位，<strong>相对于 HTML 根元素 font-size</strong> 。</p><p>特点:</p><ol><li>修改根元素大小比例地调整所有字体大小，避免了字体大小的逐层复合。</li><li>对于 IE8 及更早版本不兼容。</li></ol><h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><p>CSS3 引入与视口有关的新单位：<strong>vw 表示相对于视口的宽度，vh 表示相对于视口高度</strong>。</p><p>平时拿到的设计图是基于 px ，怎么将 px 转为 vw 呢？</p><p><strong>vw 单位换算：</strong>视口宽度为 100 vw 占满整个视口区域，1 vw 相当于占整个视口宽度的 1%，所以 375 px = 100 vw =&gt; 1 px = 1/375*100  vw</p><p>所有页面元素都可换算成 vw 单位，但和百分比方案计算类似，会比较麻烦。</p><p>可以用插件 postcss-px-to-viewport，来预处理 CSS，将 px 转换为 vw，但是需要进行一些相关的 Webpack 配置：</p><pre><code>{  loader: 'postcss-loader',  options: {​      plugins: ()=&gt;[​        require('autoprefixer')({​            browsers: ['last 5 versions']​        }),​        require('postcss-px-to-viewport')({​            viewportWidth: 375,​            viewportHeight: 1334,​            unitPrecision: 3,​            viewportUnit: 'vw',​            selectorBlackList: ['.ignore', '.hairlines'],​        minPixelValue: 1,​        mediaQuery: false​        })​      ]}</code></pre><p>优点：</p><ol><li> vw \ vh相对于视口的宽高，通过 postcss-px-to-viewport 插件进行单位转换比较方便。</li></ol><p>缺点：</p><ol><li>直接进行单位换算时百分比可能出现小数。</li><li>兼容性 - ie11和少数低版本手机系统 ios8、android4.4 以下不支持。</li></ol><h3 id="2-2-视口"><a href="#2-2-视口" class="headerlink" title="2.2 视口"></a>2.2 视口</h3><meta>标签中定义了一些元数据信息，通过设置<meta name="viewport">，提供有关 视口初始大小 的信息，供移动设备 使用。属性值为：<table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>width</code></td><td align="center">数值 / <code>device-width</code></td><td align="center">视口宽度</td></tr><tr><td align="center"><code>height</code></td><td align="center">数值 / <code>device-height</code></td><td align="center">视口高度</td></tr><tr><td align="center"><code>initial-scale</code></td><td align="center">0.0 ~ 10.0</td><td align="center">设备宽度与视口大小之间的缩放比率</td></tr><tr><td align="center"><code>maximum-scale</code></td><td align="center">0.0 ~ 10.0</td><td align="center">缩放最大值</td></tr><tr><td align="center"><code>minimum-scale</code></td><td align="center">0.0 ~ 10.0</td><td align="center">缩放最小值</td></tr><tr><td align="center"><code>user-scalable</code></td><td align="center">布尔值</td><td align="center">默认<code>yes</code>，为<code>no</code>时用户不能缩放网页</td></tr></tbody></table><p>移动端涉及<strong>布局视口</strong>（Layout Viewport）、<strong>视觉视口</strong>（Visual ViewPort）和<strong>理想视口</strong>（Ideal ViewPort）。</p><ul><li><strong>布局视口</strong>指用视口元标签（viewport meta）来进行布局视口设置，<code>css</code>布局是相对于布局视口计算。</li><li><strong>视觉视口</strong>指用户当前看到的区域。</li><li><strong>理想视口</strong>指屏幕分辨率的值，通过设置 <code>&lt;meta name = "viewport" content = "width = device-width， initial-scale = 1.0"&gt;</code>实现。</li></ul><h3 id="2-3-手机屏幕特性"><a href="#2-3-手机屏幕特性" class="headerlink" title="2.3 手机屏幕特性"></a>2.3 手机屏幕特性</h3><h4 id="像素分辨率"><a href="#像素分辨率" class="headerlink" title="像素分辨率"></a>像素分辨率</h4><p>硬件所支持的，屏幕每行的像素<code>*</code>每列的像素点数，单位是<code>px</code>。</p><h4 id="逻辑分辨率"><a href="#逻辑分辨率" class="headerlink" title="逻辑分辨率"></a>逻辑分辨率</h4><p>设备独立的，软件可以达到的，个人理解是使得软件/页面在不同屏幕上显示出来的效果一致。</p><h4 id="倍率"><a href="#倍率" class="headerlink" title="倍率"></a>倍率</h4><p>像素分辨率<code>÷</code>逻辑分辨率等于<strong>倍率</strong>，如<code>@3x</code>表示分辨率的<code>3</code>倍。一个已知物理像素大小的元素，如果在普通屏中其设备像素等于<code>css</code>像素，但在一些高清屏中，如 <strong>Retina</strong> 显示屏，一个css像素对应<code>2</code>或<code>3</code>个设备像素，这时显示出来的元素会变小。为了让元素如期待显示，需要传入<strong>原始设计稿尺寸<code>×</code>倍率</strong>的设计稿，根据 <strong>DPR</strong> 的定义，这样加载后能够达到同样的效果。</p><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><p>手机屏幕对角线长度换算成英寸的大小</p><h2 id="三、适配方案"><a href="#三、适配方案" class="headerlink" title="三、适配方案"></a>三、适配方案</h2><h3 id="3-1-百分比方案"><a href="#3-1-百分比方案" class="headerlink" title="3.1 百分比方案"></a>3.1 百分比方案</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>使用 <strong>百分比%</strong> 定义 <strong>宽度</strong>，<strong>高度</strong> 用**<code>px</code>**固定，根据可视区域实时尺寸进行调整，尽可能适应各种分辨率，通常使用<code>max-width</code>/<code>min-width</code>控制尺寸范围过大或者过小。下表是子元素不同属性设置百分比的依据</p></blockquote><table><thead><tr><th align="left">属性</th><th align="left">设置参考</th></tr></thead><tbody><tr><td align="left"><code>height</code>/<code>width</code></td><td align="left">基于子元素的直接父元素，<code>width</code>相对于父元素的<code>width</code>，<code>height</code>相对于父元素的<code>height</code></td></tr><tr><td align="left"><code>top</code>/<code>bottom</code> 和<code>left</code>/<code>right</code></td><td align="left">相对于直接非<code>static</code>定位的父元素的<code>height</code>/<code>width</code></td></tr><tr><td align="left"><code>padding</code>/<code>margin</code></td><td align="left">不论是垂直方向或者是水平方向，都相对于直接父亲元素的<code>width</code>，与父元素的<code>height</code>无关。</td></tr><tr><td align="left"><code>border-radius</code></td><td align="left">相对于自身的宽度</td></tr></tbody></table><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><blockquote><p>简单，不存在兼容问题</p></blockquote><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><blockquote><ul><li>如果屏幕尺度跨度太大，相对设计稿过大或者过小的屏幕不能正常显示，在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化。</li><li>设置盒模型的不同属性时，其百分比设置的参考元素不唯一，容易使布局问题变得复杂</li></ul></blockquote><h3 id="3-2-rem-方案"><a href="#3-2-rem-方案" class="headerlink" title="3.2 rem 方案"></a>3.2 rem 方案</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote><p><strong>rem</strong> 是相对长度单位，rem方案中的样式设计为相对于 <strong>根元素</strong> <code>font-size</code>计算值的倍数。根据 <strong>屏幕宽度</strong> 设置<code>html</code>标签的<code>font-size</code>，在布局时使用 <strong>rem</strong> 单位布局，达到自适应的目的，是 <strong>弹性布局</strong> 的一种实现方式。</p></blockquote><blockquote><p><strong>实现过程：</strong>  首先获取文档根元素和设备<code>dpr</code>，设置 <strong>rem</strong>，在<code>html</code>文档加载和解析完成后调整<code>body</code>字体大小； 在页面<strong>缩放 / 回退 / 前进</strong>的时候， 获取元素的内部宽度 (不包括垂直滚动条，边框和外边距)，重新调整 <strong>rem</strong> 大小。</p></blockquote><blockquote><p><strong>实现方法：</strong>用 <strong>css</strong> 处理器或 <strong>npm</strong> 包将页面 <strong>css</strong> 样式中的<code>px</code>自动转换成 <strong>rem</strong>。在整个 <strong>flexible</strong> 适配方案中，文本使用<code>px</code>作为单位，使用<code>[data-dpr]</code>属性来区分不同<code>dpr</code>下的文本字号。由于手机浏览器对字体显示最小是<code>8px</code>，因此对于小尺寸文字需要采用<code>px</code>为单位，防止通过 <strong>rem</strong> 转化后出现显示问题。<strong>手机淘宝</strong>中的字体使用<code>px</code>为单位，<strong>腾讯新闻</strong>中的字体使用<code>rem</code>为单位。</p></blockquote><p><strong>贴上源码分析：</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>win<span class="token punctuation">,</span> lib<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> doc <span class="token operator">=</span> win<span class="token punctuation">.</span>document<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//当前文档对象</span>    <span class="token keyword">var</span> docEl <span class="token operator">=</span> doc<span class="token punctuation">.</span>documentElement<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//文档对象根元素的只读属性</span>    <span class="token keyword">var</span> metaEl <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'meta[name="viewport"]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> flexibleEl <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'meta[name="flexible"]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> dpr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> scale <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> tid<span class="token punctuation">;</span>    <span class="token keyword">var</span> flexible <span class="token operator">=</span> lib<span class="token punctuation">.</span>flexible <span class="token operator">||</span> <span class="token punctuation">(</span>lib<span class="token punctuation">.</span>flexible <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>metaEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//当meta中viewport的标签设置了scale时，将根据scale手动设置dpr</span>        console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'将根据已有的meta标签来设置缩放比例'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> match <span class="token operator">=</span> metaEl<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/initial\-scale=([\d\.]+)/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>match<span class="token punctuation">)</span> <span class="token punctuation">{</span>            scale <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dpr <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> scale<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flexibleEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//当meta中flexible的标签存在时，据此设置dpr</span>        <span class="token keyword">var</span> content <span class="token operator">=</span> flexibleEl<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> initialDpr <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/initial\-dpr=([\d\.]+)/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> maximumDpr <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/maximum\-dpr=([\d\.]+)/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>initialDpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dpr <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>initialDpr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                scale <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> dpr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maximumDpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dpr <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>maximumDpr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                scale <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> dpr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dpr <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//根据js获取到的devicePixelRatio设置dpr及scale，scale是dpr的倒数</span>        <span class="token keyword">var</span> isAndroid <span class="token operator">=</span> win<span class="token punctuation">.</span>navigator<span class="token punctuation">.</span>appVersion<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/android/gi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> isIPhone <span class="token operator">=</span> win<span class="token punctuation">.</span>navigator<span class="token punctuation">.</span>appVersion<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/iphone/gi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> devicePixelRatio <span class="token operator">=</span> win<span class="token punctuation">.</span>devicePixelRatio<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isIPhone<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// iOS下，对于2和3的屏，分别用2和3倍方案</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>devicePixelRatio <span class="token operator">>=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>dpr <span class="token operator">||</span> dpr <span class="token operator">>=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                dpr <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>devicePixelRatio <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>dpr <span class="token operator">||</span> dpr <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dpr <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dpr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 其他设备下，仍旧使用1倍的方案</span>            dpr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        scale <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> dpr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    docEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'data-dpr'</span><span class="token punctuation">,</span> dpr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//文本字号不建议使用rem，flexible适配方案中，文本使用px作为单位，使用[data-dpr]属性来区分不同dpr下的文本字号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>metaEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//添加meta标签，设置name为viewport，content根据scale设置缩放比(默认、最大、最小缩放比)</span>        metaEl <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'meta'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        metaEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'viewport'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        metaEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">,</span> <span class="token string">'initial-scale='</span> <span class="token operator">+</span> scale <span class="token operator">+</span> <span class="token string">', maximum-scale='</span> <span class="token operator">+</span> scale <span class="token operator">+</span> <span class="token string">', minimum-scale='</span> <span class="token operator">+</span> scale <span class="token operator">+</span> <span class="token string">', user-scalable=no'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>docEl<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>            docEl<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>metaEl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> wrap <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            wrap<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>metaEl<span class="token punctuation">)</span><span class="token punctuation">;</span>            doc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>wrap<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">refreshRem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//更新rem值</span>        <span class="token keyword">var</span> width <span class="token operator">=</span> docEl<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>width <span class="token operator">/</span> dpr <span class="token operator">></span> <span class="token number">540</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            width <span class="token operator">=</span> <span class="token number">540</span> <span class="token operator">*</span> dpr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> rem <span class="token operator">=</span> width <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1rem = viewWidth / 10</span>        docEl<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> rem <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>        flexible<span class="token punctuation">.</span>rem <span class="token operator">=</span> win<span class="token punctuation">.</span>rem <span class="token operator">=</span> rem<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//resize与pageshow延时300ms触发refreshRem(),使用防抖函数，防止事件被高频触发可能引起性能问题</span>    win<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'resize'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>        tid <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>refreshRem<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'pageshow'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//当一条会话历史纪录被执行的时候触发事件，包括后退/前进按钮，同时会在onload页面触发后初始化页面时触发</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>persisted<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//表示网页是否来自缓存</span>            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>            tid <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>refreshRem<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在html文档加载和解析完成后设置body元素字体大小</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token string">'complete'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        doc<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token number">12</span> <span class="token operator">*</span> dpr <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        doc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            doc<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token number">12</span> <span class="token operator">*</span> dpr <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//浏览器有最小字体限制，css在pc上font-size是12px(移动端最小是8px), 也就是css像素是12，其DPR为1，在移动端dpr有可能为2和3，为了保证字体不变小，需要用12*dpr进行换算。</span>       <span class="token function">refreshRem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//实现rem与px相互转换</span>    flexible<span class="token punctuation">.</span>dpr <span class="token operator">=</span> win<span class="token punctuation">.</span>dpr <span class="token operator">=</span> dpr<span class="token punctuation">;</span>    flexible<span class="token punctuation">.</span>refreshRem <span class="token operator">=</span> refreshRem<span class="token punctuation">;</span>    flexible<span class="token punctuation">.</span>rem2px <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> val <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>rem<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> d <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/rem$/</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            val <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'px'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    flexible<span class="token punctuation">.</span>px2rem <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> val <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>rem<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> d <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/px$/</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            val <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'rem'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> window<span class="token punctuation">[</span><span class="token string">'lib'</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>window<span class="token punctuation">[</span><span class="token string">'lib'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><blockquote><p>兼容性好</p></blockquote><ul><li><p>ios: 6.1系统以上都支持</p></li><li><p>android: 2.1系统以上都支持</p></li><li><p>大部分主流浏览器都支持</p><p><img src="3.2.png"></p></li></ul><blockquote><ul><li>相较于之前的静态布局和百分比方案，页面不会因为伸缩发生变形，自适应效果更佳。</li></ul></blockquote><h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4><blockquote><ul><li><strong>不是纯css移动适配方案，需要引入js脚本</strong> 在头部内嵌一段 <code>js</code>脚本 <strong>监听分辨率的变化来动态改变根元素的字体大小</strong>，<code>css</code>样式和 <code>js</code> 代码有一定 <strong>耦合性</strong>，并且必须将改变<code>font-size</code>的代码放在 <strong>css</strong> 样式之前。</li><li><strong>小数像素问题：</strong>通过 <strong>rem</strong> 计算后可能会出现小数像素，浏览器会对这部分小数四舍五入，按照整数渲染。浏览器在渲染时所做的摄入处理只是应用在元素的尺寸渲染上，其真实占据的空间依旧是原始大小。也就是说如果一个元素尺寸是 <code>0.625px</code>，那么其渲染尺寸应该是 <code>1px</code>，空出的 <code>0.375px</code> 空间由其临近的元素填充；同样道理，如果一个元素尺寸是 <code>0.375px</code>，其渲染尺寸就应该是<code>0</code>，但是其会占据临近元素 <code>0.375px</code> 的空间。会导致：<strong>缩放到低于<code>1px</code>的元素时隐时现</strong>（解决办法：指定最小转换像素，对于比较小的像素，不转换为 <strong>rem</strong> 或 <strong>vw</strong>）；两个同样宽度的元素因为各自周围的元素宽度不同，导致两元素相差<code>1px</code>；宽高相同的正方形，长宽不等了；<code>border-radius: 50%</code> 画的圆不圆。</li><li><strong>Android 浏览器下 line-height 垂直居中偏离的问题</strong>。常用的垂直居中方式就是使用line-height，这种方法在Android设备下并不能完全居中。</li><li><strong>cursor: pointer 元素点击背景变色的问题</strong>，对添加了 cursor:pointer 属性的元素，在移动端点击时，背景会高亮。为元素添加<code>tag-highlight-color:transparent</code> 属性可以隐藏背景高亮。</li></ul></blockquote><h3 id="3-3-vh-vw-方案"><a href="#3-3-vh-vw-方案" class="headerlink" title="3.3 vh / vw 方案"></a>3.3 vh / vw 方案</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p><strong>视口</strong>是浏览器中用于呈现网页的区域，移动端的视口通常指的是 <strong>布局视口</strong></p><ul><li><strong>vw</strong> : <strong>1vw</strong> 等于 <strong>视口宽度</strong> 的 <strong>1%</strong></li><li><strong>vh</strong> : <strong>1vh</strong>  等于 <strong>视口高度</strong> 的 **1% **</li><li><strong>vmin</strong> : 选取 <strong>vw</strong> 和 <strong>vh</strong> 中 <strong>最小</strong> 的那个</li><li><strong>vmax</strong> : 选取 <strong>vw</strong> 和 <strong>vh</strong> 中 <strong>最大</strong> 的那个</li></ul><p>使用 <strong>css</strong> 预处理器把设计稿尺寸转换为 <strong>vw</strong> 单位，包括 <strong>文本</strong>，<strong>布局高宽</strong>，<strong>间距</strong> 等，使得这些元素能够随视口大小自适应调整。以<code>1080px</code>设计稿为基准，转化的计算表示为：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 以1080px作为设计稿基准</span>$vw_base<span class="token punctuation">:</span> <span class="token number">1080</span>@<span class="token keyword">function</span> <span class="token function">vw</span><span class="token punctuation">(</span>$px<span class="token punctuation">)</span> <span class="token punctuation">{</span>    @<span class="token keyword">return</span><span class="token punctuation">(</span>$px <span class="token operator">/</span> <span class="token number">1080</span><span class="token punctuation">)</span> <span class="token operator">*</span> 100vw<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><blockquote><ul><li>纯 <strong>css</strong> 移动端适配方案，不存在脚本依赖问题。</li><li>相对于 <strong>rem</strong> 以<strong>根元素字体大小的倍数</strong> 定义 <strong>元素大小</strong>，逻辑清晰简单，视口单位依赖于视口的尺寸 <code>"1vw ＝ 1/100 viewport width"</code>，根据 <strong>视口尺寸的百分比</strong> 来定义 <strong>元素宽度</strong>。</li></ul></blockquote><h4 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h4><blockquote><ul><li>存在一些兼容性问题，Android4.4以下不支持</li></ul></blockquote><p><img src="3.3.png"></p><h3 id="3-4-rem-vw-vh-方案"><a href="#3-4-rem-vw-vh-方案" class="headerlink" title="3.4 rem + vw / vh 方案"></a>3.4 rem + vw / vh 方案</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><blockquote><p><strong>vw / vh</strong>  方案能够实现宽度和高度的自适应，并且逻辑清晰，由于其被支持得较晚，所以存在一定的兼容性问题。将  <strong>vw/vh</strong>  方案与 <strong>rem</strong> 方案相结合，<strong>给根元素设置随视口变化的 vw 单位</strong>，可以通过 <code>postcss-plugin-vwtorem</code> 将其转换。具体的<strong>计算过程</strong>为：</p></blockquote><blockquote><p>对于<code>1080px</code>宽的设计稿，设置默认根字号的大小为<code>100px</code>，那么设计稿中<code>1px</code>对应的是 <code>100vw/1080 = 0.0925926vw</code>，并且 <code>1rem = 100px</code>，也就可以得到<code>1rem = 9.256926vw</code></p></blockquote><blockquote><p>同时可以使用媒体查询限制根元素的最大最小值，实现对页面的最大最小宽度限制，对用户的视觉体验更好。</p></blockquote><h4 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h4><blockquote><p><strong>rem</strong> 弹性布局方式作为移动端web页面适配方法，后期从 <strong>rem</strong> 过渡到 <strong>vw</strong> ，只需要通过 <strong>改变根元素大小的计算方式</strong> 不需要其他处理。<strong>vw</strong> 将会成为一种更好的适配方式，目前由于兼容性的原因得不到广泛应用。<strong>rem + vw / vh</strong>  不存在 <strong>vw/vh</strong> 的兼容性问题，可以成为由 <strong>rem</strong> 向 <strong>vw / vh</strong> 转变的一种过渡方案。</p></blockquote><h3 id="3-5-基于媒体查询的响应式设计"><a href="#3-5-基于媒体查询的响应式设计" class="headerlink" title="3.5 基于媒体查询的响应式设计"></a>3.5 基于媒体查询的响应式设计</h3><p><strong>响应式设计</strong> 使得一个网站同时适配 <strong>多种设备</strong> 和 <strong>多个屏幕</strong>，让网站的布局和功能随用户的使用环境（屏幕大小、输出方式、设备/浏览器能力而变化），使其视觉合理，交互方式符合习惯。如使得内容区块可伸缩与自由排布，边距适应页面尺寸，图片适应比例变化，能够自动隐藏/部分显示内容，能自动折叠导航和菜单。</p><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><blockquote><p>主要实现是通过 <strong>媒体查询</strong>，通过给不同分辨率的设备编写不同的样式实现响应式布局，用于解决不同设备不同分辨率之间兼容问题，一般是指PC、平板、手机设备之间较大的分辨率差异。实现上不局限于具体的方案，通常结合了 <strong>流式布局</strong> <code>+</code> <strong>弹性布局</strong> 方案。比如给小屏幕手机设置 <code>@2x</code> 图，为大屏手机设置 <code>@3x</code> 图</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript">@media only screen and <span class="token punctuation">(</span>min<span class="token operator">-</span>width<span class="token punctuation">:</span> 375px<span class="token punctuation">)</span><span class="token punctuation">{</span>    样式<span class="token number">1</span><span class="token punctuation">}</span>@media only screen and <span class="token punctuation">(</span>min<span class="token operator">-</span>width<span class="token punctuation">:</span> <span class="token number">750</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    样式<span class="token number">2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><blockquote><p>能够使网页在不同设备、不同分辨率屏幕上呈现合理布局，不仅仅是样式伸缩变换</p></blockquote><h4 id="不足-3"><a href="#不足-3" class="headerlink" title="不足"></a>不足</h4><blockquote><ul><li>要匹配足够多的设备与屏幕，一个web页面需要多个设计方案，工作量比较大</li><li>通过媒体查询技术需要设置一定量的断点，到达某个断点前后的页面发生显著变化，用户体验不太友好</li></ul></blockquote><h2 id="四、移动端web页面适配方案中的通用问题"><a href="#四、移动端web页面适配方案中的通用问题" class="headerlink" title="四、移动端web页面适配方案中的通用问题"></a>四、移动端web页面适配方案中的通用问题</h2><h3 id="4-1-像素问题"><a href="#4-1-像素问题" class="headerlink" title="4.1 像素问题"></a>4.1 像素问题</h3><blockquote><p>设置边框 为<code>1px</code> <strong>css</strong>像素，在 <strong>普通屏幕</strong> 下<code>1px</code>，<strong>高清屏幕</strong> (<code>dpr</code>为<code>2</code>)下<code>2px</code>的情况。是由于不同移动设备的<code>dpr</code>不同，导致<code>1px</code> <strong>css</strong>像素，转换成物理像素后显示不一样。</p></blockquote><h4 id="4-1-1-设置scale-为-1-dpr"><a href="#4-1-1-设置scale-为-1-dpr" class="headerlink" title="4.1.1 设置scale 为 1/dpr"></a>4.1.1 设置scale 为 1/dpr</h4><blockquote><p><strong>css</strong> 中涉及<code>1</code>像素的地方仍然使用<code>px</code>作为单位，设置<code>&lt;meta&gt;</code> 标签中 <code>initial-scale = 1/dpr</code> ，将整个页面缩小<code>dpr</code>倍，对于页面采用 <strong>rem</strong> 方案的情况，将页面的 <strong>根字体</strong> 再放大<code>dpr</code>倍，这个时候就能够在不改变页面其他布局的情况下，保持边框的 <strong>css</strong> 像素为<code>1px</code>。</p></blockquote><h4 id="4-1-2-transform-的-scale-属性"><a href="#4-1-2-transform-的-scale-属性" class="headerlink" title="4.1.2 transform 的 scale 属性"></a>4.1.2 transform 的 scale 属性</h4><blockquote><p><code>transform</code>的<code>scale</code>属性允许对元素进行缩放，其中<code>scaleY(y)</code>通过设置Y轴的值来定义缩放转换，并结合伪元素使用，通过<code>transform-origin: 50% 0%</code>修改元素变换的中心点实现。针对横着的边框线用<code>scaleY(y)</code>，针对竖着的边框线要用<code>scaleX(x)</code>，针对一圈的边框线用<code>scale()</code>，并且需要注意转移元素变换中心点。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token selector">//针对竖着的边框线<span class="token class">.className:</span> before </span><span class="token punctuation">{</span>  //其他样式  <span class="token property">transform-origin</span><span class="token punctuation">:</span> <span class="token number">50%</span> <span class="token number">0%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@media</span> only screen and <span class="token punctuation">(</span><span class="token property">-webkit-min-device-pixel-ratio</span><span class="token punctuation">:</span> 2<span class="token punctuation">)</span></span> <span class="token punctuation">{</span> <span class="token selector">//dpr为2时  <span class="token class">.className:</span> before </span><span class="token punctuation">{</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleY</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@media</span> only screen and <span class="token punctuation">(</span><span class="token property">-webkit-min-device-pixel-ratio</span><span class="token punctuation">:</span> 3<span class="token punctuation">)</span></span> <span class="token punctuation">{</span> <span class="token selector">//dpr为3时  <span class="token class">.className:</span> before </span><span class="token punctuation">{</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleY</span><span class="token punctuation">(</span><span class="token number">0.33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-border-image-属性"><a href="#4-1-3-border-image-属性" class="headerlink" title="4.1.3 border-image 属性"></a>4.1.3 border-image 属性</h4><blockquote><p>使用<code>border-image</code>，在元素的边框上设置一个一半透明一半显示的图片。</p></blockquote><h3 id="4-2-对图片的处理"><a href="#4-2-对图片的处理" class="headerlink" title="4.2 对图片的处理"></a>4.2 对图片的处理</h3><blockquote><p>加载网页时，平均<code>60%</code>以上的流量来自 <strong>加载图片</strong>。指定图像宽度时使用<strong>相对单位</strong>，<strong>防止意外溢出视口</strong>，如 <code>width: 50%</code>，将图片宽度设置为包含元素宽度的 <code>50%</code>。因为 <strong>css</strong> 允许内容溢出容器， 需要使用**<code>max-width: 100%</code> 来保证图像及其他内容不会溢出<strong>。使用 img 元素的 <code>alt</code> 属性提供描述，描述有助于提高网站的可访问性，能提供语境给屏幕阅读器及其他辅助性技术。</strong>维护自适应页面中图片宽高比固定<strong>比较常用的方法是使用</strong><code>padding</code>**设置。对于不同<code>dpr</code>以及不同分辨率/尺寸的屏幕，为了避免资源浪费和等待时间延长，需要针对不同的屏幕使用合适的图片，加载的图片分为通过标签引入的图片和背景图片。</p></blockquote><h4 id="4-2-1-srcse-和-sizes"><a href="#4-2-1-srcse-和-sizes" class="headerlink" title="4.2.1 srcse 和 sizes"></a>4.2.1 srcse 和 sizes</h4><blockquote><p><strong>对于<code>&lt;img&gt;</code>引入的图片，如果想要图片适应不同像素密度的屏幕，并且屏幕上显示图片的实际尺寸相同，使用</strong><code>srcset</code><strong>属性用来指定多张图像。</strong>它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，后接是像素密度描述符。浏览器根据当前设备的像素密度，选择需要加载的图像。如果<code>srcset</code>属性都不满足条件，那么就加载<code>src</code>属性指定的默认图像。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo-320w.jpg,             foo-480w.jpg 1.5x,             foo-640w.jpg 2x<span class="token punctuation">"</span></span>     <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo-640w.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token comment" spellcheck="true">&lt;!--srcset属性给出了三个图像URL，适应三种不同的像素密度， 后面的像素密度描述符，格式是像素密度倍数 + 字母x。1x表示单倍像素密度，可以省略。--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>如果想要针对不同屏幕，使用不同分辨率版本和尺寸的图片，使用属性<code>srcse</code> 和 <code>sizes</code> 。<a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">srcset</a> 定义了允许浏览器选择的图像集，以及每个图像的大小（使用w单位）。<code>sizes</code>定义了一组媒体条件（例如屏幕宽度），指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。</strong></p></blockquote><pre class="line-numbers language-html"><code class="language-html">&lt;img srcset = "elva-fairy-320w.jpg 320w,               elva-fairy-480w.jpg 480w,               elva-fairy-800w.jpg 800w"     sizes = "(max-width: 320px) 280px,              (max-width: 480px) 440px,              800px"     src = "elva-fairy-800w.jpg" alt="Elva dressed as a fairy"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>浏览器的查询过程：</p></blockquote><ul><li>查看设备宽度；</li><li>检查<code>sizes</code>列表中哪个媒体条件是第一个为真；</li><li>查看给予该媒体查询的槽大小；</li><li>加载<code>srcset</code>列表中引用的最接近所选的槽大小的图像</li></ul><h4 id="4-2-2-异步加载"><a href="#4-2-2-异步加载" class="headerlink" title="4.2.2 异步加载"></a>4.2.2 异步加载</h4><blockquote><p><strong>&lt; img&gt; 引入的图片，使用js自带的异步加载图片。</strong>根据不同的<code>dpr</code>，加载不同分辨率的图片。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img<span class="token punctuation">"</span></span> <span class="token attr-name">data-src1x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx@1x.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">data-src2x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx@2x.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">data-src3x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx@3x.jpg<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> dpr <span class="token operator">=</span> window<span class="token punctuation">.</span>devicePixelRatio<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>dpr <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    dpr <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> imgSrc <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token operator">+</span>dpr<span class="token operator">+</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>img<span class="token punctuation">.</span>src <span class="token operator">=</span> imgSrc<span class="token punctuation">;</span>img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>imgObj<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span>imgObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//替换img对象</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-3-picture"><a href="#4-2-3-picture" class="headerlink" title="4.2.3 picture"></a>4.2.3 picture</h4><blockquote><p><strong>为不同的视口提供不同的图片，使用<code>&lt;picture&gt;</code>标签。</strong><code>&lt;picture&gt;</code>是<code>html5</code>中定义的一个容器标签，内部使用<code>&lt;source&gt;</code>和<code>&lt;image&gt;</code>，<strong>浏览器会匹配<code>&lt;source&gt;</code>的<code>type</code>,<code>media</code>,<code>srcset</code>等属性，找到最适合当前布局 / 视口宽度 / 设备像素密度的图像进行加载。</strong>这里的<code>&lt;img&gt;</code>标签是浏览器不支持<code>picture</code>元素，或者支持<code>picture</code>但没有合适的媒体定义时的后备，不能省略。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(min-width: 30px)<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cat-vertical.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(min-width: 60px)<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cat-horizontal.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cat.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-4-Image-set"><a href="#4-2-4-Image-set" class="headerlink" title="4.2.4 Image-set"></a>4.2.4 Image-set</h4><blockquote><p><strong>对于背景图片，使用<code>image-set</code>根据用户设备的分辨率匹配合适的图像</strong>， 同时要考虑兼容性问题。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token selector"><span class="token class">.css</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(1x.png)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*不支持image-set的情况下显示*/</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">-image-set</span><span class="token punctuation">(</span>            <span class="token url">url(1x.png)</span> <span class="token number">1</span>x,<span class="token comment" spellcheck="true">/* 支持image-set的浏览器的[普通屏幕]下 */</span>            <span class="token url">url(2x.png)</span> <span class="token number">2</span>x,<span class="token comment" spellcheck="true">/* 支持image-set的浏览器的[2倍Retina屏幕] */</span>            <span class="token url">url(3x.png)</span> <span class="token number">3</span>x<span class="token comment" spellcheck="true">/* 支持image-set的浏览器的[3倍Retina屏幕] */</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-5-media-query"><a href="#4-2-5-media-query" class="headerlink" title="4.2.5 media query"></a>4.2.5 media query</h4><blockquote><p><strong>对于背景图片，使用媒体查询自动切换不同分辨率的版本</strong></p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token comment" spellcheck="true">/* 普通显示屏(设备像素比例小于等于1)使用1倍的图 */</span><span class="token selector"><span class="token class">.css</span></span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(img_1x.png)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 高清显示屏(设备像素比例大于等于2)使用2倍图  */</span><span class="token atrule"><span class="token rule">@media</span> only screen and <span class="token punctuation">(</span><span class="token property">min-device-pixel-ratio</span><span class="token punctuation">:</span>2<span class="token punctuation">)</span></span><span class="token punctuation">{</span>    <span class="token selector"><span class="token class">.css</span></span><span class="token punctuation">{</span>        <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(img_2x.png)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 高清显示屏(设备像素比例大于等于3)使用3倍图  */</span><span class="token atrule"><span class="token rule">@media</span> only screen and <span class="token punctuation">(</span><span class="token property">min-device-pixel-ratio</span><span class="token punctuation">:</span>3<span class="token punctuation">)</span></span><span class="token punctuation">{</span>    <span class="token selector"><span class="token class">.css</span></span><span class="token punctuation">{</span>        <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(img_3x.png)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><blockquote><p><strong>对于国内的一些网站，通过查看网页源代码发现，它可能不是某一种方案的单独使用，而是几种方案的结合。一个页面上，元素的宽度设置上有百分比，也有<code>rem</code>，字体的样式中有<code>rem</code>，有<code>em</code>，也有固定大小的<code>px</code>；在屏幕宽度过大时不再缩放，也会用到媒体查询，并且响应式设计更多地可能是针对不同设备间的自适应。对于移动端 web 页面的自适应方案来说，现在用的比较多的是<code>rem</code>，逐渐向<code>vw/vh</code>发展，而<code>rem + vw / vh</code>则是作为<code>vw / vh</code>向后兼容的一种过渡。</strong></p><p><strong>各种方案的具体代码示例可以参考<a href="https://www.cnblogs.com/tylerdonet/p/10146632.html">这篇文章</a>。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速进阶 Vue 3.0</title>
      <link href="/2020/12/08/04.vue-3.0/"/>
      <url>/2020/12/08/04.vue-3.0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>2020年09月18日，<code>Vue.js 3.0</code> 正式发布，属实是：可喜可贺，可喜可贺…尤大大辛苦惹，我宣布GG思密达~</p><h3 id="1-1-历程"><a href="#1-1-历程" class="headerlink" title="1.1 历程"></a>1.1 历程</h3><ul><li>3.0版本代表了2年多的开发工作</li><li>具有30多个RFC</li><li>2600多个提交</li><li>来自99个贡献者</li><li>628个拉取请求</li><li>大量开发和文档工作</li></ul><h3 id="1-2-Vue-的使命"><a href="#1-2-Vue-的使命" class="headerlink" title="1.2 Vue 的使命"></a>1.2 Vue 的使命</h3><blockquote><p>成为任何人都可以快速学习的易于接近的框架</p></blockquote><h2 id="二、Vue-3-0-项目搭建"><a href="#二、Vue-3-0-项目搭建" class="headerlink" title="二、Vue 3.0 项目搭建"></a>二、Vue 3.0 项目搭建</h2><h3 id="2-1-项目初始化"><a href="#2-1-项目初始化" class="headerlink" title="2.1 项目初始化"></a>2.1 项目初始化</h3><p>第一步，安装 <strong>Vue-cli</strong>：</p><pre><code>npm install -g @vue/cli</code></pre><p>注意以下命令是错误的！</p><pre><code>npm install -g vuenpm install -g vue-cli</code></pre><p>安装成功后，我们即可使用 <strong>vue</strong> 命令，测试方法：</p><pre><code>$ vue -V@vue/cli 4.3.1</code></pre><p>第二步，初始化 <strong>Vue</strong> 项目：</p><pre><code>vue create vue-next-test</code></pre><p>输入命令后，会出现命令行交互窗口，在这里我们选择 Manually select features：</p><pre><code>Vue CLI v4.3.1? Please pick a preset:   default (babel, eslint) ❯ Manually select features </code></pre><pre><code>随后我们勾选：Router、Vuex、CSS Pre-processors和Linter/Formatter这些都是开发商业级项目必须的！</code></pre><pre><code>Vue CLI v4.3.1? Please pick a preset: Manually select features? Check the features needed for your project:  ◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ◉ Router ◉ Vuex ◉ CSS Pre-processors❯◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing</code></pre><pre><code>注意：Vue 3.0 项目目前需要从 Vue 2.0 项目升级而来，所以为了直接升级到 Vue 3.0 全家桶。我们需要在 Vue 项目创建过程中勾选 Router 和 Vuex，所以避免手动写初始化代码。</code></pre><h3 id="2-2-升级-Vue-3-0-项目"><a href="#2-2-升级-Vue-3-0-项目" class="headerlink" title="2.2 升级 Vue 3.0 项目"></a>2.2 升级 Vue 3.0 项目</h3><p>目前创建 Vue 3.0 项目需要通过插件升级的方式实现。</p><p><strong>Vue-cli</strong> 还没有直接支持，我们进入项目目录，并输入以下指令：</p><pre><code>cd vue-next-testvue add vue-next</code></pre><p>执行自动安装 <strong>vue-cli-plugin-vue-next</strong> 插件（查看<a href="https://github.com/vuejs/vue-cli-plugin-vue-next">项目代码</a>），该插件会完成以下操作：</p><ul><li>安装 Vue 3.0 依赖</li><li>更新 Vue 3.0 webpack loader 配置，使其能够支持 .vue 文件构建（这点非常重要）</li><li>创建 Vue 3.0 的模板代码</li><li>自动将代码中的 Vue Router 和 Vuex 升级到 4.0 版本，如果未安装则不会升级</li><li>自动生成 Vue Router 和 Vuex 模板代码</li></ul><p>完成上述操作后，项目正式升级到 Vue 3.0</p><p>注意该插件还不支持 typescript，用 typescript 的童鞋还得再等等。（就是目前还不太支持TS）</p><h3 id="2-3-Vue-3-0-基本特性体验"><a href="#2-3-Vue-3-0-基本特性体验" class="headerlink" title="2.3 Vue 3.0 基本特性体验"></a>2.3 Vue 3.0 基本特性体验</h3><p>下面我们从项目开发的角度逐步体验 Vue 3.0 的开发流程</p><h4 id="2-3-1-创建路由"><a href="#2-3-1-创建路由" class="headerlink" title="2.3.1 创建路由"></a>2.3.1 创建路由</h4><p>项目开发中，我们通常需要创建新页面，然后添加路由配置。</p><p>我们在 /src/views 目录下创建 Test.vue：</p><pre><code>&lt;template&gt;  &lt;div class="test"&gt;　　  &lt;h1&gt;vue3.0 初体验&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default {}&lt;/script&gt;&lt;style lang="less" scoped&gt;&lt;/style&gt;</code></pre><p>之后在 /src/router/index.js 中创建路由配置：</p><pre><code>import { createRouter, createWebHashHistory } from 'vue-router'import Home from '../views/Home.vue'const routes = [  {    path: '/',    name: 'Home',    component: Home  },  {    path: '/about',    name: 'About',    component: () =&gt; import(/* webpackChunkName: "about" */ '../views/About.vue')  },  {    path: '/test',    name: 'Test',    component: () =&gt; import(/* webpackChunkName: "test" */ '../views/Test.vue')  }]const router = createRouter({  history: createWebHashHistory(),  routes})export default router</code></pre><p>初始化 Vue Router 的过程与 3.0 版本变化不大，只是之前采用构造函数的方式，这里改为使用 createRouter 来创建 Vue Router 实例，配置的方法基本一致，配置完成后我们还需要在 App.vue 中增加链接到 Test.vue 的路由：</p><pre><code>&lt;template&gt;  &lt;div id="app"&gt;    &lt;div id="nav"&gt;      &lt;router-link to="/"&gt;Home&lt;/router-link&gt; |      &lt;router-link to="/about"&gt;About&lt;/router-link&gt; |      &lt;router-link to="/test"&gt;Test&lt;/router-link&gt;    &lt;/div&gt;    &lt;router-view/&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>启动项目：</p><pre><code>npm run serve</code></pre><h4 id="2-3-2-状态和事件绑定"><a href="#2-3-2-状态和事件绑定" class="headerlink" title="2.3.2 状态和事件绑定"></a>2.3.2 状态和事件绑定</h4><p>Vue 3.0 中定义状态的方法改为类似 React Hooks 的方法，下面我们在 Test.vue 中定义一个状态 count：</p><pre><code>&lt;template&gt;  &lt;div class="test"&gt;    &lt;h1&gt;test count: {{count}}&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { ref } from 'vue'  export default {    setup () {      const count = ref(0)      return {        count      }    }  }&lt;/script&gt;</code></pre><p>Vue 3.0 中初始化状态通过 setup 方法</p><p>定义状态需要调用 ref 方法。接下来我们定义一个事件，用来更新 count 状态：</p><pre><code>&lt;template&gt;  &lt;div class="test"&gt;    &lt;h1&gt;test count: {{count}}&lt;/h1&gt;    &lt;button @click="add"&gt;add&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { ref } from 'vue'  export default {    setup () {      const count = ref(0)      const add = () =&gt; {        count.value++      }      return {        count,        add      }    }  }&lt;/script&gt;</code></pre><p>这里的 add 方法不再需要定义在 methods 中，但注意更新 count 值的时候不能直接使用 count++，而应使用 count.value++，</p><p>更新代码后，点击按钮，count 的值就会更新了：</p><h4 id="2-3-3-计算属性和监听器"><a href="#2-3-3-计算属性和监听器" class="headerlink" title="2.3.3 计算属性和监听器"></a>2.3.3 计算属性和监听器</h4><p>Vue 3.0 中计算属性和监听器的实现依赖 computed 和 watch 方法：</p><pre><code>&lt;template&gt;  &lt;div class="test"&gt;    &lt;h1&gt;test count: {{count}}&lt;/h1&gt;    &lt;div&gt;count * 2 = {{doubleCount}}&lt;/div&gt;    &lt;button @click="add"&gt;add&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { ref, computed, watch } from 'vue'  export default {    setup () {      const count = ref(0)      const add = () =&gt; {        count.value++      }      watch(() =&gt; count.value, val =&gt; {        console.log(`count is ${val}`)      })      const doubleCount = computed(() =&gt; count.value * 2)      return {        count,        doubleCount,        add      }    }  }&lt;/script&gt;</code></pre><p>计算属性 computed 是一个方法，里面需要包含一个回调函数，当我们访问计算属性返回结果时，会自动获取回调函数的值：</p><pre><code>const doubleCount = computed(() =&gt; count.value * 2)</code></pre><p>监听器 watch 同样是一个方法，它包含 2 个参数，2 个参数都是 function：</p><pre><code>watch(() =&gt; count.value,   val =&gt; {    console.log(`count is ${val}`)  })</code></pre><p>第一个参数是监听的值，count.value 表示当 count.value 发生变化就会触发监听器的回调函数，即第二个参数，第二个参数可以执行监听时候的回调。如果是2 个以上的监听属性 就这样：</p><pre><code>watch(  [refA, () =&gt; refB.value],  ([a, b], [prevA, prevB]) =&gt; {    console.log(`a is: ${a}`)    console.log(`b is: ${b}`)  })</code></pre><h4 id="2-3-4-获取路由"><a href="#2-3-4-获取路由" class="headerlink" title="2.3.4 获取路由"></a>2.3.4 获取路由</h4><p>Vue 3.0 中通过 getCurrentInstance 方法获取当前组件的实例，然后通过 ctx 属性获得当前上下文，</p><p>ctx.$router 是 Vue Router 实例，里面包含了 currentRoute 可以获取到当前的路由信息。</p><pre><code>&lt;script&gt;  import { getCurrentInstance } from 'vue'  export default {    setup () {      const { ctx } = getCurrentInstance()      console.log(ctx.$router.currentRoute.value)    }  }&lt;/script&gt;</code></pre><h3 id="2-4-Vuex-集成"><a href="#2-4-Vuex-集成" class="headerlink" title="2.4 Vuex 集成"></a>2.4 Vuex 集成</h3><p>Vuex 的集成方法如下：</p><h4 id="2-4-1-定义-Vuex-状态"><a href="#2-4-1-定义-Vuex-状态" class="headerlink" title="2.4.1 定义 Vuex 状态"></a>2.4.1 定义 Vuex 状态</h4><p>第一步，修改 src/store/index.js 文件：</p><pre><code>import Vuex from 'vuex'export default Vuex.createStore({  state: {    test: {      a: 1    }  },  mutations: {    setTestA(state, value) {      state.test.a = value    }  },  actions: {  },  modules: {  }})</code></pre><p>Vuex 的语法和 API 基本没有改变,我们在 state 中创建了一个 test.a 状态，在 mutations 中添加了修改 state.test.a 状态的方法： setTestA</p><h4 id="2-4-2-引用-Vuex-状态"><a href="#2-4-2-引用-Vuex-状态" class="headerlink" title="2.4.2 引用 Vuex 状态"></a>2.4.2 引用 Vuex 状态</h4><p>第二步，在 Test.vue 中，通过计算属性使用 Vuex 状态：</p><pre><code>&lt;template&gt;  &lt;div class="test"&gt;    &lt;h1&gt;test count: {{count}}&lt;/h1&gt;    &lt;div&gt;count * 2 = {{doubleCount}}&lt;/div&gt;    &lt;div&gt;state from vuex {{a}}&lt;/div&gt;    &lt;button @click="add"&gt;add&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { ref, computed, watch, getCurrentInstance } from 'vue'  export default {    setup () {      const count = ref(0)      const add = () =&gt; {        count.value++      }      watch(() =&gt; count.value, val =&gt; {        console.log(`count is ${val}`)      })      const doubleCount = computed(() =&gt; count.value * 2)      const { ctx } = getCurrentInstance()      console.log(ctx.$router.currentRoute.value)      const a = computed(() =&gt; ctx.$store.state.test.a)      return {        count,        doubleCount,        add,        a      }    }  }&lt;/script&gt;</code></pre><p>这里我们通过计算属性来引用 Vuex 中的状态：</p><pre><code>const a = computed(() =&gt; ctx.$store.state.test.a)</code></pre><p>ctx 是上节中我们提到的当前组件实例。</p><h4 id="2-4-3-更新-Vuex-状态"><a href="#2-4-3-更新-Vuex-状态" class="headerlink" title="2.4.3 更新 Vuex 状态"></a>2.4.3 更新 Vuex 状态</h4><p>更新 Vuex 状态仍然使用 commit 方法，这点和 Vuex 3.0 版本一致：</p><pre><code>&lt;template&gt;  &lt;div class="test"&gt;    &lt;h1&gt;test count: {{count}}&lt;/h1&gt;    &lt;div&gt;count * 2 = {{doubleCount}}&lt;/div&gt;    &lt;div&gt;state from vuex {{a}}&lt;/div&gt;    &lt;button @click="add"&gt;add&lt;/button&gt;    &lt;button @click="update"&gt;update a&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import { ref, computed, watch, getCurrentInstance } from 'vue'  export default {    setup () {      const count = ref(0)      const add = () =&gt; {        count.value++      }      watch(() =&gt; count.value, val =&gt; {        console.log(`count is ${val}`)      })      const doubleCount = computed(() =&gt; count.value * 2)      const { ctx } = getCurrentInstance()      console.log(ctx.$router.currentRoute.value)      const a = computed(() =&gt; ctx.$store.state.test.a)      const update = () =&gt; {        ctx.$store.commit('setTestA', count)      }      return {        count,        doubleCount,        add,        a,        update      }    }  }&lt;/script&gt;</code></pre><p>这里我们点击 update a 按钮后，会触发 update 方法，此时会通过 ctx.$store.commit 调用 setTestA 方法，将 count 的值覆盖 state.test.a 的值。</p><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>（1）Vue3.0 都写在 <strong>setup</strong> 里，以前的所有数据状态都写在 <strong>data</strong> 里。<br>（2）所有方法都写在 <strong>methods</strong> 里，而现在可根据功能模块把状态和方法等划分在一起，更利于模块化。不过这样对代码习惯和质量要求更高，初学者用 3.0 可能会写的更混乱。<br>（3）貌似 Vue 逐渐 React 化，就怕 Vuex 会被 provide 和 inject 特性替换。</p><h2 id="三、深入剖析"><a href="#三、深入剖析" class="headerlink" title="三、深入剖析"></a>三、深入剖析</h2><h3 id="3-1-剖析-Vue-Composition-API"><a href="#3-1-剖析-Vue-Composition-API" class="headerlink" title="3.1 剖析 Vue Composition API"></a>3.1 剖析 Vue Composition API</h3><p>可以去看<a href="https://vue-composition-api-rfc.netlify.com/">官方地址</a></p><ul><li>Vue 3 使用<code>ts</code>实现了类型推断，新版 API 全部采用普通函数，在编写代码时可以享受完整的类型推断（避免使用装饰器）</li><li>解决了多组件间逻辑重用问题 （解决：高阶组件、mixin、作用域插槽）</li><li>Composition API 使用简单</li></ul><p>先尝鲜<strong>Vue3.0</strong>看看效果</p><pre><code>&lt;script src="vue.global.js"&gt;&lt;/script&gt;&lt;div id="container"&gt;&lt;/div&gt;&lt;script&gt;    function usePosition(){ // 实时获取鼠标位置        let state = Vue.reactive({x:0,y:0});        function update(e) {            state.x= e.pageX            state.y = e.pageY        }        Vue.onMounted(() =&gt; {            window.addEventListener('mousemove', update)        })        Vue.onUnmounted(() =&gt; {            window.removeEventListener('mousemove', update)        })        return Vue.toRefs(state);    }    const App = {        setup(){ // Composition API 使用的入口            const state  = Vue.reactive({name:'youxuan'}); // 定义响应数据            const {x,y} = usePosition(); // 使用公共逻辑            Vue.onMounted(()=&gt;{                console.log('当组挂载完成')            });            Vue.onUpdated(()=&gt;{                console.log('数据发生更新')            });            Vue.onUnmounted(()=&gt;{                console.log('组件将要卸载')            })            function changeName(){                state.name = 'webyouxuan';            }            return { // 返回上下文,可以在模板中使用                state,                changeName,                x,                y            }        },        template:`&lt;button @click="changeName"&gt;{{state.name}} 鼠标x: {{x}} 鼠标: {{y}}&lt;/button&gt;`    }    Vue.createApp().mount(App,container);&lt;/script&gt;</code></pre><blockquote><p>到这里你会发现<strong>响应式</strong>才是<code>Vue</code>的灵魂</p></blockquote><h3 id="3-2-源码目录剖析"><a href="#3-2-源码目录剖析" class="headerlink" title="3.2 源码目录剖析"></a>3.2 源码目录剖析</h3><p>packages目录中包含着 <code>Vue3.0</code> 所有功能</p><pre><code>├── packages│   ├── compiler-core # 所有平台的编译器│   ├── compiler-dom # 针对浏览器而写的编译器│   ├── reactivity # 数据响应式系统│   ├── runtime-core # 虚拟 DOM 渲染器 ，Vue 组件和 Vue 的各种API│   ├── runtime-dom # 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等。│   ├── runtime-test # 专门为测试写的runtime│   ├── server-renderer # 用于SSR│   ├── shared # 帮助方法│   ├── template-explorer│   └── vue # 构建vue runtime + compiler</code></pre><p><strong>compiler</strong><br><code>compiler-core</code>主要功能是暴露编译相关的<code>API</code>以及<code>baseCompile</code>方法<br><code>compiler-dom</code>基于<code>compiler-core</code>封装针对浏览器的<code>compiler</code> (对浏览器标签进行处理)</p><p><strong>runtime</strong><br><code>runtime-core</code> 虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API<br><code>runtime-test</code>将<code>DOM</code>结构格式化成对象，方便测试<br><code>runtime-dom</code> 基于<code>runtime-core</code>编写的浏览器的<code>runtime</code> (增加了节点的增删改查，样式处理等)，返回<code>render</code>、<code>createApp</code>方法</p><p><strong>reactivity</strong><br>单独的数据响应式系统，核心方法<code>reactive</code>、<code>effect</code>、 <code>ref</code>、<code>computed</code></p><p><strong>vue</strong><br>整合 <code>compiler</code> + <code>runtime</code></p><blockquote><p>到此我们解析了<code>Vue3.0</code>结构目录，整体来看整个项目还是非常清晰的</p></blockquote><p>再来尝尝鲜：<br>我们可以根据官方的测试用例来看下如何使用<code>Vue3.0</code></p><pre><code>const app = {    template:`&lt;div&gt;{{count}}&lt;/div&gt;`,    data(){        return {count:100}    },}let proxy = Vue.createApp().mount(app,container);setTimeout(()=&gt;{    proxy.count = 200;},2000)</code></pre><blockquote><p>接下来我们来对比 Vue 2 和 Vue 3 中的响应式原理区别</p></blockquote><h3 id="3-3-Vue2-0-响应式原理机制-defineProperty"><a href="#3-3-Vue2-0-响应式原理机制-defineProperty" class="headerlink" title="3.3 Vue2.0 响应式原理机制 - defineProperty"></a>3.3 Vue2.0 响应式原理机制 - defineProperty</h3><p>这个原理老生常谈了，就是<code>拦截对象</code>，给对象的属性增加<code>set</code> 和 <code>get</code>方法，因为核心是 <code>defineProperty</code> 所以还需要对数组的方法进行拦截</p><h4 id="3-3-1-对对象进行拦截"><a href="#3-3-1-对对象进行拦截" class="headerlink" title="3.3.1 对对象进行拦截"></a>3.3.1 对对象进行拦截</h4><pre><code>function observer(target){    // 如果不是对象数据类型直接返回即可    if(typeof target !== 'object'){        return target    }    // 重新定义key    for(let key in target){        defineReactive(target,key,target[key])    }}function update(){    console.log('update view')}function defineReactive(obj,key,value){    observer(value); // 有可能对象类型是多层，递归劫持    Object.defineProperty(obj,key,{        get(){            // 在get 方法中收集依赖            return value        },        set(newVal){            if(newVal !== value){                observer(value);                update(); // 在set方法中触发更新            }        }    })}let obj = {name:'youxuan'}observer(obj);obj.name = 'webyouxuan';</code></pre><h4 id="3-3-2-数组方法劫持"><a href="#3-3-2-数组方法劫持" class="headerlink" title="3.3.2 数组方法劫持"></a>3.3.2 数组方法劫持</h4><pre><code>let oldProtoMehtods = Array.prototype;let proto = Object.create(oldProtoMehtods);['push','pop','shift','unshift'].forEach(method=&gt;{    Object.defineProperty(proto,method,{        get(){            update();            oldProtoMehtods[method].call(this,...arguments)        }    })})function observer(target){    if(typeof target !== 'object'){        return target    }    // 如果不是对象数据类型直接返回即可    if(Array.isArray(target)){        Object.setPrototypeOf(target,proto);        // 给数组中的每一项进行observr        for(let i = 0 ; i &lt; target.length;i++){            observer(target[i])        }        return    };    // 重新定义key    for(let key in target){        defineReactive(target,key,target[key])    }}</code></pre><p>测试</p><pre><code>let obj = {hobby:[{name:'youxuan'},'喝']}observer(obj)obj.hobby[0].name = 'webyouxuan'; // 更改数组中的对象也会触发试图更新console.log(obj)</code></pre><blockquote><p>这里依赖收集的过程就不详细描述了，我们把焦点放在<code>Vue3.0</code>上</p></blockquote><ul><li><strong>Object.defineProperty缺点</strong><ul><li>无法监听数组的变化</li><li>需要深度遍历，浪费内存</li></ul></li></ul><h3 id="3-4-Vue3-0-数据响应机制-Proxy"><a href="#3-4-Vue3-0-数据响应机制-Proxy" class="headerlink" title="3.4 Vue3.0 数据响应机制 - Proxy"></a>3.4 Vue3.0 数据响应机制 - Proxy</h3><p>在学习 Vue3.0 之前，你必须要先熟练掌握ES6中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/reflect">Reflect</a> 及 ES6中为我们提供的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/map">Map</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/set">Set </a>两种数据结构</p><p>先应用再说原理:</p><pre><code>let p = Vue.reactive({name:'youxuan'});Vue.effect(()=&gt;{ // effect方法会立即被触发    console.log(p.name);})p.name = 'webyouxuan';; // 修改属性后会再次触发effect方法</code></pre><blockquote><p>源码是采用<code>ts</code>编写，为了便于大家理解原理，这里我们采用<code>js</code>来从0编写，之后再看源码就非常的轻松啦！</p></blockquote><h4 id="3-4-1-reactive-方法实现"><a href="#3-4-1-reactive-方法实现" class="headerlink" title="3.4.1 reactive 方法实现"></a>3.4.1 reactive 方法实现</h4><p>通过 <strong>proxy</strong> 自定义获取、增加、删除等行为：</p><pre><code>function reactive(target){    // 创建响应式对象    return createReactiveObject(target);}function isObject(target){    return typeof target === 'object' &amp;&amp; target!== null;}function createReactiveObject(target){    // 判断target是不是对象,不是对象不必继续    if(!isObject(target)){        return target;    }    const handlers = {        get(target,key,receiver){ // 取值            console.log('获取')            let res = Reflect.get(target,key,receiver);            return res;        },        set(target,key,value,receiver){ // 更改 、 新增属性            console.log('设置')            let result = Reflect.set(target,key,value,receiver);            return result;        },        deleteProperty(target,key){ // 删除属性            console.log('删除')            const result = Reflect.deleteProperty(target,key);            return result;        }    }    // 开始代理    observed = new Proxy(target,handlers);    return observed;}let p = reactive({name:'youxuan'});console.log(p.name); // 获取p.name = 'webyouxuan'; // 设置delete p.name; // 删除</code></pre><p><strong>我们继续考虑多层对象如何实现代理</strong></p><pre><code>let p = reactive({ name: "youxuan", age: { num: 10 } });p.age.num = 11</code></pre><blockquote><p>由于我们只代理了第一层对象，所以对<code>age</code>对象进行更改是不会触发set方法的，但是却触发了<code>get</code>方法，这是由于 <code>p.age</code>会造成 <code>get</code>操作</p></blockquote><pre><code>get(target, key, receiver) {      // 取值    console.log("获取");    let res = Reflect.get(target, key, receiver);    return isObject(res) // 懒代理，只有当取值时再次做代理，vue2.0中一上来就会全部递归增加getter,setter    ? reactive(res) : res;}</code></pre><blockquote><p>这里我们将<code>p.age</code>取到的对象再次进行代理，这样在去更改值即可触发<code>set</code>方法</p></blockquote><p><strong>我们继续考虑数组问题</strong><br>我们可以发现<code>Proxy</code>默认可以支持数组，包括数组的长度变化以及索引值的变化</p><pre><code>let p = reactive([1,2,3,4]);p.push(5);</code></pre><blockquote><p>但是这样会触发两次<code>set</code>方法，第一次更新的是数组中的第<code>4</code>项，第二次更新的是数组的<code>length</code></p></blockquote><p>我们来屏蔽掉多次触发，更新操作</p><pre><code>set(target, key, value, receiver) {    // 更改、新增属性    let oldValue = target[key]; // 获取上次的值    let hadKey = hasOwn(target,key); // 看这个属性是否存在    let result = Reflect.set(target, key, value, receiver);    if(!hadKey){ // 新增属性        console.log('更新 添加')    }else if(oldValue !== value){ // 修改存在的属性        console.log('更新 修改')    }    // 当调用push 方法第一次修改时数组长度已经发生变化    // 如果这次的值和上次的值一样则不触发更新    return result;}</code></pre><p><strong>解决重复使用reactive情况</strong></p><pre><code>// 情况1.多次代理同一个对象let arr = [1,2,3,4];let p = reactive(arr);reactive(arr);// 情况2.将代理后的结果继续代理let p = reactive([1,2,3,4]);reactive(p);</code></pre><blockquote><p>通过<code>hash表</code>的方式来解决重复代理的情况</p></blockquote><pre><code>const toProxy = new WeakMap(); // 存放被代理过的对象const toRaw = new WeakMap(); // 存放已经代理过的对象function reactive(target) {  // 创建响应式对象  return createReactiveObject(target);}function isObject(target) {  return typeof target === "object" &amp;&amp; target !== null;}function hasOwn(target,key){  return target.hasOwnProperty(key);}function createReactiveObject(target) {  if (!isObject(target)) {    return target;  }  let observed = toProxy.get(target);  if(observed){ // 判断是否被代理过    return observed;  }  if(toRaw.has(target)){ // 判断是否要重复代理    return target;  }  const handlers = {    get(target, key, receiver) {      // 取值      console.log("获取");      let res = Reflect.get(target, key, receiver);      return isObject(res) ? reactive(res) : res;    },    set(target, key, value, receiver) {      let oldValue = target[key];      let hadKey = hasOwn(target,key);      let result = Reflect.set(target, key, value, receiver);      if(!hadKey){        console.log('更新 添加')      }else if(oldValue !== value){        console.log('更新 修改')      }      return result;    },    deleteProperty(target, key) {      console.log("删除");      const result = Reflect.deleteProperty(target, key);      return result;    }  };  // 开始代理  observed = new Proxy(target, handlers);  toProxy.set(target,observed);  toRaw.set(observed,target); // 做映射表  return observed;}</code></pre><blockquote><p>到这里<code>reactive</code>方法基本实现完毕，接下来就是与Vue2中的逻辑一样实现依赖收集和触发更新</p></blockquote><p><img src="3.4.1.png"></p><pre><code>get(target, key, receiver) {    let res = Reflect.get(target, key, receiver);+   track(target,'get',key); // 依赖收集    return isObject(res)     ?reactive(res):res;},set(target, key, value, receiver) {    let oldValue = target[key];    let hadKey = hasOwn(target,key);    let result = Reflect.set(target, key, value, receiver);    if(!hadKey){+     trigger(target,'add',key); // 触发添加    }else if(oldValue !== value){+     trigger(target,'set',key); // 触发修改    }    return result;}</code></pre><blockquote><p>track的作用是依赖收集，收集的主要是<code>effect</code>，我们先来实现<code>effect</code>原理，之后再完善 <code>track</code>和<code>trigger</code>方法</p></blockquote><h4 id="3-4-2-effect实现"><a href="#3-4-2-effect实现" class="headerlink" title="3.4.2 effect实现"></a>3.4.2 effect实现</h4><p>effect意思是副作用，此方法默认会先执行一次。如果数据变化后会再次触发此回调函数。</p><pre><code>let school = {name:'youxuan'}let p = reactive(school);effect(()=&gt;{    console.log(p.name);  // youxuan})</code></pre><p>我们来实现<code>effect</code>方法，我们需要将<code>effect</code>方法包装成响应式<code>effect</code>。</p><pre><code>function effect(fn) {  const effect = createReactiveEffect(fn); // 创建响应式的effect  effect(); // 先执行一次  return effect;}const activeReactiveEffectStack = []; // 存放响应式effectfunction createReactiveEffect(fn) {  const effect = function() {    // 响应式的effect    return run(effect, fn);  };  return effect;}function run(effect, fn) {    try {      activeReactiveEffectStack.push(effect);      return fn(); // 先让fn执行,执行时会触发get方法，可以将effect存入对应的key属性    } finally {      activeReactiveEffectStack.pop(effect);    }}</code></pre><p>当调用<code>fn()</code>时可能会触发<code>get</code>方法，此时会触发<code>track</code></p><pre><code>const targetMap = new WeakMap();function track(target,type,key){    // 查看是否有effect    const effect = activeReactiveEffectStack[activeReactiveEffectStack.length-1];    if(effect){        let depsMap = targetMap.get(target);        if(!depsMap){ // 不存在map            targetMap.set(target,depsMap = new Map());        }        let dep = depsMap.get(target);        if(!dep){ // 不存在set            depsMap.set(key,(dep = new Set()));        }        if(!dep.has(effect)){            dep.add(effect); // 将effect添加到依赖中        }    }}</code></pre><p>当更新属性时会触发<code>trigger</code>执行，找到对应的存储集合拿出<code>effect</code>依次执行</p><pre><code>function trigger(target,type,key){    const depsMap = targetMap.get(target);    if(!depsMap){        return    }    let effects = depsMap.get(key);    if(effects){        effects.forEach(effect=&gt;{            effect();        })    }}</code></pre><p><strong>我们发现如下问题</strong></p><pre><code>let school = [1,2,3];let p = reactive(school);effect(()=&gt;{    console.log(p.length);})p.push(100);</code></pre><blockquote><p>新增了值，<code>effect</code>方法并未重新执行，因为<code>push</code>中修改<code>length</code>已经被我们屏蔽掉了触发<code>trigger</code>方法，所以当新增项时应该手动触发<code>length</code>属性所对应的依赖。</p></blockquote><pre><code>function trigger(target, type, key) {  const depsMap = targetMap.get(target);  if (!depsMap) {    return;  }  let effects = depsMap.get(key);  if (effects) {    effects.forEach(effect =&gt; {      effect();    });  }  // 处理如果当前类型是增加属性，如果用到数组的length的effect应该也会被执行  if (type === "add") {    let effects = depsMap.get("length");    if (effects) {      effects.forEach(effect =&gt; {        effect();      });    }  }}</code></pre><h4 id="3-4-3-ref实现"><a href="#3-4-3-ref实现" class="headerlink" title="3.4.3 ref实现"></a>3.4.3 ref实现</h4><p>ref可以将原始数据类型也转换成响应式数据，需要通过<code>.value</code>属性进行获取值</p><pre><code>function convert(val) {  return isObject(val) ? reactive(val) : val;}function ref(raw) {  raw = convert(raw);  const v = {    _isRef:true, // 标识是ref类型    get value() {      track(v, "get", "");      return raw;    },    set value(newVal) {      raw = newVal;      trigger(v,'set','');    }  };  return v;}</code></pre><p>问题又来了我们再编写个案例</p><pre><code>let r = ref(1);let c = reactive({    a:r});console.log(c.a.value);</code></pre><blockquote><p>这样做的话岂不是每次都要多来一个<code>.value</code>，这样太难用了</p></blockquote><p>在<code>get</code>方法中判断如果获取的是<code>ref</code>的值，就将此值的<code>value</code>直接返回即可</p><pre><code>let res = Reflect.get(target, key, receiver);if(res._isRef){  return res.value}</code></pre><h4 id="3-4-4-computed实现"><a href="#3-4-4-computed实现" class="headerlink" title="3.4.4 computed实现"></a>3.4.4 computed实现</h4><p><code>computed</code> 实现也是基于 <code>effect</code> 来实现的，特点是<code>computed</code>中的函数不会立即执行，多次取值是有缓存机制的</p><p>先来看用法:</p><pre><code>let a = reactive({name:'youxuan'});let c = computed(()=&gt;{  console.log('执行次数')  return a.name +'webyouxuan';})// 不取不执行，取n次只执行一次console.log(c.value);console.log(c.value);function computed(getter){  let dirty = true;  const runner = effect(getter,{ // 标识这个effect是懒执行    lazy:true, // 懒执行    scheduler:()=&gt;{ // 当依赖的属性变化了，调用此方法，而不是重新执行effect      dirty = true;    }  });  let value;  return {    _isRef:true,    get value(){      if(dirty){        value = runner(); // 执行runner会继续收集依赖        dirty = false;      }      return value;    }  }}</code></pre><p>修改<code>effect</code>方法</p><pre><code>function effect(fn,options) {  let effect = createReactiveEffect(fn,options);  if(!options.lazy){ // 如果是lazy 则不立即执行    effect();  }  return effect;}function createReactiveEffect(fn,options) {  const effect = function() {    return run(effect, fn);  };  effect.scheduler = options.scheduler;  return effect;}</code></pre><p>在<code>trigger</code>时判断</p><pre><code>deps.forEach(effect =&gt; {  if(effect.scheduler){ // 如果有scheduler 说明不需要执行effect    effect.scheduler(); // 将dirty设置为true,下次获取值时重新执行runner方法  }else{    effect(); // 否则就是effect 正常执行即可  }});let a = reactive({name:'youxuan'});let c = computed(()=&gt;{  console.log('执行次数')  return a.name +'webyouxuan';})// 不取不执行，取n次只执行一次console.log(c.value);a.name = 'zf10'; // 更改值 不会触发重新计算,但是会将dirty变成trueconsole.log(c.value); // 重新调用计算方法</code></pre><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="4-1-架构改进和新功能："><a href="#4-1-架构改进和新功能：" class="headerlink" title="4.1 架构改进和新功能："></a>4.1 架构改进和新功能：</h3><ul><li>编译器（Compiler）<ul><li>使用模块化架构</li><li>优化 “Block tree”</li><li>更激进的 static tree hoisting 功能 （检测静态语法，进行提升）</li><li>支持 Source map</li><li>内置标识符前缀（又名”stripWith”）</li><li>内置整齐打印（pretty-printing）功能</li><li>移除 Source map 和标识符前缀功能后，使用 Brotli 压缩的浏览器版本精简了大约<strong>10KB</strong></li></ul></li><li>运行时（Runtime）<ul><li>速度显著提升</li><li>同时支持 Composition API 和 Options API，以及 typings</li><li>基于 Proxy 实现的数据变更检测</li><li>支持 Fragments (允许组件有从多个根结点)</li><li>支持 Portals (允许在DOM的其它位置进行渲染)</li><li>支持 Suspense w/ async setup()</li></ul></li></ul><h3 id="4-2-性能方面的优化"><a href="#4-2-性能方面的优化" class="headerlink" title="4.2 性能方面的优化"></a>4.2 性能方面的优化</h3><ul><li>路由懒加载</li><li>keep-alive缓存页面</li><li>使用v-show复用DOM</li><li>v-for 遍历避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片懒加载</li><li>第三方插件按需引入</li><li>无状态的组件标记为函数式组件</li><li>子组件分割</li><li>变量本地化</li><li>SSR</li></ul><h3 id="4-3-更好的-TypeScript-集成"><a href="#4-3-更好的-TypeScript-集成" class="headerlink" title="4.3 更好的 TypeScript 集成"></a>4.3 更好的 TypeScript 集成</h3><ul><li>改进的TypeScript支持，编辑器能提供强有力的类型检查和错误及警告</li><li>更好的调试支持</li></ul><h3 id="4-4-用于处理大规模用例的新-API"><a href="#4-4-用于处理大规模用例的新-API" class="headerlink" title="4.4 用于处理大规模用例的新 API"></a>4.4 用于处理大规模用例的新 API</h3><ul><li>reactive</li><li>ref</li><li>computed</li><li>readonly</li><li>watchEffect</li><li>watch</li><li>unref</li><li>toRef</li><li>toRefs</li><li>isRef</li><li>isProxy</li><li>isReactive</li><li>isReadonly</li><li>customRef</li><li>markRaw</li><li>shallowReactive</li><li>shallowReadonly</li><li>shallowRef</li><li>toRaw</li></ul><h3 id="4-5-分层内部模块"><a href="#4-5-分层内部模块" class="headerlink" title="4.5 分层内部模块"></a>4.5 分层内部模块</h3><p>Vue 3.0 内核仍然可以通过一个简单的<code>&lt;script&gt;</code>标签使用，但其内部结构已被彻底重写为一组解耦的模块。新的体系结构提供了更好的可维护性，并允许最终用户通过摇树来减少运行时大小的一半。<br><strong>模块如下:</strong></p><p><img src="4.5.png"></p><h5 id="模块提供的功能点"><a href="#模块提供的功能点" class="headerlink" title="模块提供的功能点:"></a>模块提供的功能点:</h5><ol><li><p>编译器支持用于构建时自定义的自定义 AST 转换（例如，构建时i18n）</p></li><li><p>核心运行时提供<code>API</code>用于创建针对不同渲染目标（例如<code>本机移动设备</code>，<code>WebGL</code>或<code>终端</code>）的自定义渲染器。默认<code>DOM</code>渲染器使用相同的 API 构建。</p></li><li><p>该<code>@vue/reactivity</code>模块导出的功能可以直接访问<code>Vue</code>的反应系统，并且可以用作独立程序包。它可以与其他模板解决方案（例如<code>lit-html</code>）配对，甚至可以用于非 UI 方案。</p></li></ol><h3 id="4-6-Composition-API-设计目的"><a href="#4-6-Composition-API-设计目的" class="headerlink" title="4.6 Composition API 设计目的"></a>4.6 Composition API 设计目的</h3><p>旨在解决大型应用程序中 Vue 使用的难点。<br>Composition API 建立在反应性 API 之上，与 2.x 基于对象的 API 相比，可实现类似于 React 挂钩的逻辑组成和重用，更灵活的代码组织模式以及更可靠的类型推断。</p><h3 id="4-7-性能改进（相对-Vue-2-0）"><a href="#4-7-性能改进（相对-Vue-2-0）" class="headerlink" title="4.7 性能改进（相对 Vue 2.0）"></a>4.7 性能改进（相对 Vue 2.0）</h3><ul><li>通过摇树：（减轻了多达41％的资源大小）</li><li>初始渲染：（加快了多达55％的速度）</li><li>更新速度：（加快了133％的速度）</li><li>内存占用：（最多减少54％）</li></ul><h3 id="4-8-提供的两个实验性功能"><a href="#4-8-提供的两个实验性功能" class="headerlink" title="4.8 提供的两个实验性功能"></a>4.8 提供的两个实验性功能</h3><ul><li><code>&lt;script setup&gt;</code></li></ul><blockquote><p>用于在SFC中使用Composition API的语法糖</p></blockquote><ul><li><code>&lt;style vars&gt;</code></li></ul><blockquote><p>SFC 中状态驱动的 CSS 变量</p></blockquote><p><strong>迁移3.0指♂南：</strong><a href="https://v3.vuejs.org/guide/migration/introduction.html">https://v3.vuejs.org/guide/migration/introduction.html</a></p><h3 id="4-9-兼容-IE-11"><a href="#4-9-兼容-IE-11" class="headerlink" title="4.9 兼容 IE 11"></a>4.9 兼容 IE 11</h3><p>计划在2020年第四季度重点关注它。因此，计划迁移现有 V2 应用程序的用户或需要 IE11 支持人员此时应意识到这些限制。</p><h3 id="4-10-后续计划"><a href="#4-10-后续计划" class="headerlink" title="4.10 后续计划"></a>4.10 后续计划</h3><ul><li>迁移版本</li><li><strong>IE11</strong>支持</li><li>新 <strong>devtools</strong> 中的 <strong>Router</strong> 和 <strong>Vuex</strong> 集成</li><li><strong>Vetur</strong> 中模板类型推断的进一步改进<br><strong>新文档链接：</strong></li><li>新官网<br><a href="https://v3.vuejs.org/">https://v3.vuejs.org/</a></li><li>迁移指南<br><a href="https://v3.vuejs.org/guide/migration/introduction.html">https://v3.vuejs.org/guide/migration/introduction.html</a></li><li>Composition API<br><a href="https://v3.vuejs.org/guide/composition-api-introduction.html">https://v3.vuejs.org/guide/composition-api-introduction.html</a></li></ul><p>到此为止关于<code>Vue3.0</code>核心的所有内容就完美谢幕了，内容还是相当多的，在这引用德华之铭言——如果想要飞得高，就该把 Vue 2.0 忘掉 ~ 希望对大家有所帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 心得分享</title>
      <link href="/2020/12/07/03.vscode/"/>
      <url>/2020/12/07/03.vscode/</url>
      
        <content type="html"><![CDATA[<h2 id="一、VSCode-介绍"><a href="#一、VSCode-介绍" class="headerlink" title="一、VSCode 介绍"></a>一、VSCode 介绍</h2><h3 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h3><p>VSCode 全称 Visual Studio Code，是一款开源、免费、跨平台、高性能、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得相当 nice。</p><p><strong>尤雨溪</strong>大大这样评价 VSCode：</p><p><img src="1.1.png"></p><p>有一点你可能会感到惊讶：VSCode 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的客户端开发框架 <code>Electron</code>）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：</p><blockquote><p><strong>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</strong>。</p></blockquote><p>Jeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。</p><p>如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VSCode 作为「<strong>主力开发工具</strong>」。这款软件是为前端童鞋量身定制的。</p><p>如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VSCode 作为「<strong>代码编辑器</strong>」来使用，纵享丝滑。</p><p>甚至是一些写文档、写作的同学，也经常把 VSCode 作为 Markdown <strong>写作工具</strong>，毫无违和感。</p><p>退而求其次，即便你不属于以上任何范畴，你还可以把 VSCode 当作最简单的<strong>文本编辑器</strong>来使用，完胜 Windows 系统自带的记事本。</p><h3 id="1-2-IDE-与编辑器的对比"><a href="#1-2-IDE-与编辑器的对比" class="headerlink" title="1.2 IDE 与编辑器的对比"></a>1.2 IDE 与编辑器的对比</h3><ul><li><strong>IDE</strong>（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</li><li><strong>编辑器</strong>：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</li></ul><p>需要注意的是，VSCode 的定位是<strong>编辑器</strong>，而非 IDE ，但 VSCode 又比一般的编辑器的功能要丰富许多。可以这样理解：VSCode 的体量是介于编辑器和 IDE 之间。</p><h3 id="1-3-VSCode-特点"><a href="#1-3-VSCode-特点" class="headerlink" title="1.3 VSCode 特点"></a>1.3 VSCode 特点</h3><ul><li>VSCode 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验，比如代码的智能提示、语法检查、图形化的调试工具、插件扩展、版本管理等。</li><li>跨平台支持 MacOS、Windows 和 Linux 等多个平台。</li><li>VSCode 的源代码以 MIT 协议开源。</li><li>支持第三方插件，功能强大，生态系统完善。</li><li>VSCode 自带了 TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。当然，其他的语言，你可以安装相应的<strong>扩展包</strong>插件，也会有智能提示。</li></ul><h3 id="1-4-前端利器之争：VSCode-与-WebStorm"><a href="#1-4-前端利器之争：VSCode-与-WebStorm" class="headerlink" title="1.4 前端利器之争：VSCode 与 WebStorm"></a>1.4 前端利器之争：VSCode 与 WebStorm</h3><p>前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是 VSCode 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比：</p><ul><li><strong>哪个更酷</strong>：显然 VSCode 更酷。</li><li><strong>内存占用情况</strong>：根据我的观察，VSCode 是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用，使用起来是不会有任何卡顿的感觉的。相比之下，IntelliJ IDEA 不仅非常占内存，而且还非常卡顿。如果你想换个既轻量级、又不占内存的编辑器，最好还是使用「Sublime Text」编辑器。</li><li><strong>使用比例</strong>：当然是 VSCode 更胜一筹。先不说别的，就拿数据说话，绝大部分前端童鞋都在用 VSCode，妥妥的。</li></ul><p>所以，如果你以后还问这个问题，那就真有些掉底了。</p><h2 id="二、VSCode-快捷键"><a href="#二、VSCode-快捷键" class="headerlink" title="二、VSCode 快捷键"></a>二、VSCode 快捷键</h2><p>以下都是常用的快捷键，而加粗部分的快捷键，使用频率则非常之高。</p><p>大部分工具，掌握 20% 的技能，可以应对 80% 的工作。但我想说的是：那从来都不是同样的 20%，每个人都会用到不同的功能。</p><p>掌握下面这些<strong>高频核心快捷键</strong>，足矣。</p><h3 id="2-1-工作区"><a href="#2-1-工作区" class="headerlink" title="2.1 工作区"></a>2.1 工作区</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>Cmd + Shift + P</strong></td><td align="center"><strong>Ctrl + Shift + P</strong>，F1</td><td align="center">显示命令面板</td><td align="center"></td></tr><tr><td align="center"><strong>Cmd + B</strong></td><td align="center"><strong>Ctrl + B</strong></td><td align="center">显示/隐藏侧边栏</td><td align="center">很实用</td></tr><tr><td align="center"><code>Cmd + \</code></td><td align="center"><code>Ctrl + \</code></td><td align="center"><strong>创建多个编辑器</strong></td><td align="center">【重要】抄代码利器</td></tr><tr><td align="center"><strong>Cmd + 1、2</strong></td><td align="center"><strong>Ctrl + 1、2</strong></td><td align="center">聚焦到第 1、第 2 个编辑器</td><td align="center">同上重要</td></tr><tr><td align="center"><strong>cmd +/-</strong></td><td align="center"><strong>ctrl +/-</strong></td><td align="center">将工作区放大/缩小（包括代码字体、左侧导航栏）</td><td align="center">在投影仪场景经常用到</td></tr><tr><td align="center">Cmd + J</td><td align="center">Ctrl + J</td><td align="center">显示/隐藏控制台</td><td align="center"></td></tr><tr><td align="center"><strong>Cmd + Shift + N</strong></td><td align="center"><strong>Ctrl + Shift + N</strong></td><td align="center">重新开一个软件的窗口</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + Shift + W</td><td align="center">Ctrl + Shift + W</td><td align="center">关闭软件的当前窗口</td><td align="center"></td></tr><tr><td align="center">Cmd + N</td><td align="center">Ctrl + N</td><td align="center">新建文件</td><td align="center"></td></tr><tr><td align="center">Cmd + W</td><td align="center">Ctrl + W</td><td align="center">关闭当前文件</td><td align="center"></td></tr></tbody></table><h3 id="2-2-跳转"><a href="#2-2-跳转" class="headerlink" title="2.2 跳转"></a>2.2 跳转</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Cmd + `</td><td align="center">没有</td><td align="center">在同一个软件的<strong>多个工作区</strong>之间切换</td><td align="center">使用很频繁</td></tr><tr><td align="center"><strong>Cmd + Option + 左右方向键</strong></td><td align="center">Ctrl + Pagedown/Pageup</td><td align="center">在已经打开的<strong>多个文件</strong>之间进行切换</td><td align="center">非常实用</td></tr><tr><td align="center">Ctrl + Tab</td><td align="center">Ctrl + Tab</td><td align="center">在已经打开的多个文件之间进行跳转</td><td align="center">不如上面的快捷键快</td></tr><tr><td align="center">Cmd + Shift + O</td><td align="center">Ctrl + shift + O</td><td align="center">在当前文件的各种<strong>方法之间</strong>进行跳转</td><td align="center"></td></tr><tr><td align="center">Ctrl + G</td><td align="center">Ctrl + G</td><td align="center">跳转到指定行</td><td align="center"></td></tr><tr><td align="center"><code>Cmd+Shift+\</code></td><td align="center"><code>Ctrl+Shift+\</code></td><td align="center">跳转到匹配的括号</td><td align="center"></td></tr></tbody></table><h3 id="2-3-光标移动"><a href="#2-3-光标移动" class="headerlink" title="2.3 光标移动"></a>2.3 光标移动</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">方向键</td><td align="center">方向键</td><td align="center">在<strong>单个字符</strong>之间移动光标</td><td align="center">大家都知道</td></tr><tr><td align="center"><strong>option + 左右方向键</strong></td><td align="center"><strong>Ctrl + 左右方向键</strong></td><td align="center">在<strong>单词</strong>之间移动光标</td><td align="center">很常用</td></tr><tr><td align="center"><strong>Cmd + 左右方向键</strong></td><td align="center"><strong>Fn + 左右方向键</strong></td><td align="center">在<strong>整行</strong>之间移动光标</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + ←</td><td align="center">Fn + ←（或 Win + ←）</td><td align="center">将光标定位到当前行的最左侧</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + →</td><td align="center">Fn + →（或 Win + →）</td><td align="center">将光标定位到当前行的最右侧</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + ↑</td><td align="center">Ctrl + Home</td><td align="center">将光标定位到文章的第一行</td><td align="center"></td></tr><tr><td align="center">Cmd + ↓</td><td align="center">Ctrl + End</td><td align="center">将光标定位到文章的最后一行</td><td align="center"></td></tr><tr><td align="center">Cmd + Shift + \</td><td align="center"></td><td align="center">在<strong>代码块</strong>之间移动光标</td><td align="center"></td></tr></tbody></table><h3 id="2-4-编辑"><a href="#2-4-编辑" class="headerlink" title="2.4 编辑"></a>2.4 编辑</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>Cmd + Enter</strong></td><td align="center"><strong>Ctrl + Enter</strong></td><td align="center">在当前行的下方新增一行，然后跳至该行</td><td align="center">即使光标不在行尾，也能快速向下插入一行</td></tr><tr><td align="center">Cmd+Shift+Enter</td><td align="center">Ctrl+Shift+Enter</td><td align="center">在当前行的上方新增一行，然后跳至该行</td><td align="center">即使光标不在行尾，也能快速向上插入一行</td></tr><tr><td align="center"><strong>Option + ↑</strong></td><td align="center"><strong>Alt + ↑</strong></td><td align="center">将代码向上移动</td><td align="center">很常用</td></tr><tr><td align="center"><strong>Option + ↓</strong></td><td align="center"><strong>Alt + ↓</strong></td><td align="center">将代码向下移动</td><td align="center">很常用</td></tr><tr><td align="center">Option + Shift + ↑</td><td align="center">Alt + Shift + ↑</td><td align="center">将代码向上复制</td><td align="center"></td></tr><tr><td align="center"><strong>Option + Shift + ↓</strong></td><td align="center"><strong>Alt + Shift + ↓</strong></td><td align="center">将代码向下复制</td><td align="center">写重复代码的利器</td></tr></tbody></table><h3 id="2-5-多光标编辑"><a href="#2-5-多光标编辑" class="headerlink" title="2.5 多光标编辑"></a>2.5 多光标编辑</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>Cmd + Option + 上下键</strong></td><td align="center"><strong>Ctrl + Alt + 上下键</strong></td><td align="center">在连续的多列上，同时出现光标</td><td align="center"></td></tr><tr><td align="center"><strong>Option + 鼠标点击任意位置</strong></td><td align="center"><strong>Alt + 鼠标点击任意位置</strong></td><td align="center">在任意位置，同时出现光标</td><td align="center"></td></tr><tr><td align="center">Option + Shift + 鼠标拖动</td><td align="center">Alt + Shift + 鼠标拖动</td><td align="center">在选中区域的每一行末尾，出现光标</td><td align="center"></td></tr><tr><td align="center">Cmd + Shift + L</td><td align="center">Ctrl + Shift + L</td><td align="center">在选中文本的所有相同内容处，出现光标</td><td align="center"></td></tr></tbody></table><h3 id="2-6-其他多光标编辑"><a href="#2-6-其他多光标编辑" class="headerlink" title="2.6 其他多光标编辑"></a>2.6 其他多光标编辑</h3><ul><li>选中某个文本，然后反复按住快捷键「 <strong>Cmd + D</strong> 」键（windows 用户是按住「<strong>Ctrl + D</strong>」键）， 即可将全文中相同的词逐一加入选择。</li><li>选中一堆文本后，按住「<strong>Option + Shift + i</strong>」键（windows 用户是按住「<strong>Alt + Shift + I</strong>」键），既可在<strong>每一行的末尾</strong>都创建一个光标。</li></ul><h3 id="2-7-删除"><a href="#2-7-删除" class="headerlink" title="2.7 删除"></a>2.7 删除</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Cmd + shift + K</td><td align="center">Ctrl + Shift + K</td><td align="center">删除整行</td><td align="center">「Cmd + X」的作用是剪切，但也可以删除整行</td></tr><tr><td align="center"><strong>option + Backspace</strong></td><td align="center"><strong>Ctrl + Backspace</strong></td><td align="center">删除光标之前的一个单词</td><td align="center">英文有效，很常用</td></tr><tr><td align="center">option + delete</td><td align="center">Ctrl + delete</td><td align="center">删除光标之后的一个单词</td><td align="center"></td></tr><tr><td align="center"><strong>Cmd + Backspace</strong></td><td align="center"></td><td align="center">删除光标之前的整行内容</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + delete</td><td align="center"></td><td align="center">删除光标之后的整行内容</td><td align="center"></td></tr></tbody></table><blockquote><p>备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。</p></blockquote><h3 id="2-8-编程语言相关"><a href="#2-8-编程语言相关" class="headerlink" title="2.8 编程语言相关"></a>2.8 编程语言相关</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Cmd + /</td><td align="center">Ctrl + /</td><td align="center">添加单行注释</td><td align="center">很常用</td></tr><tr><td align="center"><strong>Option + Shift + F</strong></td><td align="center">Alt + shift + F</td><td align="center">代码格式化</td><td align="center">很常用</td></tr><tr><td align="center">F2</td><td align="center">F2</td><td align="center">以重构的方式进行<strong>重命名</strong></td><td align="center">改代码备</td></tr><tr><td align="center">Ctrl + J</td><td align="center"></td><td align="center">将多行代码合并为一行</td><td align="center">Win 用户可在命令面板搜索”合并行“</td></tr><tr><td align="center">Cmd +</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Cmd + U</td><td align="center">Ctrl + U</td><td align="center">将光标的移动回退到上一个位置</td><td align="center">撤销光标的移动和选择</td></tr></tbody></table><h3 id="2-9-搜索相关"><a href="#2-9-搜索相关" class="headerlink" title="2.9 搜索相关"></a>2.9 搜索相关</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>Cmd + Shift + F</strong></td><td align="center"><strong>Ctrl + Shift +F</strong></td><td align="center">全局搜索代码</td><td align="center">很常用</td></tr><tr><td align="center"><strong>Cmd + P</strong></td><td align="center"><strong>Ctrl + P</strong></td><td align="center">在当前的项目工程里，<strong>全局</strong>搜索文件名</td><td align="center"></td></tr><tr><td align="center">Cmd + F</td><td align="center">Ctrl + F</td><td align="center">在当前文件中搜索代码，光标在搜索框里</td><td align="center"></td></tr><tr><td align="center"><strong>Cmd + G</strong></td><td align="center"><strong>F3</strong></td><td align="center">在当前文件中搜索代码，光标仍停留在编辑器里</td><td align="center">很巧妙</td></tr></tbody></table><h3 id="2-10-自定义快捷键"><a href="#2-10-自定义快捷键" class="headerlink" title="2.10 自定义快捷键"></a>2.10 自定义快捷键</h3><p>按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。</p><p>当然，你也可以选择菜单栏「偏好设置 –&gt; 键盘快捷方式」，进入快捷键的设置：</p><p><img src="2.10.png"></p><h3 id="2-11-快捷键列表"><a href="#2-11-快捷键列表" class="headerlink" title="2.11 快捷键列表"></a>2.11 快捷键列表</h3><p>你可以点击 VSCode 左下角的齿轮按钮，效果如下：</p><p><img src="2.11.1.png"></p><p>上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了：</p><p><img src="2.11.2.png"></p><h3 id="2-12-快捷键参考链接"><a href="#2-12-快捷键参考链接" class="headerlink" title="2.12 快捷键参考链接"></a>2.12 快捷键参考链接</h3><ul><li>快捷键速查表[官方]：<a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf</a></li></ul><h2 id="三、命令面板"><a href="#三、命令面板" class="headerlink" title="三、命令面板"></a>三、命令面板</h2><p>Mac 用户按住快捷键 <code>Cmd+Shift+P</code> （Windows 用户按住快捷键<code>Ctrl+Shift+P</code>），可以打开命令面板。效果如下：</p><p><img src="3.1.png"></p><p>如果们需要修改一些设置项，可以通过「命令面板」来操作，效率会更高。这里列举一些。</p><p><strong>设置字体大小</strong></p><p>在命令面板输入“字体”，可以进行字体的设置，效果如下：</p><p><img src="3.2.png"></p><p>当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。</p><p><strong>快捷键设置</strong></p><p>在命令面板输入“快捷键”，就可以进入快捷键的设置。</p><p><strong>大小写转换</strong></p><p>选中文本后，在命令面板中输入<code>transfrom</code>，就可以修改文本的大小写了。</p><p><img src="3.3.png"></p><p><strong>使用命令行启动 VS Code</strong></p><p>（1）输入快捷键「Cmd + Shift + P 」，选择<code>install code command</code>：</p><p><img src="3.4.png"></p><p>（2）使用命令行：</p><ul><li><code>code</code>命令：启动 VSCode 软件</li><li><code>code pathName/fileName</code>命令：通过 VSCode 打开指定目录/指定文件</li></ul><h2 id="四、私人订制-VSCode"><a href="#四、私人订制-VSCode" class="headerlink" title="四、私人订制 VSCode"></a>四、私人订制 VSCode</h2><h3 id="4-1-VSCode-设置为中文语言"><a href="#4-1-VSCode-设置为中文语言" class="headerlink" title="4.1 VSCode 设置为中文语言"></a>4.1 VSCode 设置为中文语言</h3><p>Mac 用户按住快捷键 <code>Cmd+Shift+P</code> （Windows 用户按住快捷键<code>Ctrl+Shift+P</code>），打开命令面板。</p><p>在命令面板中，输入<code>Configure Display Language</code>，选择<code>Install additional languages</code>，然后安装插件<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>即可。</p><p>或者，我们可以直接安装插件<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>，是一样的。</p><p>安装完成后，重启 VSCode。</p><h3 id="4-2-面包屑（Breadcrumb）"><a href="#4-2-面包屑（Breadcrumb）" class="headerlink" title="4.2 面包屑（Breadcrumb）"></a>4.2 面包屑（Breadcrumb）</h3><p>打开 VSCode 的设置项，选择「用户设置 -&gt; 工作台 -&gt; 导航路径」，如下图所示：</p><p><img src="4.2.1.png"></p><p>上图中，将红框部分打钩即可。</p><p>设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：</p><p><img src="4.2.2.png"></p><p>有了这个面包屑导航，我们可以在任意目录、任意文件之间随意跳转。</p><h3 id="4-3-左右显示多个编辑器窗口（抄代码利器）"><a href="#4-3-左右显示多个编辑器窗口（抄代码利器）" class="headerlink" title="4.3 左右显示多个编辑器窗口（抄代码利器）"></a>4.3 左右显示多个编辑器窗口（抄代码利器）</h3><p>Mac 用户按住快捷键 <code>Cmd + \</code>， Windows 用户按住快捷键<code>Ctrl + \</code>，即可同时打开多个编辑器窗口，效果如下：</p><p><img src="4.3.gif"></p><p>按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口。随时随地，想切就切。</p><p>学会了这一招，以后再抄代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。</p><h3 id="4-4-是否显示代码的行号"><a href="#4-4-是否显示代码的行号" class="headerlink" title="4.4 是否显示代码的行号"></a>4.4 是否显示代码的行号</h3><p>VSCode 默认显示代码的行号。你可以在设置项里搜索 <code>editor.lineNumbers</code>修改设置，配置项如下：</p><p><img src="4.4.png"></p><p>我建议保留这个设置项，无需修改。</p><h3 id="4-5-右侧是否显示代码的缩略图"><a href="#4-5-右侧是否显示代码的缩略图" class="headerlink" title="4.5 右侧是否显示代码的缩略图"></a>4.5 右侧是否显示代码的缩略图</h3><p>VSCode 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 <code>editor.minimap</code>进行设置，配置项如下：</p><p><img src="4.5.png"></p><h3 id="4-6-将当前行代码高亮显示（更改光标所在行的背景色）"><a href="#4-6-将当前行代码高亮显示（更改光标所在行的背景色）" class="headerlink" title="4.6 将当前行代码高亮显示（更改光标所在行的背景色）"></a>4.6 将当前行代码高亮显示（更改光标所在行的背景色）</h3><p>当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想<strong>高亮显示</strong>当前行的代码，需要设置两步：</p><p>（1）在设置项里搜索<code>editor.renderLineHighlight</code>，将选项值设置为<code>all</code>或者<code>line</code>。</p><p>（2）在设置项里增加如下内容：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"workbench.colorCustomizations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.lineHighlightBackground"</span><span class="token operator">:</span> <span class="token string">"#00000090"</span><span class="token punctuation">,</span>    <span class="token property">"editor.lineHighlightBorder"</span><span class="token operator">:</span> <span class="token string">"#ffffff30"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。</p><h3 id="4-7-改完代码后立即自动保存"><a href="#4-7-改完代码后立即自动保存" class="headerlink" title="4.7 改完代码后立即自动保存"></a>4.7 改完代码后立即自动保存</h3><p><strong>方式一</strong>：</p><p>改完代码后，默认不会自动保存。你可以在设置项里搜索<code>files.autoSave</code>，修改配置项如下：</p><p><img src="4.7.png"></p><p>上图中，我们将配置项修改为<code>onFocusChange</code>之后，那么，当光标离开该文件后，这个文件就会自动保存了。<strong>非常方便</strong>。</p><p><strong>方式二</strong>：</p><p>当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。</p><h3 id="4-8-保存代码后，是否立即格式化"><a href="#4-8-保存代码后，是否立即格式化" class="headerlink" title="4.8 保存代码后，是否立即格式化"></a>4.8 保存代码后，是否立即格式化</h3><p>保存代码后，默认<strong>不会立即</strong>进行代码的格式化。你可以在设置项里搜索<code>editor.formatOnSave</code>查看该配置项：</p><p><img src="4.8.png"></p><p>我觉得这个配置项保持默认就好，不用打钩。</p><h3 id="4-9-空格-or-制表符"><a href="#4-9-空格-or-制表符" class="headerlink" title="4.9 空格 or 制表符"></a>4.9 空格 or 制表符</h3><p>VSCode 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。</p><p>常见的设置项如下：</p><ul><li><strong>editor.detectIndentation</strong>：自动检测（默认开启）。截图如下：</li></ul><p><img src="4.9.1.png"></p><ul><li><strong>editor.insertSpaces</strong>：按 Tab 键时插入空格（默认）。截图如下：</li></ul><p><img src="4.9.2.png"></p><ul><li><strong>editor.tabSize</strong>：一个制表符默认等于四个空格。截图如下：</li></ul><p><img src="4.9.3.png"></p><h3 id="4-10-新建文件后的默认文件类型"><a href="#4-10-新建文件后的默认文件类型" class="headerlink" title="4.10 新建文件后的默认文件类型"></a>4.10 新建文件后的默认文件类型</h3><p>当我们按下快捷键「Cmd + N」新建文件时，VSCode 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。</p><p>如果你想修改默认的文件类型，可以在设置项里搜索<code>files.defaultLanguage</code>，设置项如下：</p><p><img src="4.10.png"></p><p>上图中的红框部分，填入你期望的默认文件类型。我填的是<code>html</code>类型，你也可以填写成 <code>javascript</code> 或者 <code>markdown</code>，或者其他的语言类型。</p><h3 id="4-11-删除文件时，是否弹出确认框"><a href="#4-11-删除文件时，是否弹出确认框" class="headerlink" title="4.11 删除文件时，是否弹出确认框"></a>4.11 删除文件时，是否弹出确认框</h3><p>当我们在 VSCode 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索<code>xplorer.confirmDelete</code>。截图如下：</p><p><img src="4.11.png"></p><p>我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一不小心删了呢？</p><blockquote><p>接下来，我们来讲一些更高级的配置。</p></blockquote><h3 id="4-12-文件对比"><a href="#4-12-文件对比" class="headerlink" title="4.12 文件对比"></a>4.12 文件对比</h3><p>VSCode 默认支持<strong>对比两个文件的内容</strong>。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：</p><p><img src="4.12.1.png"></p><p>VSCode 自带的对比功能并不够强大，我们可以安装插件<code>compareit</code>，进行更丰富的对比。比如说，安装完插件<code>compareit</code>之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：</p><p><img src="4.12.2.png"></p><h3 id="4-13-查找某个函数在哪些地方被调用了"><a href="#4-13-查找某个函数在哪些地方被调用了" class="headerlink" title="4.13 查找某个函数在哪些地方被调用了"></a>4.13 查找某个函数在哪些地方被调用了</h3><p>比如我已经在<code>a.js</code>文件里调用了 <code>foo()</code>函数。那么，如果我想知道<code>foo()</code>函数在其他文件中是否也被调用了，该怎么做呢？</p><p>做法如下：在 <code>a.js</code> 文件里，选中<code>foo()</code>函数（或者将光标放置在<code>foo()</code>函数上），然后按住快捷键「Shift + F12」，就能看到 <code>foo()</code>函数在哪些地方被调用了，比较实用。</p><h3 id="4-14-鼠标操作"><a href="#4-14-鼠标操作" class="headerlink" title="4.14 鼠标操作"></a>4.14 鼠标操作</h3><ul><li>在当前行的位置，鼠标三击，可以选中当前行。</li><li>用鼠标单击文件的<strong>行号</strong>，可以选中当前行。</li><li>在某个<strong>行号</strong>的位置，<strong>上下移动鼠标，可以选中多行</strong>。</li></ul><h3 id="4-15-重构"><a href="#4-15-重构" class="headerlink" title="4.15 重构"></a>4.15 重构</h3><p>重构分很多种，我们来举几个例子。</p><p><strong>命名重构</strong>：</p><p>当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。</p><p><strong>方法重构</strong>：</p><p>选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。</p><h3 id="4-16-在当前文件中搜索"><a href="#4-16-在当前文件中搜索" class="headerlink" title="4.16 在当前文件中搜索"></a>4.16 在当前文件中搜索</h3><p>在上面的快捷键列表中，我们已经知道如下快捷键：</p><ul><li>Cmd + F（Win 用户是 Ctrl + F）：在当前文件中搜索，光标在搜索框里</li><li>Cmd + G（Win 用户是 F3）：在当前文件中搜索，光标仍停留在编辑器里</li></ul><p>另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：</p><p><img src="4.16.1.png"></p><p>上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。</p><p>「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 <code>editor.find.autoFindInSelection</code>，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以<strong>自动</strong>只在这些内容里进行查找。该设置项如下图所示：</p><p><img src="4.16.2.png"></p><h3 id="4-17-全局搜索"><a href="#4-17-全局搜索" class="headerlink" title="4.17 全局搜索"></a>4.17 全局搜索</h3><p>在上面的快捷键列表中，我们已经知道如下快捷键：</p><ul><li>Cmd + Shift + F（Win 用户是 Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下：</li></ul><p><img src="4.17.png"></p><p>上图中，你可以点击红框部分，展开更多的配置项。</p><h3 id="4-18-Git-版本管理"><a href="#4-18-Git-版本管理" class="headerlink" title="4.18 Git 版本管理"></a>4.18 Git 版本管理</h3><p>VSCode 自带了 Git 版本管理，如下图所示：</p><p><img src="4.18.png"></p><p>上图中，我们可以在这里进行常见的 Git 命令操作。如果你还不熟悉 <strong>Git 版本管理</strong>，先去补补课吧。</p><p>与此同时，我建议安装插件<code>GitLens</code>，它是 VSCode 中我最推荐的一个插件，简直是 Git 神器，码农必备。</p><h3 id="4-19-将工作区放大-缩小"><a href="#4-19-将工作区放大-缩小" class="headerlink" title="4.19 将工作区放大/缩小"></a>4.19 将工作区放大/缩小</h3><p>我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。</p><p>如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「**cmd +/-**」。windows 用户是按下「ctrl +/-」</p><p><strong>当我们在投影仪上给别人演示代码的时候，这一招十分管用</strong>。</p><p>如果你想恢复默认的工作区大小，可以在命令面板输入<code>重置缩放</code>（英文是<code>reset zoom</code>）</p><h3 id="4-20-创建多层子文件夹"><a href="#4-20-创建多层子文件夹" class="headerlink" title="4.20 创建多层子文件夹"></a>4.20 创建多层子文件夹</h3><p>我们可以在新建文件夹的时候，如果直接输入<code>aa/bb/cc</code>，比如：</p><p><img src="4.20.1.png"></p><p>那么，就可以创建多层子文件夹，效果如下：</p><p><img src="4.20.2.png"></p><h3 id="4-21-vscode-文件夹的作用"><a href="#4-21-vscode-文件夹的作用" class="headerlink" title="4.21 .vscode 文件夹的作用"></a>4.21 <code>.vscode</code> 文件夹的作用</h3><p>为了统一团队的 vscode 配置，我们可以在项目的根目录下建立<code>.vscode</code>目录，在里面放置一些配置内容，比如：</p><ul><li><code>settings.json</code>：工作空间设置、代码格式化配置、插件配置。</li><li><code>sftp.json</code>：ftp 文件传输的配置。</li></ul><p><code>.vscode</code>目录里的配置只针对当前项目范围内生效。将<code>.vscode</code>提交到代码仓库，大家统一配置时，会非常方便。</p><h3 id="4-22-自带终端"><a href="#4-22-自带终端" class="headerlink" title="4.22 自带终端"></a>4.22 自带终端</h3><p>我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 <strong>item2</strong>。</p><h3 id="4-23-Markdown-语法支持"><a href="#4-23-Markdown-语法支持" class="headerlink" title="4.23 Markdown 语法支持"></a>4.23 Markdown 语法支持</h3><p>VSCode 自带 markdown 语法高亮。也就是说，如果你是用 Markdown 格式写文章，则完全可以用 VSCode 进行写作。</p><p>写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：</p><p><img src="4.23.png"></p><p>我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。</p><p>你也可以在控制面板输入<code>Markdown: 打开预览</code>，直接全屏预览 markdown 文件。</p><h3 id="4-24-Emmet-in-VSCode"><a href="#4-24-Emmet-in-VSCode" class="headerlink" title="4.24 Emmet in VSCode"></a>4.24 Emmet in VSCode</h3><p><code>Emmet</code>可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。</p><p>举个例子，我们在编辑器中输入缩写代码：<code>ul&gt;li*6</code> ，然后按下 Tab 键，即可得到如下代码片段：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>VS Code 默认支持 Emmet。更多 Emmet 语法规则，请自行查阅。</p><h3 id="4-25-修改字体，使用「Fira-Code」字体"><a href="#4-25-修改字体，使用「Fira-Code」字体" class="headerlink" title="4.25 修改字体，使用「Fira Code」字体"></a>4.25 修改字体，使用「Fira Code」字体</h3><p>这款字体很漂亮，很适合用来写代码：</p><p><img src="4.25.png"></p><p>安装步骤如下：</p><p>（1）进入 <a href="https://github.com/tonsky/FiraCode">https://github.com/tonsky/FiraCode</a> 网站，下载并安装「Fira Code」字体。</p><p>（2）打开 VS Code 的「设置」，搜索<code>font</code>，修改相关配置为如下内容：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"editor.fontFamily"</span><span class="token operator">:</span> <span class="token string">"'Fira Code',Menlo, Monaco, 'Courier New', monospace"</span><span class="token punctuation">,</span> // 设置字体显示<span class="token property">"editor.fontLigatures"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>//控制是否启用字体连字，<span class="token boolean">true</span>启用，<span class="token boolean">false</span>不启用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上方的第二行配置，取决于个人习惯，我是直接设置为<code>"editor.fontLigatures": null</code>，因为我不太习惯连字。</p><h3 id="4-26-代码格式化：Prettier"><a href="#4-26-代码格式化：Prettier" class="headerlink" title="4.26 代码格式化：Prettier"></a>4.26 代码格式化：Prettier</h3><p>我们可以使用 <code>Prettier</code>进行代码格式化，会让代码的展示更加美观。步骤如下：</p><p>（1）安装插件 <code>Prettier</code>。</p><p>（2）在项目的根路径下，新建文件<code>.prettierrc</code>，并在文件中添加如下内容：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"printWidth"</span><span class="token operator">:</span> <span class="token number">150</span><span class="token punctuation">,</span>  <span class="token property">"tabWidth"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token property">"semi"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"singleQuote"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"trailingComma"</span><span class="token operator">:</span> <span class="token string">"es5"</span><span class="token punctuation">,</span>  <span class="token property">"tslintIntegration"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"insertSpaceBeforeFunctionParenthesis"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的内容，是我自己的配置，你可以参考。</p><p>更多配置，可以参考官方文档：<a href="https://prettier.io/docs/en/options.html">https://prettier.io/docs/en/options.html</a></p><h3 id="4-27-文件传输：sftp"><a href="#4-27-文件传输：sftp" class="headerlink" title="4.27 文件传输：sftp"></a>4.27 文件传输：sftp</h3><p>如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装<code>sftp</code>这个插件，很好用。在公司会经常用到。</p><p>步骤如下：</p><p>（1）安装插件<code>sftp</code>。</p><p>（2）配置 <code>sftp.json</code>文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入<code>sftp:config</code>，回车，当前工程的<code>.vscode</code>文件夹下就会自动生成一个<code>sftp.json</code>文件，我们需要在这个文件里配置的内容可以是：</p><ul><li><code>host</code>：服务器的 IP 地址</li><li><code>username</code>：用户名</li><li><code>privateKeyPath</code>：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）</li><li><code>remotePath</code>：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录</li><li><code>ignore</code>：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号</li></ul><p>举例如下：(注意，其中的注释需要去掉)</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"192.168.xxx.xxx"</span><span class="token punctuation">,</span> //服务器ip  <span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span> //端口，sftp模式是<span class="token number">22</span>  <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> //用户名  <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> //密码  <span class="token property">"protocol"</span><span class="token operator">:</span> <span class="token string">"sftp"</span><span class="token punctuation">,</span> //模式  <span class="token property">"agent"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"privateKeyPath"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"passphrase"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"passive"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"interactiveAuth"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"remotePath"</span><span class="token operator">:</span> <span class="token string">"/root/node/build/"</span><span class="token punctuation">,</span> //服务器上的文件地址  <span class="token property">"context"</span><span class="token operator">:</span> <span class="token string">"./server/build"</span><span class="token punctuation">,</span> //本地的文件地址  <span class="token property">"uploadOnSave"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> //监听保存并上传  <span class="token property">"syncMode"</span><span class="token operator">:</span> <span class="token string">"update"</span><span class="token punctuation">,</span>  <span class="token property">"watcher"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    //监听外部文件    <span class="token property">"files"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> //外部文件的绝对路径    <span class="token property">"autoUpload"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token property">"autoDelete"</span><span class="token operator">:</span> <span class="token boolean">false</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"ignore"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    //忽略项    <span class="token string">"**/.vscode/**"</span><span class="token punctuation">,</span>    <span class="token string">"**/.git/**"</span><span class="token punctuation">,</span>    <span class="token string">"**/.DS_Store"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）在 VS Code 的当前文件里，选择「右键 -&gt; upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 <code>host</code> 中配置的服务器 ip）。</p><p>我们还可以选择「右键 -&gt; Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比。</p><h3 id="4-28-自定义代码颜色"><a href="#4-28-自定义代码颜色" class="headerlink" title="4.28 自定义代码颜色"></a>4.28 自定义代码颜色</h3><blockquote><p>进入 VSCode ，按 F1 ，搜索 <strong>Developer: Inspect Editor Tokens and Scopes</strong> ，并点击</p></blockquote><p><img src="4.28.1.png"></p><p>鼠标移到需要换颜色的代码上单击，将 foreground 对应的第一行作用域复制下来：</p><p><img src="4.28.2.png"></p><p>打开 <code>settings.json</code> 文件，我的配置可以参考一下：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"files.autoSave"</span><span class="token operator">:</span> <span class="token string">"afterDelay"</span><span class="token punctuation">,</span>  <span class="token property">"less.compile"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"compress"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> // <span class="token boolean">true</span> => remove surplus whitespace    <span class="token property">"sourceMap"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> // <span class="token boolean">true</span> => generate source maps (.css.map files<span class="token punctuation">)</span>    <span class="token property">"out"</span><span class="token operator">:</span> <span class="token boolean">true</span> // <span class="token boolean">false</span> => DON'T output .css files (overridable per-file<span class="token punctuation">,</span> see below<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"editor.tabSize"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token property">"vetur.validation.template"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"eslint.enable"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"window.zoomLevel"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"files.associations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"*.cjson"</span><span class="token operator">:</span> <span class="token string">"jsonc"</span><span class="token punctuation">,</span>    <span class="token property">"*.wxss"</span><span class="token operator">:</span> <span class="token string">"css"</span><span class="token punctuation">,</span>    <span class="token property">"*.wxs"</span><span class="token operator">:</span> <span class="token string">"javascript"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"emmet.includeLanguages"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"wxml"</span><span class="token operator">:</span> <span class="token string">"html"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"minapp-vscode.disableAutoConfig"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"[javascript]"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"vscode.typescript-language-features"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"[vue]"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"esbenp.prettier-vscode"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"editor.tokenColorCustomizations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"comments"</span><span class="token operator">:</span> <span class="token string">"#00ff00"</span><span class="token punctuation">,</span> // 注释的斜杠    <span class="token property">"keywords"</span><span class="token operator">:</span> <span class="token string">"#dd8dd8"</span><span class="token punctuation">,</span> // 关键字    <span class="token property">"variables"</span><span class="token operator">:</span> <span class="token string">"#00ffff"</span><span class="token punctuation">,</span> // 变量名    <span class="token property">"strings"</span><span class="token operator">:</span> <span class="token string">"#bbffaa"</span><span class="token punctuation">,</span> // 字符串    <span class="token property">"functions"</span><span class="token operator">:</span> <span class="token string">"#ffff00"</span><span class="token punctuation">,</span> // 函数名    <span class="token property">"numbers"</span><span class="token operator">:</span> <span class="token string">"#DD8066"</span><span class="token punctuation">,</span> // 数字    <span class="token property">"textMateRules"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Comment"</span><span class="token punctuation">,</span> // 注释内容        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"comment"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#00ff00"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"[VSCODE-CUSTOM] PHP Punctuation Variable Definition"</span><span class="token punctuation">,</span>        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"punctuation.definition.variable.php"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#dd6f6f"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span> // 字符串        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"string"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#bbffaa"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"HTML:Tags"</span><span class="token punctuation">,</span> // 标签尖括号        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token string">"meta.tag"</span><span class="token punctuation">,</span>          <span class="token string">"punctuation.definition.tag.html"</span><span class="token punctuation">,</span>          <span class="token string">"punctuation.definition.tag.begin.html"</span><span class="token punctuation">,</span>          <span class="token string">"punctuation.definition.tag.end.html"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#66bfad"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"HTML:Tag Names"</span><span class="token punctuation">,</span> // 标签名        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"entity.name.tag"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#ee6c66"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"HTML: Attribute Names"</span><span class="token punctuation">,</span> // 标签内属性名        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token string">"meta.tag entity.other.attribute-name"</span><span class="token punctuation">,</span>          <span class="token string">"entity.other.attribute-name.html"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">"italic"</span><span class="token punctuation">,</span> // 斜体          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#ffff00"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Operator"</span><span class="token punctuation">,</span> // 关键字        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"keyword.operator"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#ad8dda"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"property"</span><span class="token punctuation">,</span> // 普通对象中的属性        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"meta.object-literal.key.js"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#04fdf1"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"prototype"</span><span class="token punctuation">,</span> // 原型对象        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"support.variable.property.js"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#04fdf1"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"!important"</span><span class="token punctuation">,</span> // CSS的!important        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"keyword.other.important.css"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#f00"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"workbench.colorCustomizations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.selectionBackground"</span><span class="token operator">:</span> <span class="token string">"#3390ff"</span> // 选中高亮的颜色  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"[jsonc]"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"esbenp.prettier-vscode"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"workbench.colorTheme"</span><span class="token operator">:</span> <span class="token string">"Ayu Mirage"</span><span class="token punctuation">,</span>  <span class="token property">"workbench.iconTheme"</span><span class="token operator">:</span> <span class="token string">"vscode-icons"</span><span class="token punctuation">,</span>  <span class="token property">"editor.fontSize"</span><span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">,</span>  <span class="token property">"[html]"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"esbenp.prettier-vscode"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、VSCode-插件推荐"><a href="#五、VSCode-插件推荐" class="headerlink" title="五、VSCode 插件推荐"></a>五、VSCode 插件推荐</h2><p>VSCode 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。我来列举几个常见的插件，这些插件都很实用。注意：<strong>顺序越靠前，越实用</strong>。</p><h3 id="5-1-GitLens-【荐】"><a href="#5-1-GitLens-【荐】" class="headerlink" title="5.1 GitLens 【荐】"></a>5.1 GitLens 【荐】</h3><p>我强烈建议你安装插件<code>GitLens</code>，它是 VSCode 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。</p><p>GitLens 在 Git 管理上有很多强大的功能，比如：</p><ul><li>将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。</li><li>查看某个 commit 的代码改动记录</li><li>查看不同的分支</li><li>可以将两个 commit 进行代码对比</li><li>甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招。</li></ul><h3 id="5-2-Git-History"><a href="#5-2-Git-History" class="headerlink" title="5.2 Git History"></a>5.2 Git History</h3><p>有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。</p><h3 id="5-3-Live-Server-【荐】"><a href="#5-3-Live-Server-【荐】" class="headerlink" title="5.3 Live Server 【荐】"></a>5.3 Live Server 【荐】</h3><p>在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。</p><p>使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。</p><h3 id="5-4-Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#5-4-Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="5.4 Chinese (Simplified) Language Pack for Visual Studio Code"></a>5.4 Chinese (Simplified) Language Pack for Visual Studio Code</h3><p>让软件显示为简体中文语言。</p><h3 id="5-5-Bracket-Pair-Colorizer-2：突出显示成对的括号【荐】"><a href="#5-5-Bracket-Pair-Colorizer-2：突出显示成对的括号【荐】" class="headerlink" title="5.5 Bracket Pair Colorizer 2：突出显示成对的括号【荐】"></a>5.5 Bracket Pair Colorizer 2：突出显示成对的括号【荐】</h3><p><code>Bracket Pair Colorizer 2</code>插件：以不同颜色显示成对的括号，并用连线标注括号范围。简称<strong>彩虹括号</strong>。</p><p>另外，还有个<code>Rainbow Brackets</code>插件，也可以突出显示成对的括号。</p><h3 id="5-6-sftp：文件传输-【荐】"><a href="#5-6-sftp：文件传输-【荐】" class="headerlink" title="5.6 sftp：文件传输 【荐】"></a>5.6 sftp：文件传输 【荐】</h3><p>如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装<code>sftp</code>这个插件，很好用。在公司会经常用到。</p><p>详细配置已经在上面讲过。</p><h3 id="5-7-highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】"><a href="#5-7-highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】" class="headerlink" title="5.7 highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】"></a>5.7 highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】</h3><p>VSCode 自带的高亮显示，实在是不够显眼。用插件支持一下吧。</p><p>所用了这个插件之后，VS Code 自带的高亮就可以关掉了：</p><p>在用户设置里添加<code>"editor.selectionHighlight": false</code>即可。</p><p>参考链接：<a href="https://blog.csdn.net/palmer_kai/article/details/79548164">vscode 选中后相同内容高亮插件推荐</a></p><h3 id="5-8-vscode-icons"><a href="#5-8-vscode-icons" class="headerlink" title="5.8 vscode-icons"></a>5.8 vscode-icons</h3><p>vscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。</p><h3 id="5-9-Project-Manager"><a href="#5-9-Project-Manager" class="headerlink" title="5.9 Project Manager"></a>5.9 Project Manager</h3><p>工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。</p><h3 id="5-10-TODO-Highlight"><a href="#5-10-TODO-Highlight" class="headerlink" title="5.10 TODO Highlight"></a>5.10 TODO Highlight</h3><p>写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写<code>TODO</code>，而不是小写的<code>todo</code>）</p><pre><code>//TODO:这里有个bug，我一会儿再收拾你</code></pre><p>或者：</p><pre><code>//FIXME:我也不知道为啥， but it works only that way.</code></pre><p>安装了插件 <code>TODO Highlight</code>之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。</p><h3 id="5-11-WakaTime-【荐】"><a href="#5-11-WakaTime-【荐】" class="headerlink" title="5.11 WakaTime 【荐】"></a>5.11 WakaTime 【荐】</h3><p>统计在 VS Code 里写代码的时间。统计效果如下：</p><p><img src="5.11.png"></p><h3 id="5-12-Markdown-Preview-Github-Styling-【荐】"><a href="#5-12-Markdown-Preview-Github-Styling-【荐】" class="headerlink" title="5.12 Markdown Preview Github Styling 【荐】"></a>5.12 Markdown Preview Github Styling 【荐】</h3><p>以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果：</p><p><img src="5.12.png"></p><h3 id="5-13-Settings-Sync【荐】"><a href="#5-13-Settings-Sync【荐】" class="headerlink" title="5.13 Settings Sync【荐】"></a>5.13 Settings Sync【荐】</h3><ul><li>地址：<a href="https://github.com/shanalikhan/code-settings-sync">https://github.com/shanalikhan/code-settings-sync</a></li><li>作用：多台设备之间，同步 VS Code 配置。通过登录 GitHub 账号来使用这个同步工具。</li></ul><p>同步的详细操作已在上面讲过。</p><h3 id="5-14-Vetur"><a href="#5-14-Vetur" class="headerlink" title="5.14 Vetur"></a>5.14 Vetur</h3><p>Vue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VSCode 官方钦定 Vue 插件。</p><h3 id="5-15-ES7-React-Redux-GraphQL-React-Native-snippets"><a href="#5-15-ES7-React-Redux-GraphQL-React-Native-snippets" class="headerlink" title="5.15 ES7 React/Redux/GraphQL/React-Native snippets"></a>5.15 ES7 React/Redux/GraphQL/React-Native snippets</h3><p>React/Redux/react-router 的语法智能提示。</p><h3 id="5-16-minapp：小程序支持"><a href="#5-16-minapp：小程序支持" class="headerlink" title="5.16 minapp：小程序支持"></a>5.16 minapp：小程序支持</h3><p>小程序开发必备插件。</p><h3 id="5-17-Prettier：代码格式化"><a href="#5-17-Prettier：代码格式化" class="headerlink" title="5.17 Prettier：代码格式化"></a>5.17 Prettier：代码格式化</h3><p>Prettier 是一个代码格式化工具，只关注格式化，但不具备校验功能。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高。</p><h3 id="5-18-ESLint：代码格式校验"><a href="#5-18-ESLint：代码格式校验" class="headerlink" title="5.18 ESLint：代码格式校验"></a>5.18 ESLint：代码格式校验</h3><p>日常开发中，建议用 Prettier 做代码格式化，相比 Beautify 好不少，然后用 eslint 做校验。</p><h3 id="5-19-Search-node-modules-【荐】"><a href="#5-19-Search-node-modules-【荐】" class="headerlink" title="5.19 Search node_modules 【荐】"></a>5.19 Search node_modules 【荐】</h3><p><code>node_modules</code>模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 <code>Search node_modules</code> 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 <code>node_modules</code>，在弹出的选项中选择 <code>Search node_modules</code>，即可搜索 node_modules 里的模块。</p><h3 id="5-20-javascript-console-utils：快速打印-log-日志【荐】"><a href="#5-20-javascript-console-utils：快速打印-log-日志【荐】" class="headerlink" title="5.20 javascript console utils：快速打印 log 日志【荐】"></a>5.20 javascript console utils：快速打印 log 日志【荐】</h3><p>安装好这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 <code>console.log()</code>。简直是日志党福音。</p><p>当我们选中某个变量 <code>name</code>，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 <code>console.log(name)</code>。</p><p>其他的同类插件还有：Turbo Console Log。</p><p>不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。</p><ul><li>打日志，这是最简单、便捷的方式，略显低级，一般新手或资深程序员偷懒时会用。</li><li>断点调试，在前端、Java、PHP、iOS 开发时非常常用，通过断点调试可以很直观地跟踪代码执行逻辑、调用栈、变量等，是非常实用的技巧。</li><li>测试驱动开发，在写代码之前先写测试。与第二的断点调试刚好相反，大部分人不是很习惯这种方式，但在国外开发者或者敏捷爱好者看来，这是最高效的开发方式，在保证代码质量、重构等方面非常有帮助，是现代编程开发必不可少的一部分。</li></ul><h3 id="5-21-Code-Spell-Checker：单词拼写错误检查"><a href="#5-21-Code-Spell-Checker：单词拼写错误检查" class="headerlink" title="5.21 Code Spell Checker：单词拼写错误检查"></a>5.21 Code Spell Checker：单词拼写错误检查</h3><p>这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish.</p><h3 id="5-22-Local-History-【荐】"><a href="#5-22-Local-History-【荐】" class="headerlink" title="5.22 Local History 【荐】"></a>5.22 Local History 【荐】</h3><p>维护文件的本地历史记录，强烈建议安装。代码意外丢失时，有时可以救命。</p><p><img src="5.22.png"></p><h3 id="5-23-Polacode-2020-【荐】"><a href="#5-23-Polacode-2020-【荐】" class="headerlink" title="5.23 Polacode-2020 【荐】"></a>5.23 Polacode-2020 【荐】</h3><p>可以把代码保存成美观的图片，主题不同，代码配色方案也不同，也可以自己设置边框颜色、大小、阴影。</p><p>有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。</p><h3 id="5-24-Image-Preview-【荐】"><a href="#5-24-Image-Preview-【荐】" class="headerlink" title="5.24 Image Preview 【荐】"></a>5.24 Image Preview 【荐】</h3><p>图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。</p><h3 id="5-25-Auto-Close-Tag、Auto-Rename-Tag"><a href="#5-25-Auto-Close-Tag、Auto-Rename-Tag" class="headerlink" title="5.25 Auto Close Tag、Auto Rename Tag"></a>5.25 Auto Close Tag、Auto Rename Tag</h3><p>自动闭合标签、自动对标签重命名。</p><h3 id="5-26-CSS-Peek"><a href="#5-26-CSS-Peek" class="headerlink" title="5.26 CSS Peek"></a>5.26 CSS Peek</h3><p>增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。</p><h3 id="5-27-Vue-CSS-Peek"><a href="#5-27-Vue-CSS-Peek" class="headerlink" title="5.27 Vue CSS Peek"></a>5.27 Vue CSS Peek</h3><p>CSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。</p><h3 id="5-28-Live-Share：实时编码分享"><a href="#5-28-Live-Share：实时编码分享" class="headerlink" title="5.28 Live Share：实时编码分享"></a>5.28 Live Share：实时编码分享</h3><p><code>Live Share</code>这个神奇的插件是由微软官方出品，它的作用是：<strong>实时编码分享</strong>。也就是说，它可以实现你和你的小伙伴一起写代码。这绝对就是<strong>结对编程</strong>的神器啊。</p><p>安装方式：</p><p>打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：</p><p><img src="5.28.1.png"></p><p>上图中，点击红框部分，登录后就可以分享你的工作空间了。</p><h3 id="5-29-Import-Cost"><a href="#5-29-Import-Cost" class="headerlink" title="5.29 Import Cost"></a>5.29 Import Cost</h3><p>在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。<code>Import Cost</code>插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。</p><h3 id="5-30-常见主题插件"><a href="#5-30-常见主题插件" class="headerlink" title="5.30 常见主题插件"></a>5.30 常见主题插件</h3><p>给你的 VSCode 换个皮肤吧，免费的那种：</p><ul><li><p>Dracula Theme</p></li><li><p>Material Theme</p></li><li><p>Nebula Theme</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme">One Dark Pro</a></p></li><li><p>One Monokai Theme</p></li><li><p>Monokai Pro</p></li><li><p>Ayu</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=akarlsten.vscode-snazzy-akarlsten">Snazzy Plus</a></p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=alexanderte.dainty-vscode">Dainty</a></p></li><li><p><code>SynthWave '84</code></p></li><li><p>GitHub Plus Theme：白色主题</p></li><li><p>Horizon Theme：红色主题</p></li></ul><h2 id="六、VSCode-云同步"><a href="#六、VSCode-云同步" class="headerlink" title="六、VSCode 云同步"></a>六、VSCode 云同步</h2><p>我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件，也不需要重新配置软件。</p><p>我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。</p><p><strong>将自己本地的配置云同步到 GitHub</strong>：</p><p>（1）安装插件 <code>settings-sync</code>。</p><p>（2）安装完插件后，在插件里使用 GitHub 账号登录。</p><p>（3）登录后在 VSCode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。</p><p>（4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。</p><p><strong>换另外一个电脑时，从云端同步配置到本地</strong>：</p><p>（1）当我们换另外一台电脑时，可以先在 VSCode 中安装 <code>settings-sync</code> 插件。</p><p>（2）安装完插件后，在插件里使用 GitHub 账号登录。</p><p>（3）登录之后，插件的界面上，会自动出现之前的同步记录：</p><p><img src="6.1.png"></p><p>上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：</p><p><img src="6.2.png"></p><p>如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。</p><p><strong>使用其他人的配置</strong>：</p><p>如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：</p><p>（1）安装插件 <code>settings-sync</code>。</p><p>（2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，选择「下载配置」</p><p>（3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 填坑之 error 整理</title>
      <link href="/2020/12/06/02.git/"/>
      <url>/2020/12/06/02.git/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Git-环境配置"><a href="#一、Git-环境配置" class="headerlink" title="一、Git 环境配置"></a>一、Git 环境配置</h2><p>下载安装流程就不一一赘述了，安装好之后在命令行输入 <code>git</code> 回车或鼠标右键界面空白处查看是否出现 <code>Git GUI Here</code> <code>Git Bash Here</code> 检查是否安装成功。</p><p>Git 安装好去 GitHub 上注册一个账号，注册好后，点击 <code>Git Bash</code>，用账号进行环境配置：</p><p><strong>配置用户名</strong></p><p><code>git config --global user.name "xxx" </code></p><p><strong>配置邮箱</strong></p><p><code>git config --global user.email "xxx@xxx.com"</code></p><p><strong>生成ssh</strong><br><code>ssh-keygen -t rsa</code></p><p>然后连敲三次回车键，结束后去系统盘目录下（一般在 C:\Users\你的用户名.ssh）(mac: /Users/用户/.ssh）查看是否有 <strong>ssh</strong> 文件夹生成，此文件夹中两个文件：<code>id_rsa</code> <code>id_rsa.pub</code></p><p>将ssh文件夹中的公钥（ id_rsa.pub）添加到 GitHub 管理平台中，在 GitHub 个人账户的设置中找到如下界面：</p><p><img src="1.1.png"></p><p><strong>Title</strong> 随便起一个，将公钥（ <strong>id_rsa.pub</strong>）文件中内容复制粘贴到 <strong>key</strong> 中，然后点击 <strong>Ass SSH key</strong> 添加成功。</p><p>在 <code>Git Bash</code> 中输入 <code>ssh -T git@github.com</code> 回车，若出现以下提示就说明配置好啦：</p><p><img src="1.2.png"></p><h2 id="二、Git-与-SVN"><a href="#二、Git-与-SVN" class="headerlink" title="二、Git 与 SVN"></a>二、Git 与 SVN</h2><h3 id="2-1-集中式-SVN"><a href="#2-1-集中式-SVN" class="headerlink" title="2.1 集中式(SVN)"></a>2.1 集中式(SVN)</h3><pre><code>SVN 因为每次存入的都是差异，需要的硬盘空间会相对的小一点，可是回滚的速度会很慢。优点: 代码存放在单一的服务器上，便于项目的管理。缺点: 服务器宕机：员工写的代码得不到保障。服务器炸了：整个项目的历史记录都会丢失。</code></pre><h3 id="2-2-分布式-Git"><a href="#2-2-分布式-Git" class="headerlink" title="2.2 分布式(Git)"></a>2.2 分布式(Git)</h3><pre><code>Git 每次存入的是项目的完整快照 需要的硬盘空间会相对大一点。Git 团队对代码做了极致压缩，最终需要的实际空间比 SVN 多不了太多，可是 Git 的回滚速度极快。</code></pre><h2 id="三、Git-命令"><a href="#三、Git-命令" class="headerlink" title="三、Git 命令"></a>三、Git 命令</h2><h3 id="3-1-底层命令"><a href="#3-1-底层命令" class="headerlink" title="3.1 底层命令"></a>3.1 底层命令</h3><pre><code>git对象git hash-object -w fileUrl: 生成一个key(hash值):val(压缩后的文件内容)键值对存到 .git/objectstree对象git update-index --add --cacheinfo 100644 hash test.txt: 往暂存区添加一条记录(让git对象对应上文件名)存到 .git/indexgit write-tree: 生成树对象存到 .git/objectscommit对象echo 'first commit' | git commit-tree treehash: 生成一个提交对象存到 .git/objects对以上对象的查询git cat-file -p hash: 拿对应对象的内容git cat-file -t hash: 拿对应对象的类型</code></pre><h3 id="3-2-查看暂存区"><a href="#3-2-查看暂存区" class="headerlink" title="3.2 查看暂存区"></a>3.2 查看暂存区</h3><pre><code>git ls-files -s</code></pre><h3 id="3-3-高层命令"><a href="#3-3-高层命令" class="headerlink" title="3.3 高层命令"></a>3.3 高层命令</h3><p><strong>查看 Git 版本</strong></p><pre><code>git --version</code></pre><p><strong>初始化配置</strong></p><pre><code>git config --global user.name "xxx"git config --global user.email xxx@xxx.com    git config --list</code></pre><p><strong>初始化仓库</strong></p><pre><code>git init</code></pre><p><strong>C (新增)</strong></p><pre><code>在工作目录中新增文件git status 查看文件的状态git add ./ 将修改添加到暂存区git commit -m "msg" 将暂存区提交到版本库</code></pre><p><strong>U(修改)</strong></p><pre><code>在工作目录中修改文件git status 查看文件的状态git add ./ 将修改添加到暂存区git commit -m "msg" 将暂存区提交到版本库</code></pre><p><strong>D(删除 &amp; 重命名)</strong></p><pre><code>git rm 要删除的文件git mv 原文件名 新文件名：将工作目录中的文件进行重命名,再将修改添加到暂存区。git rm 文件名：删除工作目录中对应的文件，再将修改添加到暂存区</code></pre><p><strong>R(查询)</strong></p><pre><code>git status: 查看工作目录中文件的状态(已跟踪(已提交 已暂存 已修改) 未跟踪)git diff: 查看未暂存的修改git diff --cache: 查看未提交的暂存git log --oneline: 查看提交记录</code></pre><h2 id="四、分支"><a href="#四、分支" class="headerlink" title="四、分支"></a>四、分支</h2><p><strong>分支的本质其实就是一个提交对象！</strong>所有的分支都会有机会被HEAD所引用(HEAD一个时刻只会指向一个分支)，当我们有新的提交时HEAD会携带当前持有的分支往前移动。<br><strong>HEAD：</strong><br>是一个指针，默认指向master分支，切换分支时其实就是让HEAD指向不同分支。<br>每次有新提交时，HEAD都会带着当前指向的分支一起往前移。</p><p><strong>分支命令：</strong></p><pre><code>git log --oneline --decorate --graph --all: 查看整个项目的分支图  git branch: 查看分支列表git branch -v: 查看分支指向的最新的提交git branch name: 在当前提交对象上创建新的分支git branch name commithash: 在指定的提交对象上创建新的分支git checkout name: 切换分支git branch -d name: 删除空的分支 删除已经被合并的分支git branch -D name: 强制删除分支 创建分支: git branch branchname切换分支: git checkout  branchname创建&amp;切换分支: git checkout -b branchname版本穿梭(时光机): git branch branchname commitHash  普通删除分支: git branch -d branchname强制删除分支: git branch -D branchname合并分支: git merge branchname快进合并 --&gt; 不会产生冲突典型合并 --&gt; 有机会产生冲突解决冲突 --&gt; 打开冲突的文件进行修改 add commit </code></pre><pre><code>查看分支列表: git branch查看合并到当前分支的分支列表: git branch --merged一旦出现在这个列表中就应该删除查看没有合并到当前分支的分支列表: git branch&nbsp;--no-merged一旦出现在这个列表中就应该观察一下是否需要合并</code></pre><p><strong>分支的注意点：</strong></p><pre><code>在切换的时候一定要保证当前分支是干净的!动三个地方：HEAD、暂存区、工作目录    允许切换分支:         分支上所有的内容 处于已提交状态            (避免)分支上的内容是初始化创建 处于未跟踪状态        (避免)分支上的内容是初始化创建 第一次处于已暂存状态    不允许切分支:         分支上所有的内容处于 已修改状态或第二次以后的已暂存状态           在分支上的工作做到一半时 如果有切换分支的需求, 我们应该将现有的工作存储起来    git stash: 会将当前分支上的工作推到一个栈中    分支切换 进行其他工作 完成其他工作后 切回原分支    git stash apply: 将栈顶的工作内容还原 但不让任何内容出栈     git stash drop: 取出栈顶的工作内容后 就应该将其删除(出栈)    git stash pop: git stash apply +  git stash drop     git stash list: 查看存储</code></pre><p><strong>后悔药：</strong></p><pre><code>工作区    撤销工作目录的修改: git checkout -- filename暂存区    撤销暂存区的修改: git reset HEAD  filename版本库    撤销提交: git commit --amend</code></pre><p><strong>reset：</strong></p><pre><code>git log、git reflog: HEAD有变化，git reflog就会记录下来。git reset --soft commithash 用commithash的内容重置HEAD内容。git reset [--mixed] commithash 用commithash的内容重置HEAD内容，重置暂存区。git reset --hard commithash 用commithash的内容重置HEAD内容，重置暂存区，重置工作目录。</code></pre><p><strong>路径 reset：</strong></p><pre><code>所有的路径reset都要省略第一步!第一步是重置HEAD内容，HEAD本质指向一个分支，分支的本质是一个提交对象，提交对象指向一个树对象，树对象又很有可能指向多个git对象，一个git对象代表一个文件，HEAD可以代表一系列文件的状态。git reset HEAD filename 动了暂存区git reset [--mixed] commithash filename 用commithash中filename的内容重置暂存区</code></pre><p><strong>checkout 深入理解：</strong></p><pre><code>git checkout brancname 跟 git reset --hard commithash特别像    共同点        都需要重置 HEAD 暂存区 工作目录    区别        checkout 对工作目录是安全的 reset --hard是强制覆盖        checkout 动HEAD时不会带着分支走而是切换分支        reset --hard 是带着分支走        checkout + 路径      git checkout commithash filename 重置暂存区、工作目录      git checkout -- filename 重置工作目录     </code></pre><h2 id="五、Eslint-结合-Git"><a href="#五、Eslint-结合-Git" class="headerlink" title="五、Eslint 结合 Git"></a>五、Eslint 结合 Git</h2><h3 id="5-1-Eslint"><a href="#5-1-Eslint" class="headerlink" title="5.1 Eslint"></a>5.1 Eslint</h3><pre><code>js代码的检查工具下载: npm i eslint -D使用:    生成配置文件: npx eslint --init    检查js文件: npx eslint 目录名    命中的规则:        字符串必须使用单引号        语句结尾不能有分号        文件的最后必须要有换行</code></pre><h3 id="5-2-Eslint-结合-Git"><a href="#5-2-Eslint-结合-Git" class="headerlink" title="5.2 Eslint 结合 Git"></a>5.2 Eslint 结合 Git</h3><pre><code>husky: 哈士奇, 为Git仓库设置钩子程序使用:    在仓库初始化完毕之后 再去安装哈士奇    在package.json文件写配置        "husky": {            "hooks": {              "pre-commit": "npm run lint"                 // 在git commit之前一定要通过npm run lint的检查              // 只有npm run lint不报错时commit才能真正的运行            }          }           </code></pre><h2 id="六、协作"><a href="#六、协作" class="headerlink" title="六、协作"></a>六、协作</h2><h3 id="6-1-推送、拉取"><a href="#6-1-推送、拉取" class="headerlink" title="6.1 推送、拉取"></a>6.1 推送、拉取</h3><pre><code>正常的数据推送和拉取步骤：    1. 确保本地分支已经跟踪了远程跟踪分支    2. 拉取数据: git pull    3. 推送数据: git push    一个本地分支怎么去跟踪一个远程跟踪分支：    1. 当克隆的时候会自动生成一个master本地分支(已经跟踪了对应的远程跟踪分支)    2. 在新建其他分支时可以指定想要跟踪的远程跟踪分支，本地没有分支：            git checkout -b 本地分支名 远程跟踪分支名            git checkout --track 远程跟踪分支名(remote/分支名)    3. 将一个已经存在的本地分支改成一个跟踪分支，本地已经创建了分支：               git branch -u 远程跟踪分支名(remote/分支名) </code></pre><h3 id="6-2-团队协作"><a href="#6-2-团队协作" class="headerlink" title="6.2 团队协作"></a>6.2 团队协作</h3><pre><code>1. 项目经理初始化远程仓库：   一定要初始化一个空的仓库，在github上操作2. 项目经理创建本地仓库：    git remote 别名 仓库地址(https)    git init 将源码复制进来，修改用户名，修改邮箱    git add    git commit 3. 项目经理推送本地仓库到远程仓库：    清理Windows凭据    git push 别名 分支(输入用户名，密码，推完之后会附带生成远程跟踪分支)4. 项目邀请成员&amp;成员接受邀请，在github上操作5. 成员克隆远程仓库：   git clone 仓库地址(在本地生成.git文件 默认为远程仓库配了别名 orgin)   只有在克隆的时候，本地分支master和远程跟踪分支别名/master是有同步关系的6. 成员做出贡献：   修改源码文件   git add    git commit    git push 别名 分支(输入用户名，密码，推完之后会附带生成远程跟踪分支)  7. 项目经理更新修改：    git fetch 别名(将修改同步到远程跟踪分支上)    git merge 远程跟踪分支</code></pre><h2 id="七、Error-Resolve"><a href="#七、Error-Resolve" class="headerlink" title="七、Error Resolve"></a>七、Error Resolve</h2><h3 id="7-1-non-fast-forward"><a href="#7-1-non-fast-forward" class="headerlink" title="7.1 non-fast-forward"></a>7.1 non-fast-forward</h3><p><strong>问题描述：</strong><code>git push origin login</code> 报错。</p><p><strong>原因：</strong>远程库与本地库不一致导致。比如别人上传到远程仓库后，你没有及时的同步（拉取）到本地，但是你同时又添加了一些内容（提交），以致于你在提交时，它会检测到你之前从远程仓库拉取的时候的仓库状态和现在的不一样。于是，它为了安全起见拒绝了你的提交（然后就报了这个错误）。</p><p><strong>解决方案一：</strong>先合并之前的历史，再进行提交——提倡使用。</p><p>（1）先把 <strong>Git</strong> 的东西 <strong>fetch</strong> 到你本地然后 <strong>merge</strong> 后再 <strong>push</strong> 。</p><pre><code>$ git fetch origin login$ git merge origin FETCH_HEAD</code></pre><p>这2句命令等价于：<code>$ git pull origin login</code>，但是使用 <code>git fetch + git merge</code> 更加安全 </p><p>（2）重定基，可以使历史更加统一，提交历史趋向于一条直线。</p><pre><code>git pull --rebase origin login 意为先取消commit记录，临时保存为补丁之后同步远程库到本地，最后合并补丁到本地库之中</code></pre><p>补充：它们间的关系：</p><pre><code>git pull = git fetch + git merge FETCH_HEAD git pull --rebase =  git fetch + git rebase FETCH_HEAD</code></pre><p>接着输入 <code>git status</code> 可能会报错：</p><p><img src="7.1.png"></p><p>提示 amend 或 continue，amend会继续报错，而continue则会提交本地修改完成修复：</p><pre><code>git rebase --continuegit push origin login（查看GitHub上login分支没问题了）</code></pre><p><strong>解决方案二：</strong>放弃之前的历史，<strong>强推</strong>（用强覆盖方式用你本地的代码替代 Git 仓库内的内容）——谨慎使用。</p><pre><code>$ git push -f  或 $ git push --force</code></pre><blockquote><p>官方文档提示：This flag disables these checks, and can cause the remote repository to lose commits; use it with care.（即：此标志禁用这些检查，并可能导致远程存储库丢失提交；小心使用。）</p></blockquote><h3 id="7-2-failed-to-push-some-refs-to-‘https-github-com-…"><a href="#7-2-failed-to-push-some-refs-to-‘https-github-com-…" class="headerlink" title="7.2 failed to push some refs to ‘https://github.com/…"></a>7.2 failed to push some refs to ‘<a href="https://github.com/">https://github.com/</a>…</h3><p><strong>问题描述：</strong>在 git bash 中键入 $ git push origin master 提交时出现。</p><p><strong>原因：</strong>远程库与本地库不一致导致，在 hint 中也有提示把远程库同步到本地库即可。</p><p><strong>解决方案：</strong></p><pre><code>git pull --rebase origin master</code></pre><p>该命令的意思是把远程库中的更新合并到（pull = fetch + merge）本地库中，–-rebase 的作用是取消掉本地库中刚刚的 commit，并把它们对接到更新后的版本库之中。</p><h3 id="7-3-…-you-have-unmerged-files"><a href="#7-3-…-you-have-unmerged-files" class="headerlink" title="7.3 … you have unmerged files"></a>7.3 … you have unmerged files</h3><p><strong>问题描述：</strong>将本地代码提交到 GitHub 后某些组件插件或其他文件夹丢失。</p><p><strong>原因：</strong>使用 Git 时，没有提前 <code>git pull</code>，就把自己本地修改的文件 <code>git add</code>、<code>git commit</code>，就会出现 “ … you have unmerged files.” 的 error。</p><p><strong>解决方案：</strong></p><pre><code>git reflog：复制以前分支的 hashgit reset --hard hash：回溯之前版本</code></pre><p>然后重新提交：</p><pre><code>git statusgit add . git commit -m "msg"</code></pre><p><code>git push origin 分支</code> 可能会出现报错：<code>non-fast-forward</code> ,参考上述解决方案。</p><h3 id="7-4-already-up-to-date"><a href="#7-4-already-up-to-date" class="headerlink" title="7.4 already up to date"></a>7.4 already up to date</h3><p><strong>问题描述：</strong>合并 login 分支时报错 <code>already up to date</code> 。</p><p><strong>解决方案：</strong></p><pre><code>git checkout mastergit reset --hard logingit push --force origin master</code></pre><p>查看 GitHub 发现主分支和 login 分支都更新成功，搞腚！</p><h3 id="7-5-error-setting-certificate-verify-locations"><a href="#7-5-error-setting-certificate-verify-locations" class="headerlink" title="7.5 error setting certificate verify locations"></a>7.5 error setting certificate verify locations</h3><p><strong>问题描述：</strong>执行 <code>git push origin master</code> 命令时出错:</p><pre><code>fatal: unable to access ‘https://github.com/…/’: error setting certificate verify locations:CAfile: D:/Git/Git/mingw64/ssl/certs/ca-bundle.crtCApath: none</code></pre><p><strong>解决方案：</strong></p><p>（1）<code>git config –system http.sslcainfo “C:\Program Files (x86)\git\bin\curl-ca-bundle.crt”</code></p><p>（2）<code>git config –system http.sslverify false</code></p><p>（3）顺着报错信息在文件树里找，发现：<strong>D:/Git/mingw64/libexec 没有 ssl 目录</strong>。但在 <strong>D:\Git\mingw64</strong> 目录下有 <strong>ssl/certs/ca-bundle.crt</strong> 这个路径。将 <strong>ssl 目录</strong> 复制到 <strong>D:/Git/mingw64/libexec</strong> 下即可。</p><h3 id="7-6-Git-Bash-Here-失效"><a href="#7-6-Git-Bash-Here-失效" class="headerlink" title="7.6 Git Bash Here 失效"></a>7.6 Git Bash Here 失效</h3><p><strong>问题描述：</strong>在某个文件夹下右键选择 <code>git bash/gui here</code> ，结果显示 <strong>“找不到应用程序”</strong>，这是 Git 相关的文件路径变更导致的。</p><p><strong>解决方案：</strong></p><p>（1）<strong>win + R</strong> 打开命令行窗口，输入 <strong>regedit</strong> 打开注册表。</p><p>（2）根据路径查找 [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\git_shell\command] 和[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_shell\command] 。</p><p>将其数值数据里面的路径修改为现在的 <strong>git bash.exe</strong> 的路径：</p><p><img src="7.6.1.png"></p><p>将其 <strong>git_shell</strong> 改为 <strong>git_gui</strong> ，找到两个路径，将其数值数据里面的路径修改为现在的 <strong>git gui.exe</strong> 的路径<br>关闭注册表，接着在文件夹右键选择 <strong>git bash/gui here</strong> ，发现可以打开，完成。</p><p>然后你会发现<strong>新问题</strong>：git clone 不好用，<strong>解决：</strong>在 Git 安装包下，找到 <strong>gitconfig</strong> 文件修改里边的路径信息</p><p><img src="7.6.2.png"></p><p><img src="7.6.3.png"></p><p>这里改好就好了，记住安装完 Git <strong>不要随便移动路径</strong>，因为注册表中的信息不会改变。</p><h3 id="7-7-管理小程序"><a href="#7-7-管理小程序" class="headerlink" title="7.7 管理小程序"></a>7.7 管理小程序</h3><p>和管理日常项目流程如出一撤，具体如何用 Git 管理小程序就不一一赘述了，有需要可以看这篇：<a href="https://blog.csdn.net/qq_36672905/article/details/82887102">微信小程序如何使用Git实现版本管理</a></p><p>说下遇到的问题：<code>push</code> 远程仓库提示 <code>error invalid authentication scheme</code></p><p><strong>解决方案：</strong>在微信小程序的设置里面配置仓库设置中的网络认证，认证选择用户名和密码，然后填写好你创建远程仓库时候设置的用户名和密码。</p><p><img src="7.7.png"></p><h3 id="7-8-问题征集"><a href="#7-8-问题征集" class="headerlink" title="7.8 问题征集"></a>7.8 问题征集</h3><p>到此为止关于 Git 相关的知识就整理完毕了，阿呆暂时只遇到了这些问题，以后出现新问题我会及时整理更新，诸君有其他的疑问也欢迎在评论区留言哦。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> ESLint </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 使用详解（附图文）</title>
      <link href="/2020/12/05/01.markdown/"/>
      <url>/2020/12/05/01.markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管你是开发人亦或是写作人，应该知道 Markdown 语法的重要性，如果不了解也问题不大，话说这玩意好用且属实easy，记性好的伙计可能分分钟搞腚，话不多说瞅瞅看就知道了。</p><h2 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h2><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">加粗</td><td align="center">Ctrl + B</td></tr><tr><td align="center">斜体</td><td align="center">Ctrl + I</td></tr><tr><td align="center">引用</td><td align="center">Ctrl + Q</td></tr><tr><td align="center">插入链接</td><td align="center">Ctrl + L</td></tr><tr><td align="center">插入代码</td><td align="center">Ctrl + K</td></tr><tr><td align="center">插入图片</td><td align="center">Ctrl + G</td></tr><tr><td align="center">提升标题</td><td align="center">Ctrl + H</td></tr><tr><td align="center">有序列表</td><td align="center">Ctrl + O</td></tr><tr><td align="center">无序列表</td><td align="center">Ctrl + U</td></tr><tr><td align="center">横线</td><td align="center">Ctrl + R</td></tr><tr><td align="center">撤销</td><td align="center">Ctrl + Z</td></tr><tr><td align="center">重做</td><td align="center">Ctrl + Y</td></tr></tbody></table><h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><h3 id="2-1-字体设置斜体、粗体、删除线"><a href="#2-1-字体设置斜体、粗体、删除线" class="headerlink" title="2.1 字体设置斜体、粗体、删除线"></a>2.1 字体设置斜体、粗体、删除线</h3><p>*斜体* =&gt; <em>斜体</em>、_斜体_ =&gt; _斜体_、**加粗** =&gt; <strong>加粗</strong>、***倾斜加粗*** =&gt; <em><strong>倾斜加粗</strong></em>、~~ 删除线~~ =&gt; <del>删除线</del></p><p><img src="font.png"></p><h3 id="2-2-分级标题"><a href="#2-2-分级标题" class="headerlink" title="2.2 分级标题"></a>2.2 分级标题</h3><p><strong>写法1：</strong><br># 一级标题、## 二级标题、### 三级标题、#### 四级标题、##### 五级标题、###### 六级标题</p><p><img src="title_01.png"></p><p><strong>写法2：</strong><br>一级标题：在一级标题下一行加一个或多个“=”；二级标题：在二级标题下一行加一个或多个“-”</p><p><img src="title_02.png"></p><h3 id="2-3-链接"><a href="#2-3-链接" class="headerlink" title="2.3 链接"></a>2.3 链接</h3><p>（1）普通链接：将链接地址用 &lt; &gt; 包起来：</p><p><img src="link.png"></p><p>（2）插入图片链接： ![图片描述](图片url)（图片描述可省略）<br>（3）参考链接：[关键字](链接地址 “添加一个标题（可选）”)</p><blockquote><p>注意：配合 Hexo 使用可能会遇到这种情况，本地编辑器上的图片 url 使用相对路径可以显示，但 hexo g + hexo s 打包后失效。</p><p>建议：暂时缘由不明，研究发现将 xxx.md 对应所有图片放在文件夹 xxx 中（取名一致），且处于同一层目录下即可。</p></blockquote><h3 id="2-4-分割线"><a href="#2-4-分割线" class="headerlink" title="2.4 分割线"></a>2.4 分割线</h3><p>在一行中用三个以上的星号(*)、减号(-)或底线(_)生成分隔线，行内不能有其他东西。也可以在星号或减号中间插入空格。</p><p><img src="cross_line.png"></p><h3 id="2-5-代码块"><a href="#2-5-代码块" class="headerlink" title="2.5 代码块"></a>2.5 代码块</h3><p><strong>写法1：</strong><br>缩进4个空格或一个制表符（Tab）<br><strong>写法2：</strong><br>（1）用英文的单反引号（在 Esc 键下方，和 ~ 同一个键）包裹代码，多行代码需要在代码块上一行和下一行使用三个单反引号包裹，同时可在第一行反引号后面，输入代码块所使用的语言，实现代码高亮。</p><p><img src="code_block_01.png"></p><p>（2）在代码块中， &amp; 、 &lt; 和 &gt; 会被 Markdown 自动转成 HTML 实体，示例：</p><p><img src="code_block_02.png"></p><h3 id="2-6-引用"><a href="#2-6-引用" class="headerlink" title="2.6 引用"></a>2.6 引用</h3><p>（1）在被引用的文本前加 &gt; 号和一个空格，只输入了一个 &gt; 号会产生一个空白的引用：</p><p><img src="quote_01.png"></p><p>（2）引用嵌套使用：</p><p><img src="quote_02.png"></p><p>（3）引用内也可加其他 Markdown 语法，包括标题、列表、代码块等这里不一一演示。</p><h3 id="2-7-列表"><a href="#2-7-列表" class="headerlink" title="2.7 列表"></a>2.7 列表</h3><p>（1）无序列表：使用 *，+，- 符号表示无序列表，符号后面<strong>一腚要有个空格</strong>。</p><p><img src="list_01.png"></p><p>（2）有序列表：使用数字和一个英文点号表示有序列表，点号后面<strong>一腚要有个空格</strong>。</p><p><img src="list_02.png"></p><p>（3）二者同时使用：</p><p><img src="list_03.png"></p><p>（4）列表内也可加入其他 Markdown 语法，包括标题、引用、代码块等这里不一一演示。</p><blockquote><p><strong>注意：</strong></p><ol><li>加粗效果不能直接用于列表标题里面，但是可以嵌套在列表里面混合使用。</li><li>列表中包含代码块（前面加2个 Tab 或者8个空格，并且需要空一行，否则不显示）。</li><li>数字后接英文点，会无意中生成列表，如2020.12.04日期，有时会被误认为列表。解决：在每个点前面加上 \ 即可。</li></ol></blockquote><h3 id="2-8-表格"><a href="#2-8-表格" class="headerlink" title="2.8 表格"></a>2.8 表格</h3><p>（1）多的不说直接上图：</p><p><img src="table_01.png"></p><p>（2）指定对齐方式：英文冒号在英文减号左侧表示左对齐，右侧表示右对齐，两边都有表示居中。</p><p><img src="table_02.png"></p><h2 id="三、常用技巧"><a href="#三、常用技巧" class="headerlink" title="三、常用技巧"></a>三、常用技巧</h2><h3 id="3-1-换行"><a href="#3-1-换行" class="headerlink" title="3.1 换行"></a>3.1 换行</h3><p>（1）连续两个以上空格 + 回车<br>（2）使用 HTML 换行标签</p><h3 id="3-2-缩进字符"><a href="#3-2-缩进字符" class="headerlink" title="3.2 缩进字符"></a>3.2 缩进字符</h3><p>不断行的空白格或半角的空格或全角的空格：</p><p><img src="indent.png"></p><h3 id="3-3-特殊符号"><a href="#3-3-特殊符号" class="headerlink" title="3.3 特殊符号"></a>3.3 特殊符号</h3><p>（1）对于 Markdown 中的语法符号，前面加反斜杠 \ 即可显示符号本身：</p><p><img src="symbol_01.png"></p><p>（2）其他特殊字符：</p><p><img src="symbol_02.png"></p><p>（3）<a href="https://unicode-table.com/">字符对应的 Unicode</a></p><h3 id="3-4-脚注"><a href="#3-4-脚注" class="headerlink" title="3.4 脚注"></a>3.4 脚注</h3><p>在需要添加脚注的文本后加上[^注脚名字]，然后在文本的任意位置(一般在最后)添加对应的脚注即可：</p><p><img src="footnote.png"></p><blockquote><p><strong>注意：</strong><br>脚注自动被搬运到最后面，请到文章末尾查看，脚注后方的链接可以直接跳转回到加注的位置。</p></blockquote><h3 id="3-5-表情速查表"><a href="#3-5-表情速查表" class="headerlink" title="3.5 表情速查表"></a>3.5 表情速查表</h3><p>详情参考：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">表情语法大全</a> ，花里胡哨的一大堆…</p><h2 id="四、高阶用法"><a href="#四、高阶用法" class="headerlink" title="四、高阶用法"></a>四、高阶用法</h2><h3 id="4-1-Latex数学公式"><a href="#4-1-Latex数学公式" class="headerlink" title="4.1 Latex数学公式"></a>4.1 Latex数学公式</h3><p>（1）行内公式：使用两个”$”符号引用公式<br>（2）行间公式：使用两对“$$”符号引用公式<br>详情参考：<a href="https://www.mohu.org/info/symbols/symbols.htm">Latex数学符号</a></p><h3 id="4-2-流程图"><a href="#4-2-流程图" class="headerlink" title="4.2 流程图"></a>4.2 流程图</h3><p>不建议用 Markdown 做各种图，仅作了解：</p><p><img src="flow_chart.png"></p><h3 id="4-3-Todo-列表"><a href="#4-3-Todo-列表" class="headerlink" title="4.3 Todo 列表"></a>4.3 Todo 列表</h3><p><img src="todo_list.png"></p><h3 id="4-4-序号图"><a href="#4-4-序号图" class="headerlink" title="4.4 序号图"></a>4.4 序号图</h3><p><img src="order_list.png"></p><h3 id="4-5-甘特图"><a href="#4-5-甘特图" class="headerlink" title="4.5 甘特图"></a>4.5 甘特图</h3><p><img src="gantt_chart.png"></p><h2 id="五、Markdown-工具"><a href="#五、Markdown-工具" class="headerlink" title="五、Markdown 工具"></a>五、Markdown 工具</h2><p>太多了太多了，这里只推荐两个顶呱呱的：<strong>Typora</strong> 和 <strong>MarkdownPad</strong>，我用的 <strong>Typora</strong> 。</p><p>Typora 的设计理念很 cool，是真正的<strong>即时预览型编辑器</strong>，不同于左右两个窗口，追求<strong>极致的简洁</strong>，它将「写字」和「预览」合体了。可切换到“源代码模式”，Typora 可进行多种文档格式转换如 Word。流畅度、反应速度很快，适合辣些<strong>手速快</strong>的<strong>ds</strong>（大神）贵族。</p><p><img src="typora.png"></p><p>MarkdownPad 被很多人称赞为 Windows 下最好用的 Markdown 编辑器之一，功能之强大自然不必解释：</p><p><img src="markdownpad.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 搭建教程</title>
      <link href="/2020/12/04/00.website/"/>
      <url>/2020/12/04/00.website/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如今写文章的平台太多了太多了，大亿点的像知乎、CSDN、博客园、掘金、思否还有简书等等太多了。我以前是在CSDN、博客园等平台上做下学习的记录以及分享。有一说一这些网站做得非常 nice，大部分想知道的知识上面都有且<strong>方便收藏</strong>，然鹅它们不够<strong>个性化</strong>，作为一个边缘人思量一番撅腚自己建个無名小站得了，兜兜转转最后还是选择了 Hexo + <a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a> 来搭建。</p><h2 id="一、安装-Git、Node-js、Hexo"><a href="#一、安装-Git、Node-js、Hexo" class="headerlink" title="一、安装 Git、Node.js、Hexo"></a>一、安装 Git、Node.js、Hexo</h2><h3 id="1-1-安装-Git"><a href="#1-1-安装-Git" class="headerlink" title="1.1 安装 Git"></a>1.1 安装 Git</h3><p>为了把本地文件上传到 GitHub，需要用到目前最先进的分布式版本控制工具 <strong>Git</strong>，不得不说 <strong>Linus Torvalds</strong> 永远滴神，基于这个之后又有了全球最大的同性交友平台 GitHub，三个旧金山的年轻人在2008年4月创办，正如每个伟大的传奇都开始于一场冒险，Tom 在这篇文章 <a href="http://tom.preston-werner.com/2008/10/18/how-i-turned-down-300k.html">我如何辞掉微软30万年薪邀约，创办GitHub</a> 中谈到：当我老去，回顾一生，我想说，”哇，那是一场冒险“；而不是，“哇，我真的很安稳“。</p><p><strong>Windows下载：</strong>到 Git 官网上下载，安装时选项默认，只不过最后一步添加路径时要选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开 Git 了。之后，就可以直接右键空白处使用<code>git bash</code>来敲命令行了。</p><p><strong>linux下载：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>安装完成后在命令提示符中输入<code>git --version</code>来查看一下版本验证是否安装成功。<br>对了，记得 <a href="https://blog.csdn.net/huangqqdy/article/details/83032408">配置环境变量</a></p></blockquote><h3 id="1-2-安装-Node-js"><a href="#1-2-安装-Node-js" class="headerlink" title="1.2 安装 Node.js"></a>1.2 安装 Node.js</h3><p>Hexo 是基于Node.js 的，需要官网安装 Node.js，然后配置好环境变量，方法和 Git 一样，这里就不一一赘述了。</p><p>安装完后，打开命令行，输入：<code>node -v</code>和<code>npm -v</code>检查是否安装成功。</p><h3 id="1-3-添加阿里的镜像源加速下载"><a href="#1-3-添加阿里的镜像源加速下载" class="headerlink" title="1.3 添加阿里的镜像源加速下载"></a>1.3 添加阿里的镜像源加速下载</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-安装-Hexo"><a href="#1-4-安装-Hexo" class="headerlink" title="1.4 安装 Hexo"></a>1.4 安装 Hexo</h3><p>Git 和 Node.js 安装好后，就可以去安装 Hexo 了，你可以先创建一个文件夹比如叫 Blog，用来存放自己的博客文件。</p><p>在该目录下右键空白处点击 <code>Git Bash Here</code> 定位到该目录下，然后输入命令 <code>npm install -g hexo-cli</code> 来安装 <code>Hexo</code>。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完毕后输入 <code>hexo -v</code> 验证是否安装成功，接下来初始化一下 Hexo，输入 <code>hexo init</code> 初始化文件夹。</p><pre class="line-numbers language-bash"><code class="language-bash">hexo init Blog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着输入 <code>npm install</code> 安装必备的组件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> Blog // 进入这个MyBlog文件夹<span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>新建完成后，指定文件夹 Blog 目录下有：</p><ul><li><code>node_modules:</code> 依赖包</li><li><code>public：</code>存放生成的页面</li><li><code>scaffolds：</code>生成文章的一些模板</li><li><code>source：</code>用来存放你的文章</li><li><code>themes：</code>主题</li><li><code>_config.yml:</code> 博客的配置文件</li></ul><p>如此这般把本地的网站配置完毕后，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器</p><pre class="line-numbers language-bash"><code class="language-bash">hexo ghexo server<span class="token punctuation">(</span>或者简写:hexo s）<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后浏览器打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%95%A6">http://localhost:4000/，就可以看到我们的博客网站啦</a></p><p>按<code>Ctrl + C</code>关闭本地服务器</p><h2 id="二、GitHub-创建个人仓库"><a href="#二、GitHub-创建个人仓库" class="headerlink" title="二、GitHub 创建个人仓库"></a>二、GitHub 创建个人仓库</h2><p>接下来需要注册一个<code>GitHub</code>账号，用来存放我们的网站。然后打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%60New">https://github.com/，新建一个仓库`New</a> repository<code> 输入自己的项目名，后面一定要加</code>.github.io<code>后缀，</code>README`初始化也要勾上。</p><h2 id="三、生成-SSH-添加到-GitHub"><a href="#三、生成-SSH-添加到-GitHub" class="headerlink" title="三、生成 SSH 添加到 GitHub"></a>三、生成 SSH 添加到 GitHub</h2><p><strong>生成<code>SSH</code>添加到<code>GitHub</code>，连接<code>Github</code>与本地。</strong><br>右键空白打开<code>git bash</code>，接着输入下面命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"yourname"</span><span class="token function">git</span> config --global user.email <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的<code>yourname</code>输入你的<code>GitHub</code>用户名，<code>youremail</code>输入你<code>GitHub</code>的邮箱。</p><p>然后创建<code>SSH</code>,一路回车（三、四次来着）</p><blockquote><p><code>ssh</code>，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在<code>GitHub</code>上，这样当你链接<code>GitHub</code>自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过<code>git</code>上传你的文件到<code>GitHub</code>上。</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时它会告诉你已经生成了<code>.ssh</code>的文件夹。在你的电脑中找到这个文件夹。或者<code>git bash</code>中输入：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>准备将输出的内容复制到 GitHub 中进行保存：</p><p>打开<a href="http://github.com/">GitHub</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取个，把<code>id_rsa.pub</code>里面的信息复制进去。<br>在<code>git bash</code>输入<code>ssh -T git@github.com</code>，如果出现你的用户名，辣就成功了。</p><h2 id="四、将-Hexo-部署到-GitHub"><a href="#四、将-Hexo-部署到-GitHub" class="headerlink" title="四、将 Hexo 部署到 GitHub"></a>四、将 Hexo 部署到 GitHub</h2><p>这一步，我们就可以将<code>Hexo</code>和<code>GitHub</code>关联起来，也就是将<code>Hexo</code>生成的文章部署到<code>GitHub</code>上，打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这你可以修改与博客配置相关的各种信息。</p><p>修改最后一行的配置：</p><pre class="line-numbers language-yml"><code class="language-yml">deploy:  type: git  repository: https://github.com/adaichan/adaichan.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repository </code>修改为你自己的 <code>github</code> 项目地址即可，就是部署时告诉工具，将生成网页通过 <code>git</code> 方式上传到你对应的链接仓库中。</p><p>这个时候需要先安装 <code>deploy-git</code> ，即部署命令，这样你才能用命令部署到 <code>GitHub</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后依次进行：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中 <code>hexo clean</code> 清除了你之前生成的东西， <code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code> 缩写 ，<code>hexo deploy</code> 部署文章，可以用 <code>hexo d</code> 缩写。</p><blockquote><p>注意<code>deploy</code>时可能要你输入<code>username</code>和<code>password</code></p></blockquote><h2 id="五、设置个人域名"><a href="#五、设置个人域名" class="headerlink" title="五、设置个人域名"></a>五、设置个人域名</h2><p>目前你的个人网站的地址是<code>yourname.github.io</code>，如果不喜欢该网址，这就需要你设置个人域名了，就是需要<strong>花点银子</strong>。</p><blockquote><p><strong>不过，这一步不是必要的，如果目前还不想买域名可以先跳过，继续看后面的，以后想买域名了在还看这块</strong></p></blockquote><p>首先你得购买一个专属域名，<code>xx</code>云都能买，看个人喜好。以腾讯云为例，腾讯云官网购买，然后实名认证后进入腾讯云控制台，点云解析进去，找到你刚买的域名，点进去添加两条解析记录，然后打开你的<code>github</code>博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存。</p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\Blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到<code>GitHub</code>。</p><p>过不了多久，再打开你的浏览器，输入你自己的专属域名，就可以看到搭建的网站啦！</p><h2 id="六、写文章、发布文章"><a href="#六、写文章、发布文章" class="headerlink" title="六、写文章、发布文章"></a>六、写文章、发布文章</h2><p>首先在博客根目录下右键打开<code>git bash</code>，安装一个扩展：<code>npm i hexo-deployer-git</code></p><p>然后输入：<code>hexo new post "article title"</code>，新建一篇文章</p><p>打开 <code>D:\Blog\source\_posts</code> 的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件。</p><p>你可以会直接下载一个 <strong>Typora</strong> 编辑器，在里面编写 Markdown 文件，可以实时预览。编写完 Markdown 文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到<code>Github</code>上（突然想起 G.S.D，每一段都是盲人刮痧）。这时打开你的<code>github.io</code>主页就能看到发布的文章啦！</p><h2 id="七、吐槽"><a href="#七、吐槽" class="headerlink" title="七、吐槽"></a>七、吐槽</h2><p>到这一个比较简陋的个人博客小站基本上就搭建完了，写得很不详细，但问题不大我能看懂就行，其它的优化部分一言难尽各种 bug 层出不穷，不是只言片语扯得清的。若想实现一些花里胡哨的功能少不了大量的鼓捣折腾，<strong>不可能一蹴而就</strong>，毕竟我这也只是刚从未开化状态进入社会主义初级阶段，未来有空自会添砖加瓦。需要个性化定制主题可以参考 <a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a> ，相信会符合诸君口味，在这里致敬 <strong>闪烁之狐</strong> 的开源 ^o^</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
