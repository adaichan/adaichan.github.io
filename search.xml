<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Excel 前端导出</title>
      <link href="/2023/12/28/21.excel-dao-chu/"/>
      <url>/2023/12/28/21.excel-dao-chu/</url>
      
        <content type="html"><![CDATA[<h3 id="一、使用插件"><a href="#一、使用插件" class="headerlink" title="一、使用插件"></a>一、使用插件</h3><p>像excel.js、xlsx.js、js-export-excel这类插件都可以轻松实现</p><pre class="line-numbers language-js"><code class="language-js">npm install js<span class="token operator">-</span><span class="token keyword">export</span><span class="token operator">-</span>excel <span class="token comment" spellcheck="true">// 或者</span>yarn add js<span class="token operator">-</span><span class="token keyword">export</span><span class="token operator">-</span>excel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> ExportJsonExcel <span class="token keyword">from</span> <span class="token string">'js-export-excel'</span><span class="token comment" spellcheck="true">// 模拟数据</span><span class="token keyword">const</span> tableItemConfig <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">{</span> label<span class="token punctuation">:</span> <span class="token string">'序号'</span><span class="token punctuation">,</span> prop<span class="token punctuation">:</span> <span class="token string">'index'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> label<span class="token punctuation">:</span> <span class="token string">'物料编码'</span><span class="token punctuation">,</span> prop<span class="token punctuation">:</span> <span class="token string">'materialCode'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> label<span class="token punctuation">:</span> <span class="token string">'物料名称'</span><span class="token punctuation">,</span> prop<span class="token punctuation">:</span> <span class="token string">'materialName'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> label<span class="token punctuation">:</span> <span class="token string">'规格型号'</span><span class="token punctuation">,</span> prop<span class="token punctuation">:</span> <span class="token string">'specification'</span><span class="token punctuation">,</span> width<span class="token punctuation">:</span> <span class="token number">150</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token keyword">const</span> arrayData <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>materialCode<span class="token punctuation">:</span><span class="token number">10086</span><span class="token punctuation">,</span>materialName<span class="token punctuation">:</span><span class="token string">'篮球'</span><span class="token punctuation">,</span>specification<span class="token punctuation">:</span><span class="token string">'20*20*20'</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 使用</span><span class="token keyword">const</span> option<span class="token punctuation">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> any<span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>option<span class="token punctuation">.</span>fileName <span class="token operator">=</span> <span class="token string">'文件名'</span>option<span class="token punctuation">.</span>datas <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        sheetData<span class="token punctuation">:</span> arrayData<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 数组数据</span>        sheetName<span class="token punctuation">:</span> <span class="token string">'表格名'</span><span class="token punctuation">,</span>        sheetFilter<span class="token punctuation">:</span> tableItemConfig<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token operator">></span> i<span class="token punctuation">.</span>prop<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 字段prop</span>        sheetHeader<span class="token punctuation">:</span> tableItemConfig<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token operator">></span> i<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 字段中文</span>        columnWidths<span class="token punctuation">:</span> tableItemConfig<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>width <span class="token operator">?</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>width <span class="token operator">/</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 列宽</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token keyword">const</span> toExcel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExportJsonExcel</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span>toExcel<span class="token punctuation">.</span><span class="token function">saveExcel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、接口返回"><a href="#二、接口返回" class="headerlink" title="二、接口返回"></a>二、接口返回</h3><p>接口加工好返回，用a标签下载就行</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> downloadFile <span class="token operator">=</span> <span class="token punctuation">(</span>data<span class="token punctuation">:</span> any<span class="token punctuation">,</span> fileName<span class="token punctuation">:</span> any<span class="token punctuation">,</span> fileSuffix<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> fileTypeMime <span class="token operator">=</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// 文件 mime 类型，移动端必传，否则下载不成功；pc端可传可不传</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>    fileSuffix <span class="token comment" spellcheck="true">// 获取后缀对应的 mime</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">'png'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/png'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'doc'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/msword'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'docx'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.openxmlformats-officedocument.wordprocessingml.document'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'jpg'</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token string">'jpeg'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/jpeg'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'gif'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/gif'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'svg'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/svg+xml'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'tif'</span><span class="token punctuation">:</span>    <span class="token keyword">case</span> <span class="token string">'tiff'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'image/tiff'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'txt'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'text/plain'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'ppt'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.ms-powerpoint'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'pptx'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.openxmlformats-officedocument.presentationml.presentation'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'xls'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.ms-excel'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'xlsx'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'zip'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/zip'</span>      <span class="token keyword">break</span>    <span class="token keyword">case</span> <span class="token string">'7z'</span><span class="token punctuation">:</span>      fileTypeMime <span class="token operator">=</span> <span class="token string">'application/x-7z-compressed'</span>      <span class="token keyword">break</span>  <span class="token punctuation">}</span>  <span class="token keyword">const</span> blob <span class="token operator">=</span> window<span class="token punctuation">.</span>URL<span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>    <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>data<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>      type<span class="token punctuation">:</span> fileTypeMime<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span>  <span class="token keyword">const</span> link <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>  link<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span>  link<span class="token punctuation">.</span>href <span class="token operator">=</span> blob  link<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'download'</span><span class="token punctuation">,</span> fileName<span class="token punctuation">)</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span>  link<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//下载完成移除元素</span>  window<span class="token punctuation">.</span>URL<span class="token punctuation">.</span><span class="token function">revokeObjectURL</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//释放掉 blob 对象</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//临时表数据下载</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">downloadFiles</span><span class="token punctuation">(</span>configCode<span class="token punctuation">:</span> string<span class="token punctuation">,</span> query<span class="token punctuation">:</span> any<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    url<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`/wms/wms-account/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>configCode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/download`</span></span><span class="token punctuation">,</span>    method<span class="token punctuation">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>    params<span class="token punctuation">:</span> query<span class="token punctuation">,</span>    responseType<span class="token punctuation">:</span> <span class="token string">'blob'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> fileName <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">decodeURI</span><span class="token punctuation">(</span>      res<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'content-disposition'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>        res<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'content-disposition'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'filename='</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">9</span>      <span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">const</span> fileSuffix <span class="token operator">=</span> fileName<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>fileName<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fileName<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token function">downloadFile</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">,</span> fileName<span class="token punctuation">,</span> fileSuffix<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、WebWorker"><a href="#三、WebWorker" class="headerlink" title="三、WebWorker"></a>三、WebWorker</h3><p>​    如果数据量大需要进一步计算处理，如日期或其他字段的 format 以及格式转换会增加 JS 线程的开销可以使用WebWorker。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sass 基础学习</title>
      <link href="/2023/12/06/20.sass/"/>
      <url>/2023/12/06/20.sass/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装和使用"><a href="#一、安装和使用" class="headerlink" title="一、安装和使用"></a>一、安装和使用</h2><p><a href="http://sass-lang.com/">Sass</a>是一种 CSS 的开发工具，提供了许多便利写法，大大节省了设计者的时间，使得 CSS 的开发，变得简单和可维护。</p><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p>SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先<a href="http://www.ruby-lang.org/zh_cn/downloads/">安装Ruby</a>，然后再安装SASS。</p><p>假定你已经安装好了Ruby，接着在命令行输入下面的命令：</p><blockquote><p>gem install sass</p></blockquote><p>然后，就可以使用了。</p><h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><p>SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。</p><p>下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。）</p><blockquote><p>sass test.scss</p></blockquote><p>如果要将显示结果保存成文件，后面再跟一个.css文件名。</p><blockquote><p>sass test.scss test.css</p></blockquote><p>SASS提供四个<a href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#output_style">编译风格</a>的选项：</p><blockquote><ul><li><p>nested：嵌套缩进的css代码，它是默认值。</p></li><li><p>expanded：没有缩进的、扩展的css代码。</p></li><li><p>compact：简洁格式的css代码。</p></li><li><p>compressed：压缩后的css代码。</p></li></ul></blockquote><p>生产环境当中，一般使用最后一个选项。</p><blockquote><p>sass –style compressed test.sass test.css</p></blockquote><p>你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。</p><blockquote><p>// watch a file</p><p>sass –watch input.scss:output.css</p><p>// watch a directory</p><p>sass –watch app/sass:public/stylesheets</p></blockquote><p>SASS的官方网站，提供了一个<a href="http://sass-lang.com/try.html">在线转换器</a>。你可以在那里，试运行下面的各种例子。</p><h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><h3 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h3><p>SASS允许使用变量，所有变量以$开头。</p><blockquote><p>$blue : #1875e7;　</p><p>div {<br>    color : $blue;<br>}</p></blockquote><p>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。</p><blockquote><p>$side : left;</p><p>.rounded {<br>    border-#{$side}-radius: 5px;<br>}</p></blockquote><h3 id="2-2-计算功能"><a href="#2-2-计算功能" class="headerlink" title="2.2 计算功能"></a>2.2 计算功能</h3><p>SASS允许在代码中使用算式：</p><blockquote><p>body {<br>    margin: (14px/2);<br>　top: 50px + 100px;<br>　right: $var * 10%;<br>}</p></blockquote><h3 id="2-3-嵌套"><a href="#2-3-嵌套" class="headerlink" title="2.3 嵌套"></a>2.3 嵌套</h3><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p><blockquote><p>div h1 {<br>    color : red;<br>}</p></blockquote><p>可以写成：</p><blockquote><p>div {<br>　hi {<br>　　color:red;<br>　}<br>}</p></blockquote><p>属性也可以嵌套，比如border-color属性，可以写成：</p><blockquote><p>p {<br>　border: {<br>　　　color: red;<br>　}<br>}</p></blockquote><p>注意，border后面必须加上冒号。</p><p>在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成：</p><blockquote><p>a {<br>    &amp;:hover { color: #ffb3ff; }<br>}</p></blockquote><h3 id="2-4-注释"><a href="#2-4-注释" class="headerlink" title="2.4 注释"></a>2.4 注释</h3><p>SASS有两种注释风格。</p><p>标准的CSS注释 /* comment */ ，会保留到编译后的文件。</p><p>单行注释 // comment，只保留在SASS源文件中，编译后被省略。</p><p>在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可用于声明版权信息。</p><blockquote><p>/*!<br>    重要注释！<br>*/</p></blockquote><h2 id="三、代码的重用"><a href="#三、代码的重用" class="headerlink" title="三、代码的重用"></a>三、代码的重用</h2><h3 id="3-1-继承"><a href="#3-1-继承" class="headerlink" title="3.1 继承"></a>3.1 继承</h3><p>SASS允许一个选择器继承另一个选择器。比如，现有class1：</p><blockquote><p>.class1 {<br>    border: 1px solid #ddd;<br>}</p></blockquote><p>class2要继承class1，就要使用@extend命令：</p><blockquote><p>.class2 {<br>　@extend .class1;<br>　font-size:120%;<br>}</p></blockquote><h3 id="3-2-Mixin"><a href="#3-2-Mixin" class="headerlink" title="3.2 Mixin"></a>3.2 Mixin</h3><p>Mixin有点像C语言的宏（macro），是可以重用的代码块。</p><p>使用@mixin命令，定义一个代码块。</p><blockquote><p>@mixin left {<br>　float: left;<br>　margin-left: 10px;<br>}</p></blockquote><p>使用@include命令，调用这个mixin。</p><blockquote><p>div {<br>　@include left;<br>}</p></blockquote><p>mixin的强大之处，在于可以指定参数和缺省值。</p><blockquote><p>@mixin left($value: 10px) {<br>　float: left;<br>　margin-right: $value;<br>}</p></blockquote><p>使用的时候，根据需要加入参数：</p><blockquote><p>div {<br>    @include left(20px);<br>}</p></blockquote><p>下面是一个mixin的实例，用来生成浏览器前缀。</p><blockquote><p>@mixin rounded($vert, $horz, $radius: 10px) {<br>　border-#{$vert}-#{$horz}-radius: $radius;<br>　-moz-border-radius-#{$vert}#{$horz}: $radius;<br>　-webkit-border-#{$vert}-#{$horz}-radius: $radius;<br>}</p></blockquote><p>使用的时候，可以像下面这样调用：</p><blockquote><p>#navbar li { @include rounded(top, left); }</p><p>#footer { @include rounded(top, left, 5px); }</p></blockquote><h3 id="3-3-颜色函数"><a href="#3-3-颜色函数" class="headerlink" title="3.3 颜色函数"></a>3.3 颜色函数</h3><p>SASS提供了一些内置的颜色函数，以便生成系列颜色。</p><blockquote><p>lighten(#cc3, 10%) // #d6d65c<br>darken(#cc3, 10%) // #a3a329<br>grayscale(#cc3) // #808080<br>complement(#cc3) // #33c</p></blockquote><h3 id="3-4-插入文件"><a href="#3-4-插入文件" class="headerlink" title="3.4 插入文件"></a>3.4 插入文件</h3><p>@import命令，用来插入外部文件。</p><blockquote><p>@import “path/filename.scss”;</p></blockquote><p>如果插入的是.css文件，则等同于css的import命令。</p><blockquote><p>@import “foo.css”;</p></blockquote><p>四、高级用法</p><h3 id="4-1-条件语句"><a href="#4-1-条件语句" class="headerlink" title="4.1 条件语句"></a>4.1 条件语句</h3><p>@if可以用来判断：</p><blockquote><p>p {<br>　@if 1 + 1 == 2 { border: 1px solid; }<br>　@if 5 &lt; 3 { border: 2px dotted; }<br>}</p></blockquote><p>配套的还有@else命令：</p><blockquote><p>@if lightness($color) &gt; 30% {<br>　background-color: #000;<br>} @else {<br>　background-color: #fff;<br>}</p></blockquote><h3 id="4-2-循环语句"><a href="#4-2-循环语句" class="headerlink" title="4.2 循环语句"></a>4.2 循环语句</h3><p>支持for循环：</p><blockquote><p>@for $i from 1 to 10 {<br>　.border-#{$i} {<br>　　border: #{$i}px solid blue;<br>　}<br>}</p></blockquote><p>也支持while循环：</p><blockquote><p>$i: 6;</p><p>@while $i &gt; 0 {<br>　.item-#{$i} { width: 2em * $i; }<br>　$i: $i - 2;<br>}</p></blockquote><p>each命令，作用与for类似：</p><blockquote><p>@each $member in a, b, c, d {<br>　.#{$member} {<br>　　　background-image: url(“/image/#{$member}.jpg”);<br>　}<br>}</p></blockquote><h3 id="4-3-自定义函数"><a href="#4-3-自定义函数" class="headerlink" title="4.3 自定义函数"></a>4.3 自定义函数</h3><p>允许编写自己的函数。</p><blockquote><p>@function double($n) {<br>　@return $n * 2;<br>}</p><p>#sidebar {<br>　width: double(5px);<br>}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 继承汇总</title>
      <link href="/2023/10/23/19.js-ji-cheng/"/>
      <url>/2023/10/23/19.js-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// child name: son</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要是原型链中出现的原型，都可以说是该原型链派生的实例的原型。</p><p>这里存在两个缺点：</p><ol><li>子类型无法给超类型传递参数，在面向对象的继承中，我们总希望通过 var child = new Child(‘son’, ‘father’); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent(‘father’) 去调用父类。</li><li>Child.prototype.sayName 必须写在 Child.prototype = new Parent(‘father’); 之后，不然就会被覆盖掉。</li></ol><h2 id="二、类式继承"><a href="#二、类式继承" class="headerlink" title="二、类式继承"></a>二、类式继承</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>doSomthing <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent do something!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// child name: son</span>child<span class="token punctuation">.</span><span class="token function">doSomthing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// TypeError: child.doSomthing is not a function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相当于 Parent 这个函数在 Child 函数中执行了一遍，并且将所有与 this 绑定的变量都切换到了 Child 上，这样就克服了第一种方式带来的问题。</p><p>缺点：</p><ol><li>没有原型，每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。</li></ol><h2 id="三、组合式继承：结合前两种"><a href="#三、组合式继承：结合前两种" class="headerlink" title="三、组合式继承：结合前两种"></a>三、组合式继承：结合前两种</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>doSomething <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent do something!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// child name: son</span>child<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// parent do something!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p><p>这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p><p><strong>组合式继承是 JS 最常用的继承模式，但组合继承使用过程中会被调用两次：一次是创建子类型的时候，另一次是在子类型构造函数的内部。</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>doSomething <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent do something!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 第二次调用</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 第一次调用</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      child<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然从上述的代码中可以看出，第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了，所以这时候你可能会这样写：</p><pre class="line-numbers language-js"><code class="language-js">Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样写显然是不对的：</p><ol><li>首先，你这样写的话相当于是子类和父类都指向同一个对象，这时候如果你添加了新的方法给 Child 但实际上 Parent 并不需要，相当于强行给 Parent 添加了一个未知的方法。</li><li>其次，仔细想想，这样体现不出继承的多态性，比如此时子类想要重写父类的 getName 的方法，那么父类的方法也就会随之修改，这显然违背了多态性。</li></ol><p>也就是说我们第一次调用构造函数的时候，其实是不管构造函数里面的内容，所以我们何不 new 一个空函数，将其 prototype 指向 Parent.prototype，代码如下：</p><h2 id="四、寄生组合式继承"><a href="#四、寄生组合式继承" class="headerlink" title="四、寄生组合式继承"></a>四、寄生组合式继承</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> proto<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parent<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// parent name: father</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">,</span> <span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// child name: son</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是所谓的<strong>寄生组合式继承方式</strong>，跟组合式继承的区别在于，他不需要在一次实例中调用两次父类的构造函数，假如说父类的构造器代码很多，还需要调用两次的话对系统肯定会有影响，<strong>寄生组合式继承的思想在于：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</strong></p><p>在上面的代码中，我们手动创建了一个 create 函数，但是其实是存在于 Object 对象中，不需要我们手动去创建，所以上面的代码可以改为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Parent<span class="token punctuation">,</span> Child<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//修改</span>    Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Parent<span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>Child<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parent<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// parent name: father</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">,</span> <span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// child name: son</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、ES6-继承"><a href="#五、ES6-继承" class="headerlink" title="五、ES6 继承"></a>五、ES6 继承</h2><p>ES6 写继承就特别简单，如果你学过 Java 就会发现，ES6 中的继承跟 Java 太像了，上述的代码可改为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent do something!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parent name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> parentName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>parentName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'child name:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">'son'</span><span class="token punctuation">,</span> <span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// child name: son</span>child<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// parent do something!</span><span class="token keyword">const</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token string">'father'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>parent<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// parent name: father</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ES5 继承和 ES6 继承的区别</strong></p><p>es5 继承首先是在子类中创建自己的 this 指向，最后将方法添加到 this 中</p><p><code>Child.prototype=new Parent() || Parent.apply(this) || Parent.call(this)</code></p><p>es6 继承是使用关键字先创建父类的实例对象 this，最后在子类 class 中修改 this。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESLint 使用和配置</title>
      <link href="/2023/10/02/18.eslint/"/>
      <url>/2023/10/02/18.eslint/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>ESLint 是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免某些低级错误并统一代码风格。ESLint 被设计为完全可配置的，主要有两种方式：</p><ul><li>在注释中配置：使用 JavaScript 注释直接把配置嵌入到 JS 文件中。</li><li>配置文件：使用下面任一的文件来为全部的目录和它的子目录指定配置信息。<ul><li>javascript：使用<code>.eslintrc.js</code>文件并导出一个包含配置的对象。</li><li>YAML：<code>.eslintrc.yaml</code>或者<code>.eslintrc.yml</code></li><li>JSON：<code>.eslintrc.json</code>，并且此文件允许使用JS形式的注释</li><li>废弃的用法：<code>.eslintrc</code>，此文件可以是JSON或者YAML</li><li>package.json：在<code>package.json</code>文件中创建<code>eslintConfig</code>属性，所有的配置包含在此属性中。</li></ul></li></ul><p>这些文件的优先级则是按照以上出现的顺序（<code>.eslintrc.js</code> &gt; <code>.eslintrc.yaml</code> &gt; <code>.eslintrc.yml</code> &gt; <code>.eslintrc.json</code> &gt; <code>.eslintrc</code> &gt; <code>package.json</code>）。</p><p>可以被配置的信息主要分为3类：</p><ul><li>Environments：你的 javascript 脚步将要运行在什么环境下（如：nodejs，browser，commonjs 等）中。</li><li>Globals：执行代码时脚步需要访问的额外全局变量。</li><li>Rules：开启某些规则，也可以设置规则的等级。</li></ul><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><hr><ul><li>全局安装</li></ul><pre class="line-numbers language-undefined"><code class="language-undefined">npm i -g eslint<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>局部安装（推荐）</li></ul><pre class="line-numbers language-undefined"><code class="language-undefined">npm i -D eslint<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完毕后，接下来新建一个配置文件<code>.eslintrc.js</code>，或者使用如下的命令行来自动生成。</p><pre class="line-numbers language-kotlin"><code class="language-kotlin">eslint <span class="token operator">--</span><span class="token keyword">init</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><h3 id="3-1-指定执行环境"><a href="#3-1-指定执行环境" class="headerlink" title="3.1 指定执行环境"></a>3.1 指定执行环境</h3><p>JavaScript 代码可以运行在浏览器或 Node.js 等环境中，每个环境的全局变量都不尽相同（如 Node.js 中没有 DOM 相关的全局变量）。在配置文件中可以自由的指定执行环境。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// .eslintrc.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  env<span class="token operator">:</span> <span class="token punctuation">{</span>    browser<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    node<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所有的环境可在官网查询。</p><h3 id="3-2-指定全局变量"><a href="#3-2-指定全局变量" class="headerlink" title="3.2 指定全局变量"></a>3.2 指定全局变量</h3><p>可以在配置文件或注释中指定额外的全局变量，<code>false</code>表明变量只读：</p><ul><li>使用注释来配置：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">/* global var1, var2 *//* global var1:false, var2:false */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用配置文件来配置：</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// .eslintrc.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  globals<span class="token operator">:</span> <span class="token punctuation">{</span>    var1<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    var2<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-规则"><a href="#3-3-规则" class="headerlink" title="3.3 规则"></a>3.3 规则</h3><p>在配置文件中可以设置一些规则。</p><p>这些规则的等级有三种：</p><ul><li>“off” 或者 0：关闭规则。</li><li>“warn” 或者 1：打开规则，并且作为一个警告（不影响 exit code）。</li><li>“error” 或者 2：打开规则，并且作为一个错误（exit code 将会是1）。</li></ul><p>例如：</p><ul><li>使用配置文件来配置：</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// .eslintrc.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  rules<span class="token operator">:</span> <span class="token punctuation">{</span>    eqeqeq<span class="token operator">:</span> <span class="token string">'off'</span><span class="token punctuation">,</span>    curly<span class="token operator">:</span> <span class="token string">'error'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用注释来配置：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">/* eslint eqeqeq: <span class="token string">"off"</span>, curly: <span class="token string">"error"</span> *//* eslint eqeqeq: 0, curly: 2 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>具体的规则可以在官网上找到。</p><h2 id="四、使用方法"><a href="#四、使用方法" class="headerlink" title="四、使用方法"></a>四、使用方法</h2><h3 id="4-1-命令行"><a href="#4-1-命令行" class="headerlink" title="4.1 命令行"></a>4.1 命令行</h3><p>通过命令行使用 ESLint。</p><pre class="line-numbers language-css"><code class="language-css">eslint [options] file<span class="token number">.</span>js [file<span class="token number">.</span>js] [dir]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-编辑器"><a href="#4-2-编辑器" class="headerlink" title="4.2 编辑器"></a>4.2 编辑器</h3><p>使用 VSCode 配合相应的插件直接显示错误和警告。</p><p>除了上述，还可以配合 Gulp、Webpack 等工具使用。</p><h2 id="五、常见示例"><a href="#五、常见示例" class="headerlink" title="五、常见示例"></a>五、常见示例</h2><h3 id="5-1-一般示例"><a href="#5-1-一般示例" class="headerlink" title="5.1 一般示例"></a>5.1 一般示例</h3><p>在项目的根目录中添加文件 .prettierrc</p><pre><code>{ "semi": false, // 格式化消除所有分号  "singleQuote": true // 格式化字符串为单引号}</code></pre><p>找到 .eslintrc.js，在 rules 中</p><pre><code>rules: {  'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',  'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',  // fun () {} =&gt; fun() {}  'space-before-function-paren': 0 }</code></pre><h3 id="5-2-ESLint-忽略检查"><a href="#5-2-ESLint-忽略检查" class="headerlink" title="5.2 ESLint 忽略检查"></a>5.2 ESLint 忽略检查</h3><!-- eslint-disable --> 或 /* eslint-disable */ 后面的代码都不检查。<!-- eslint-disable --> … <!-- eslint-enable> 或 /* eslint-disable */ … /* eslint-enable */ 不检查某段代码。<p>eslint-disable-next-line：不检查下一行代码。</p><h3 id="5-3-其他配置规则"><a href="#5-3-其他配置规则" class="headerlink" title="5.3 其他配置规则"></a>5.3 其他配置规则</h3><ul><li><p><code>&quot;no-console&quot;:&quot;off&quot;</code> 禁用 console。</p></li><li><p><code>&quot;no-unused-vars&quot;:2</code> 禁止出现未使用过的变量。</p></li><li><p><code>&quot;no-use-before-define&quot;:2</code> 不允许在变量定义之前使用它们。</p></li><li><p><code>&quot;linebreak-style&quot;:[2, &quot;unix&quot;]</code> 强制使用一致的换行风格。</p></li><li><p><code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code> 强制使用一致的单引号。</p></li><li><p><code>&quot;semi&quot;:[&quot;error&quot;, &quot;always&quot;]</code> 控制行尾部分号。</p></li><li><p><code>&quot;curly&quot;:[&quot;error&quot;, &quot;all&quot;]</code> 强制所有控制语句使用一致的括号风格。</p></li><li><p><code>&quot;default-case&quot;: &quot;error&quot;</code> switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告。</p></li><li><p><code>&quot;no-else-return&quot;:&quot;error&quot;</code> 禁止 if 语句中有 return 之后有 else。</p></li><li><p><code>&quot;no-implicit-coercion&quot;: &quot;error&quot;</code> 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。</p></li><li><p><code>&quot;no-invalid-this&quot;: &quot;error&quot;</code> 禁止 this 关键字出现在类和类对象之外。</p></li><li><p><code>&quot;no-loop-func&quot;:&quot;error&quot;</code> 禁止在循环中出现 function 声明和表达式。</p></li><li><p><code>&quot;no-multi-spaces&quot;:&quot;error&quot;</code> 禁止使用多个空格。</p></li><li><p><code>&quot;no-new-func&quot;:&quot;error&quot;</code> 禁止对 空Function 对象使用 new 操作符。</p></li><li><p><code>&quot;no-useless-return&quot;:&quot;error&quot;</code> 禁止没有任何内容的return;</p></li><li><p><code>&quot;global-require&quot;: &quot;error&quot;</code> 要求 require() 出现在顶层模块作用域中。</p></li><li><p><code>&quot;no-path-concat&quot;: &quot;error&quot;</code> 禁止对 dirname 和 filename进行字符串连接</p></li><li><p><code>&quot;no-sync&quot;: &quot;error&quot;</code> 禁用同步方法。</p></li><li><p><code>&quot;array-bracket-spacing&quot;: [&quot;error&quot;, &quot;never&quot;]</code> 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格。</p></li><li><p><code>&quot;block-spacing&quot;: [&quot;error&quot;, &quot;always&quot;]</code> 禁止或强制在单行代码块中使用空格(禁用)。</p></li><li><p><code>&quot;brace-style&quot;: [&quot;error&quot;, &quot;1tbs&quot;]</code></p></li><li><p><code>&quot;camelcase&quot;: &quot;error&quot;</code> 强制驼峰法命名。</p></li><li><p><code>&quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always-multiline&quot;]</code> 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗,always-multiline：多行模式必须带逗号，单行模式不能带逗号号。</p></li><li><p><code>&quot;comma-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;]</code> 控制逗号前后的空格。</p></li><li><p><code>&quot;comma-style&quot;: [&quot;error&quot;, &quot;last&quot;]</code> 控制逗号在行尾出现还是在行首出现 (默认行尾)。</p></li><li><p><code>&quot;key-spacing&quot;: [&quot;error&quot;, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;]</code> 该规则规定了在对象字面量语法中，key和value之间的空白，冒号前不要空格，冒号后面需要一个空格。</p></li><li><p><code>&quot;lines-around-comment&quot;: [&quot;error&quot;, &#123; &quot;beforeBlockComment&quot;: true &#125;]</code> 要求在注释周围有空行 ( 要求在块级注释之前有一空行)。</p></li><li><p><code>&quot;newline-after-var&quot;: [&quot;error&quot;, &quot;always&quot;]</code> 要求或禁止 var 声明语句后有一行空行。</p></li><li><p><code>&quot;newline-before-return&quot;: &quot;error&quot;</code> 要求 return 语句之前有一空行。</p></li><li><p><code>&quot;no-multi-assign&quot;: &quot;error&quot;</code> 链接变量的赋值可能会导致意外的结果并难以阅读，不允许在单个语句中使用多个分配。</p></li><li><p><code>&quot;max-params&quot;: [1, 3] function</code> 定义中最多允许的参数数量。</p></li><li><p><code>&quot;new-cap&quot;: [&quot;error&quot;, &#123; &quot;newIsCap&quot;: true, &quot;capIsNew&quot;: false&#125;]</code> 构造函数首字母大写。</p></li><li><p><code>&quot;no-multiple-empty-lines&quot;: [&quot;error&quot;, &#123;&quot;max&quot;: 2&#125;]</code> 空行不能够超过2行。</p></li><li><p><code>&quot;no-shadow-restricted-names&quot;: &quot;error&quot;</code> 禁止对一些关键字或者保留字进行赋值操作，比如NaN、Infinity、undefined、eval、arguments等。</p></li><li><p><code>&quot;no-undef-init&quot;: &quot;error&quot;</code> 禁止把undefined赋值给一个变量。</p></li><li><p><code>&quot;keyword-spacing&quot;: &quot;error&quot;</code> keyword 前后需要空格。</p></li><li><p><code>&quot;space-before-blocks&quot;: [&quot;error&quot;,&quot;always&quot;]</code> 强制在块之前使用一致的空格。</p></li></ul>-->]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESLint </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用正则汇总</title>
      <link href="/2023/08/15/17.chang-yong-zheng-ze-hui-zong/"/>
      <url>/2023/08/15/17.chang-yong-zheng-ze-hui-zong/</url>
      
        <content type="html"><![CDATA[<h3 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h3><p>数字：^[0-9]*$</p><p>n位的数字：^d{n}$</p><p>至少n位的数字：^d{n,}$</p><p>m-n位的数字：^d{m,n}$</p><p>零和非零开头的数字：^(0|[1-9][0-9]*)$</p><p>非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$</p><p>7位整数5位小数：/^\d{0,7}(.\d{0,5})?$/</p><p>非零，7位整数5位小数：/^\d{1,7}(.\d{0,5})?$/</p><p>非负整数，最多8位：/^(0|+?[1-9][0-9]{0,7})$/</p><p>非负整数，最多6位：/^([1-9][0-9]{0,5}|0)$/</p><p>整数，最多4位：/^(-?[1-9][0-9]{0,3})$/</p><p>自然数，最多5位：/^(0|+?[1-9][0-9]{0,4})$/</p><p>非中文：/^[^\u4e00-\u9fa5]*$/</p><p>非0开头，最多6位的正整数：^[1-9][0-9]{0,5}$</p><p>带1-2位小数的正数或负数：^(-)?d+(.d{1,2})?$</p><p>正数、负数、和小数：^(-|+)?d+(.d+)?$</p><p>有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</p><p>有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</p><p>非零的正整数：^[1-9]d*$ 或 ^([1-9][0-9]<em>){1,3}$ 或 ^+?[1-9][0-9]</em>$</p><p>非零的负整数：^-[1-9][]0-9”<em>$ 或 ^-[1-9]d</em>$</p><p>非正整数：^-[1-9]d*|0$ 或 ^((-d+)|(0+))$</p><p>非负浮点数：^d+(.d+)?$ 或 ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$</p><p>非正浮点数：^((-d+(.d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$</p><p>正浮点数：^[1-9]d*.d*|0.d*[1-9]d*$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>))$</p><p>负浮点数：^-([1-9]d*.d*|0.d*[1-9]d*)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]</em>.[0-9]+)|([0-9]<em>[1-9][0-9]</em>)))$</p><p>浮点数：^(-?d+)(.d+)?$ 或 ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$</p><h3 id="二、校验字符的表达式"><a href="#二、校验字符的表达式" class="headerlink" title="二、校验字符的表达式"></a>二、校验字符的表达式</h3><p>汉字：^[u4e00-u9fa5]{0,}$</p><p>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</p><p>长度为3-20的所有字符：^.{3,20}$</p><p>由26个英文字母组成的字符串：^[A-Za-z]+$</p><p>由26个大写英文字母组成的字符串：^[A-Z]+$</p><p>由26个小写英文字母组成的字符串：^[a-z]+$</p><p>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</p><p>由数字、26个英文字母或者下划线组成的字符串：^w+$ 或 ^w{3,20}$</p><p>中文、英文、数字包括下划线：^[u4E00-u9FA5A-Za-z0-9_]+$</p><p>中文、英文、数字但不包括下划线等符号：^[u4E00-u9FA5A-Za-z0-9]+$ 或 ^[u4E00-u9FA5A-Za-z0-9]{2,20}$</p><p>可以输入含有^%&amp;’,;=?$”等字符：[^%&amp;’,;=?$x22]+</p><p>禁止输入含有<del>的字符：[^</del>x22]+</p><h3 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h3><p>Email地址：[a-zA-Z0-9]+([-_.][A-Za-zd]+)*@([a-zA-Z0-9]+[-.])+[A-Za-zd]{2,5}$</p><p>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</p><p>InternetURL：[a-zA-z]+://[^s]* 或 ^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$</p><p>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])d{8}$</p><p>通配电话：^\s***(?:+?(\d{1,3}))?[-. (]<em><strong>(\d{3})[-. )]</strong></em>(\d{3})[-. ]***(\d{4})(?: <em><strong>x(\d+))?\s</strong></em>$</p><p>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((d{3,4}-)|d{3.4}-)?d{7,8}$  </p><p>国内电话号码(0511-4405222、021-87888822)：d{3}-d{8}|d{4}-d{7}</p><p>身份证号(15位、18位数字)：^d{15}|d{18}$</p><p>短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</p><p>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</p><p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]w{5,17}$</p><p>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.<em>d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$  </p><p>日期格式：^d{4}-d{1,2}-d{1,2}</p><p>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</p><p>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$  </p><p>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+.[x|X][m|M][l|L]$</p><p>中文字符的正则表达式：[u4e00-u9fa5]</p><p>双字节字符：[^x00-xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</p><p>空白行的正则表达式： s* (可以用来删除空白行)</p><p>HTML标记的正则表达式：&lt;(S*?)[^&gt;]<em>&gt;.</em>?&lt;/1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</p><p>首尾空白字符的正则表达式：^s*|s*$或(^s*)|(s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</p><p>腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)</p><p>中国邮政编码：[1-9]d{5}(?!d) (中国邮政编码为6位数字)</p><p>端口号： /^([0-9]|[1-9]\d|[1-9]\d{2}|[1-9]\d{3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$/</p><p>IP地址：/^((25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d))).){3}(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))$/g</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 RGB 整理</title>
      <link href="/2023/08/14/16.chang-yong-rgb-zheng-li/"/>
      <url>/2023/08/14/16.chang-yong-rgb-zheng-li/</url>
      
        <content type="html"><![CDATA[<p>常用护眼色代码与RGB值</p><p>常见的一些保护眼睛的颜色（可根据喜好设置）：</p><table><thead><tr><th><strong>颜色</strong></th><th><strong>代码</strong></th><th><strong>RGB值</strong></th></tr></thead><tbody><tr><td>银河白</td><td>#FFFFFF</td><td>RGB(255, 255, 255)</td></tr><tr><td>杏仁黄</td><td>#FAF9DE</td><td>RGB(250,249,222)</td></tr><tr><td>秋叶褐</td><td>#FFF2E2</td><td>RGB(255,242,226)</td></tr><tr><td>胭脂红</td><td>#FDE6E0</td><td>RGB(253,230,224)</td></tr><tr><td>青草绿</td><td>#E3EDCD</td><td>RGB(227,237,205)</td></tr><tr><td>海天蓝</td><td>#DCE2F1</td><td>RGB(220,226,241)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九种跨域方式及其原理</title>
      <link href="/2023/06/26/15.kua-yu/"/>
      <url>/2023/06/26/15.kua-yu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h2><h3 id="1-1-什么是同源策略及其限制内容？"><a href="#1-1-什么是同源策略及其限制内容？" class="headerlink" title="1.1 什么是同源策略及其限制内容？"></a>1.1 什么是同源策略及其限制内容？</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><img src="1.1.png"></p><p><strong>同源策略限制内容有：</strong></p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求不能发送</li></ul><p>但是有<strong>三个标签是允许跨域加载资源</strong>：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><h3 id="1-2-常见的跨域场景"><a href="#1-2-常见的跨域场景" class="headerlink" title="1.2 常见的跨域场景"></a>1.2 常见的跨域场景</h3><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p><p><img src="1.2.png"></p><p>特别说明两点：</p><p><strong>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</strong></p><p><strong>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”</strong>。</p><p>这里你或许有个疑问：<strong>请求跨域了，那么请求到底发出去没有？</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="二、跨域解决方案"><a href="#二、跨域解决方案" class="headerlink" title="二、跨域解决方案"></a>二、跨域解决方案</h2><h3 id="2-1-jsonp"><a href="#2-1-jsonp" class="headerlink" title="2.1 jsonp"></a>2.1 jsonp</h3><p><strong>1) JSONP 原理</strong></p><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><p><strong>2) JSONP 和 AJAX 对比</strong></p><p>JSONP 和 AJAX 相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但 AJAX 属于同源策略，JSONP 属于非同源策略（跨域请求）</p><p><strong>3) JSONP 优缺点</strong></p><p>JSONP 优点是简单兼容性很好，可用于解决主流浏览器的跨域数据访问的问题。<strong>缺点是仅支持 get 方法非常具有局限性，一般用不上，不安全可能会遭受 XSS 攻击。</strong></p><p><strong>4) JSONP的实现流程</strong></p><ul><li>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个 <code>&lt;script&gt;</code> 标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li><li>服务器接收到请求后，需进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show('xxx')</code>。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ul><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己来封装一个 JSONP 函数。</p><p>省流：可以直接用封装好的 npm 包，然鹅大部分三方接口基本都不会采用 Get 方式，JSONP 的使用场景极低。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// index.html</span><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callback <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>    window<span class="token punctuation">[</span>callback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    params <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>params<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// wd=b&amp;callback=show</span>    <span class="token keyword">let</span> arrs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>      arrs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arrs<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  url<span class="token punctuation">:</span> <span class="token string">'http://localhost:3000/say'</span><span class="token punctuation">,</span>  params<span class="token punctuation">:</span> <span class="token punctuation">{</span> wd<span class="token punctuation">:</span> <span class="token string">'Iloveyou'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  callback<span class="token punctuation">:</span> <span class="token string">'show'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show('我xxx')</code>，最后会运行show()这个函数，打印出’xxx’</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// server.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/say'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> <span class="token punctuation">{</span> wd<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>query  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>wd<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Iloveyou</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// show</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">('我不爱你')`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5) jQuery 的 jsonp 形式</strong></p><p><strong>JSONP 都是 GET 和异步请求的，不存在其他的请求方式和同步请求，且 jQuery 默认就会给 JSONP 的请求清除缓存。</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>url<span class="token punctuation">:</span><span class="token string">"http://crossdomain.com/jsonServerResponse"</span><span class="token punctuation">,</span>dataType<span class="token punctuation">:</span><span class="token string">"jsonp"</span><span class="token punctuation">,</span>type<span class="token punctuation">:</span><span class="token string">"get"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//可以省略</span>jsonpCallback<span class="token punctuation">:</span><span class="token string">"show"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span>jsonp<span class="token punctuation">:</span><span class="token string">"callback"</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//->把传递函数名的那个形参callback，可省略</span>success<span class="token punctuation">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-CORS-跨域资源共享（W3C推荐）"><a href="#2-2-CORS-跨域资源共享（W3C推荐）" class="headerlink" title="2.2 CORS 跨域资源共享（W3C推荐）"></a>2.2 CORS 跨域资源共享（W3C推荐）</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><p><strong>1) 简单请求</strong></p><p>只要同时满足以下两大条件，就属于简单请求</p><p>条件1：使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>条件2：Content-Type 的值仅限于下列三者之一：</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><p><strong>2) 复杂请求</strong></p><p>不符合以上条件的请求就肯定是复杂请求了。<br>复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 允许哪个方法访问我</span>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 预检的存活时间</span>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Max-Age'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// OPTIONS请求不做任何处理</span><span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'OPTIONS'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义后台返回的内容</span>app<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// index.html</span><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">'name=xiamen'</span> <span class="token comment" spellcheck="true">// cookie不能跨域</span>xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 前端设置是否带cookie</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:4000/getData'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'xiamen'</span><span class="token punctuation">)</span>xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//得到响应头，后台需设置Access-Control-Expose-Headers</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span><span class="token function">getResponseHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//server1.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//server2.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> whitList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'http://localhost:3000'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//设置白名单</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> origin <span class="token operator">=</span> req<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>origin  <span class="token keyword">if</span> <span class="token punctuation">(</span>whitList<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置哪个源可以访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span> origin<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许携带哪个头访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许哪个方法访问我</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许携带cookie</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Credentials'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 预检的存活时间</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Max-Age'</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 允许返回的头</span>    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Expose-Headers'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method <span class="token operator">===</span> <span class="token string">'OPTIONS'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// OPTIONS请求不做任何处理</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'jw'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回一个响应头，后台需设置</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/getData'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">)</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'我不爱你'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p><h3 id="2-3-postMessage"><a href="#2-3-postMessage" class="headerlink" title="2.3 postMessage"></a>2.3 postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p><p><code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。</p><pre class="line-numbers language-html"><code class="language-html">// a.html  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://localhost:4000/b.html<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>frame<span class="token punctuation">"</span></span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>load()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span> //等它加载完触发一个事件  //内嵌在http://localhost:3000/a.html    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">      <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> frame <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'frame'</span><span class="token punctuation">)</span>        frame<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'我爱你'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:4000'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//发送数据</span>        window<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//接受返回数据</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//我不爱你</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>// b.html  window.onmessage = function(e) {    console.log(e.data) //我爱你    e.source.postMessage('我不爱你', e.origin) }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-websocket"><a href="#2-4-websocket" class="headerlink" title="2.4 websocket"></a>2.4 websocket</h3><p>WebSocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生 WebSocket API 使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了 WebSocket 接口，提供了更简单、灵活的接口，也对不支持 WebSocket 的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件 socket.html 向<code>localhost:3000</code>发生数据和接受数据：</p><pre class="line-numbers language-html"><code class="language-html">// socket.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">let</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'ws://localhost:3000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    socket<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      socket<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'hellow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 向服务器发送数据</span>    <span class="token punctuation">}</span>    socket<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 接收服务器返回的数据</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>// server.jslet express = require('express');let app = express();let WebSocket = require('ws'); // 记得安装wslet wss = new WebSocket.Server({port:3000});wss.on('connection',function(ws) {  ws.on('message', function (data) {    console.log(data);    ws.send('hi')  });})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-node中间件代理-两次跨域"><a href="#2-5-node中间件代理-两次跨域" class="headerlink" title="2.5 node中间件代理 (两次跨域)"></a>2.5 node中间件代理 (两次跨域)</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong><br>代理服务器，需要做以下几个步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li><li>将 响应 转发给客户端。</li></ul><p><img src="2.5.png"></p><p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p><pre class="line-numbers language-html"><code class="language-html">// index.html(http://127.0.0.1:5500) <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">      $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        url<span class="token punctuation">:</span> <span class="token string">'http://localhost:3000'</span><span class="token punctuation">,</span>        type<span class="token punctuation">:</span> <span class="token string">'post'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'xiamen'</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'123456'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        contentType<span class="token punctuation">:</span> <span class="token string">'application/json;charset=utf-8'</span><span class="token punctuation">,</span>        success<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {"title":"fontend","password":"123456"}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        error<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) => {  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段  response.writeHead(200, {    'Access-Control-Allow-Origin': '*',    'Access-Control-Allow-Methods': '*',    'Access-Control-Allow-Headers': 'Content-Type'  })  // 第二步：将请求转发给服务器  const proxyRequest = http    .request(      {        host: '127.0.0.1',        port: 4000,        url: '/',        method: request.method,        headers: request.headers      },      serverResponse => {        // 第三步：收到服务器的响应        var body = ''        serverResponse.on('data', chunk => {          body += chunk        })        serverResponse.on('end', () => {          console.log('The data is ' + body)          // 第四步：将响应结果转发给浏览器          response.end(body)        })      }    )    .end()})server.listen(3000, () => {  console.log('The proxyServer is running at http://localhost:3000')})// server2.js(http://localhost:4000)const http = require('http')const data = { title: 'fontend', password: '123456' }const server = http.createServer((request, response) => {  if (request.url === '/') {    response.end(JSON.stringify(data))  }})server.listen(4000, () => {  console.log('The server is running at http://localhost:4000')})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>{"title":"fontend","password":"123456"}</code></p><h3 id="2-6-nginx-反向代理"><a href="#2-6-nginx-反向代理" class="headerlink" title="2.6 nginx 反向代理"></a>2.6 nginx 反向代理</h3><p>实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。</p><p>使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。</p><p>先下载 <a href="http://nginx.org/en/download.html">nginx</a>，然后将 nginx 目录下的 nginx.conf 修改如下:</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// proxy服务器</span>server <span class="token punctuation">{</span>    listen       <span class="token number">81</span><span class="token punctuation">;</span>    server_name  www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>    location <span class="token operator">/</span> <span class="token punctuation">{</span>        proxy_pass   http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com<span class="token punctuation">:</span><span class="token number">8080</span><span class="token punctuation">;</span>  #反向代理        proxy_cookie_domain www<span class="token punctuation">.</span>domain2<span class="token punctuation">.</span>com www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span> #修改cookie里域名        index  index<span class="token punctuation">.</span>html index<span class="token punctuation">.</span>htm<span class="token punctuation">;</span>        # 当用webpack<span class="token operator">-</span>dev<span class="token operator">-</span>server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>domain1<span class="token punctuation">.</span>com<span class="token punctuation">;</span>  #当前端只跨域不带cookie时，可为<span class="token operator">*</span>        add_header Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后通过命令行<code>nginx -s reload</code>启动nginx</p><pre class="line-numbers language-html"><code class="language-html">// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send();// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) {    var params = qs.parse(req.url.substring(2));    // 向前台写cookie    res.writeHead(200, {        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取    });    res.write(JSON.stringify(params));    res.end();});server.listen('8080');console.log('Server is running at port 8080...');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-window-name-iframe"><a href="#2-7-window-name-iframe" class="headerlink" title="2.7 window.name + iframe"></a>2.7 window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><pre class="line-numbers language-html"><code class="language-html"> // a.html(http://localhost:3000/b.html)  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://localhost:4000/c.html<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>load()<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>iframe<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token comment" spellcheck="true">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span>    <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 第1次onload(跨域页)成功后，切换到同域代理页面</span>        <span class="token keyword">let</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/b.html'</span><span class="token punctuation">;</span>        first <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b.html为中间代理页，与a.html同域，内容为空。</p><pre class="line-numbers language-html"><code class="language-html"> // c.html(http://localhost:4000/c.html)  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    window<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'我不爱你'</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="2-8-location-hash-iframe"><a href="#2-8-location-hash-iframe" class="headerlink" title="2.8 location.hash + iframe"></a>2.8 location.hash + iframe</h3><p>实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用 iframe的 location.hash 传值，相同域之间直接 js 访问来通信。</p><p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。<br>同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><pre class="line-numbers language-html"><code class="language-html"> // a.html  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://localhost:4000/c.html#iloveyou<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    window<span class="token punctuation">.</span>onhashchange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//检测hash的变化</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span> // b.html  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash     <span class="token comment" spellcheck="true">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span> // c.html console.log(location.hash);  let iframe = document.createElement('iframe');  iframe.src = 'http://localhost:3000/b.html#idontloveyou';  document.body.appendChild(iframe);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-9-document-domain-iframe"><a href="#2-9-document-domain-iframe" class="headerlink" title="2.9 document.domain + iframe"></a>2.9 document.domain + iframe</h3><p><strong>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式</strong>。<br>只需要给页面添加 <code>document.domain ='test.com'</code> 表示二级域名都相同就可以实现跨域。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p><pre class="line-numbers language-html"><code class="language-html">// a.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span> helloa  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://b.zf1.cn:3000/b.html<span class="token punctuation">"</span></span> <span class="token attr-name">frameborder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>load()<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>frame<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'zf1.cn'</span>    <span class="token keyword">function</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>frame<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>// b.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>   hellob   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">     document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'zf1.cn'</span>     <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><ul><li>CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案。</li><li>JSONP 只支持 GET 请求，JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</li><li>不管是 Node 中间件代理还是 Nginx 反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是 CORS 和 Nginx 反向代理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 协议相关</title>
      <link href="/2023/04/22/13.http-xie-yi/"/>
      <url>/2023/04/22/13.http-xie-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、请求报文和响应报文"><a href="#一、请求报文和响应报文" class="headerlink" title="一、请求报文和响应报文"></a>一、请求报文和响应报文</h2><p>http请求报文组成: 请求行+请求头+请求体</p><p>http响应报文组成: 响应行+响应头+响应体</p><p>请求行: 请求方法(HEAD/GET/POST) + 请求URL + HTTP协议版本</p><p>响应行: HTTP协议版本 + 状态码 + 状态码描述</p><p>请求头: 比如客户端的Cookie和User-Agent就放在这里</p><p>响应头: 比如服务器的Set-Cookie和Server信息就放在这里</p><p>请求体: 比如客户端POST的数据就放在这里(对比:GET的数据放在请求行的URL里)</p><p>响应体: 比如服务器返回的HTML和JSON数据就放在这里</p><h2 id="二、输入地址到展示过程"><a href="#二、输入地址到展示过程" class="headerlink" title="二、输入地址到展示过程"></a>二、输入地址到展示过程</h2><p>（1）浏览器输入url,先解析url地址是否合法</p><p>（2）浏览器检查是否有缓存(浏览器缓存-系统缓存-路由器缓存)如果有,直接显示.如果没有,跳到第三步</p><p>（3）在发送http请求前,需要域名解析(DNS解析),解析获取对应过的ip地址</p><p>（4）浏览器向服务器发起tcp链接,与浏览器简历tcp三次握手</p><p>（5）握手成功后,浏览器向服务器发送http请求,请求数据包</p><p>（6）服务器收到处理的请求,将数据返回至浏览器</p><p>（7）浏览器收到http响应</p><p>（8）浏览器解析响应.如果响应可以缓存,则存入缓存</p><p>（9）浏览器发送请求获取嵌入在HTML中的资源(html,css,JavaScript,图片,音乐等),对于未知类型,会弹出对话框</p><p>（10）浏览器发送异步请求</p><p>（11）页面全部渲染结束</p><h2 id="三、HTTP-请求方式-类型"><a href="#三、HTTP-请求方式-类型" class="headerlink" title="三、HTTP 请求方式/类型"></a>三、HTTP 请求方式/类型</h2><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">GET</td><td align="left">请求指定的页面信息，并返回实体主体。向服务器读取数据，数据暴露在url中。</td></tr><tr><td align="left">2</td><td align="left">HEAD</td><td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="left">3</td><td align="left">POST</td><td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td align="left">4</td><td align="left">PUT</td><td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="left">5</td><td align="left">DELETE</td><td align="left">请求服务器删除指定的页面。</td></tr><tr><td align="left">6</td><td align="left">CONNECT</td><td align="left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="left">7</td><td align="left">OPTIONS</td><td align="left">允许客户端查看服务器的性能。</td></tr><tr><td align="left">8</td><td align="left">TRACE</td><td align="left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="left">9</td><td align="left">PATCH</td><td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><h2 id="四、HTTP-状态码"><a href="#四、HTTP-状态码" class="headerlink" title="四、HTTP 状态码"></a>四、HTTP 状态码</h2><p>下面是常见的HTTP状态码：</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><p>HTTP状态码共分为5种类型：</p><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h2 id="五、HTTPS-和-SSL-加密"><a href="#五、HTTPS-和-SSL-加密" class="headerlink" title="五、HTTPS 和 SSL 加密"></a>五、HTTPS 和 SSL 加密</h2><p>（1）http是直接和tcp通信,https=http+ssl加密</p><p>（2）https有ca证书,http一般没有</p><p>（3）http默认端口号为80,https默认端口号为443</p><p>（4）https基于传输层,http基于应用层</p><p>（5）https对于搜索引擎更友好,利于seo,百度,谷歌等搜索引擎优先索引https网页</p><p>ssl加密: 发送密文的一方使用对方的公钥进行加密处理”对称的密钥”,然后对方用自己的私钥解密拿到”对称的密钥”,这样可以确保交换的密钥是安全的前提下,使用对称加密方式进行通信。</p><p>所以,https采用对称加密和非对称加密两者并用的混合加密机制。</p><h2 id="六、cookie-和-session"><a href="#六、cookie-和-session" class="headerlink" title="六、cookie 和 session"></a>六、cookie 和 session</h2><ol><li>cookies数据保存在客户端,session数据保存在服务端</li><li>cookie可以减轻服务器压力但不是很安全,别人可以进行cookie欺骗,考虑到安全应当使用session</li><li>session会在一定时间内保存在服务器上,当访问增多,会比较占用你服务器的性能,考虑到减轻服务器性能方面,应当使用cookie</li><li>单个的cookie保存的数据不能超过4K,很多浏览器都限制一个站点最多保存20个cookie</li><li>所以个人建议: </li></ol><p>将登陆信息等重要信息存放为session;其他信息如果需要保留,可以放在cookie中</p><p>通过Web Server或者浏览器来获取Cookie.多数浏览器能够配置允许用户访问Cookies,但是不同站点之间的Cookie不能共享</p><p>cookie有一个属性expires,设置其值为一个时间,那么当到达此时间后,此cookie失效.通过Okhttp的拦截器去进行持久化cookie</p><h2 id="七、HTTP-缓存机制"><a href="#七、HTTP-缓存机制" class="headerlink" title="七、HTTP 缓存机制"></a>七、HTTP 缓存机制</h2><pre><code>http缓存主要分为两种: 强缓存和协商缓存    a. 强缓存基本原理是: 所请求的数据在缓存数据库中尚未过期时,不与服务器进行交互,直接使用缓存数据库中的数据.    Expire指定了一个日期/时间,在这个日期/时间之后,http响应被认为是过时的.但是它本身是一个HTTP1.0标准下的字段,所以如果请求中还有一个置了"max-age"或者"s-max-age"指令的Cache-Control响应头,那么Expires 头就会被忽略.    Cache-Control通用消息头用于在http请求和响应中通过指定指令来实现缓存机制,其常用的几个取值有：    private: 客户端可以缓存    public: 客户端和代理服务器都可以缓存    max-age=xxx: 缓存的内容将在xxx 秒后失效    s-max-age=xxx: 同s-max-age,但仅适用于共享缓存(比如各个代理),并且私有缓存中忽略    no-cache: 需要使用协商缓存来验证缓存数据    no-store: 所有内容都不会缓存,强缓存和协商缓存都不会触发    must-revalidate: 缓存必须在使用之前验证旧资源的状态,并且不可使用过期资源    b. 当强缓存过期未命中或者响应报文Cache-Control中有must-revalidate标识必须每次请求验证资源的状态时,便使用协商缓存的方式去处理缓存文件    协商缓存主要原理是从缓存数据库中取出缓存的标识,然后向浏览器发送请求验证请求的数据是否已经更新,如果已更新则返回新的数据,若未更新则使用缓存数据库中的缓存数据</code></pre><h2 id="八、正-反向代理、中间人攻击"><a href="#八、正-反向代理、中间人攻击" class="headerlink" title="八、正/反向代理、中间人攻击"></a>八、正/反向代理、中间人攻击</h2><p><img src="8.png"></p><p>正向代理即是客户端代理,代理客户端,服务端不知道实际发起请求的客户端</p><p>反向代理即是服务端代理,代理服务端,客户端不知道实际提供服务的服务端</p><p>正向代理的用途:</p><p>（1）访问原来无法访问的资源,如google</p><p>（2）可以做缓存,加速访问资源</p><p>（3）对客户端访问授权,上网进行认证</p><p>（4）代理可以记录用户访问记录(上网行为管理),对外隐藏用户信息</p><p>反向代理的作用：</p><p>（1）保证内网的安全,阻止web攻击,大型网站,通常将反向代理作为公网访问地址,Web服务器是内网</p><p>（2）负载均衡,通过反向代理服务器来优化网站的负载</p><p>中间人攻击：</p><p>中间人攻击(Man-in-the-Middle Attack, MITM)是一种由来已久的网络入侵手段,并且当今仍然有着广泛的发展空间,如SMB会话劫持,DNS欺骗等攻击都是典型的MITM攻击.简而言之,所谓的MITM攻击就是通过拦截正常的网络通信数据,并进行数据篡改和嗅探,而通信的双方却毫不知情。</p><h2 id="九、３次握手与４次挥手"><a href="#九、３次握手与４次挥手" class="headerlink" title="九、３次握手与４次挥手"></a>九、３次握手与４次挥手</h2><p><img src="9.png"></p><blockquote><p>3次握手,保障通讯双方有通信的基础;4次挥手,保障通讯双方可以安全的回收TCP通信的系统资源.HTTP是基于TCP的协议,TCP是可靠的传输层协议</p></blockquote><p>具体内容:</p><p>三次握手: 是指在建立TCP连接协议时,需要在客户端和服务器之间发三个包,传送的包里不含数据,握手完毕后客户端和服务器才开始正式传送数据</p><p>第一次握手: 客户端发第一个包,SYN标志位为1,ACK=0,发送顺序号Seq=X(随机int).客户端进入SYN发送状态,等待服务器确认</p><p>第二次握手: 服务器收到包后发第二个包,包的SYN,ACK标志位=1,发送顺序号Seq=Y(随机int),接收顺序号ACK=X+1,此时服务器进入SYN接收状态</p><p>第三次握手: 客户端收到包后发第三个,SYN=0,ACK=1,接收顺序号ACK=Y+1,发送顺序号seq=X+1.客户端和服务器进入ESTABLISHED建立成功状态,完成三次握手</p><p>四次挥手: 是指终止TCP连接协议时,需要在客户端和服务器之间发送四个包</p><p>第一次挥手: 主动关闭方发送第一个包,其中FIN标志位为1,发送顺序号Seq=X</p><p>第二次挥手: 被动关闭方收到FIN包后发送第二个包,其中发送顺序号Seq=Z,接收顺序号ACK=X+1</p><p>第三次挥手: 被动关闭方再发送第三个包,其中FIN标志位为1,发送顺序号Seq=Y,接收顺序号ACK=X</p><p>第四次挥手: 主动关闭方发送第四个包,其中发送顺序号Seq=X,接收顺序号ACK=Y,完成四次挥手</p><blockquote><p>TCP为什么是三次握手,而不是两次或四次?</p></blockquote><p>TCP既要保证数据可靠传输,又要提高传输的效率,两次握手容易死锁,四次又浪费资源</p><p>TCP需要seq序列号做可靠重传或接收,防止连接复用时无法分辨seq是延迟的还是旧链接的,因此需要三次握手来确定双方的ISN(初始seq序列号）</p><p>比如一个seq过来了,跟现在记住的seq不一样,我不知道它是上条延迟的,还是上上条延迟的,所以接收方一定需要跟发送方确认SYN</p><blockquote><p>为什么建立连接协议是三次握手,而关闭连接却是四次握手呢?</p></blockquote><p>建立TCP连接时,ACK和SYN可以放在一个报文里发送.而关闭连接时,被动关闭方可能还需要发送一些数据后再发送FIN报文表示同意现在可以关闭连接了,所以它这里的ACK报文和FIN报文多数情况下都是分开发送的</p><blockquote><p>为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态?</p></blockquote><p>无法保证最后发送的ACK报文会一定被对方收到,所以需要重发可能丢失的ACK报文<br>关闭连接后可能在相同的IP地址和端口建立新连接,为了防止旧连接的重复分组在新连接再现,2MSL足以让分组最多存活2msl秒被丢弃</p><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><p><strong>URI和URL</strong></p><p>URI是统一资源标识符,而URL是统一资源定位符.每个URL都是URI,但不一定每个URI都是URL.这是因为URI还包括一个子类,即统一资源名称(URN),它命名资源但不指定如何定位资源</p><p><strong>TCP和UDP</strong></p><p>（1）TCP是面向连接的(在客户端和服务器之间传输数据之前要先建立连接),UDP是无连接的(发送数据之前不需要先建立连接)</p><p>（2）TCP提供可靠的服务(通过TCP传输的数据,无差错,不丢失,不重复,且按序到达);UDP提供面向事务的简单的不可靠的传输</p><p>（3）UDP具有较好的实时性,工作效率比TCP高,适用于对高速传输和实时性比较高的通讯或广播通信.随着网速的提高,UDP使用越来越多</p><p>（4）每一条TCP连接只能是点到点的,UDP支持一对一,一对多和多对多的交互通信</p><p>（5）TCP对系统资源要求比较多,UDP对系统资源要求比较少</p><p>（6）UDP程序结构更加简单</p><p>（7）TCP是流模式,UDP是数据报模式</p><p><strong>请求头内容</strong></p><p>1）Accept 作用: 浏览器端可以接受的媒体类型 例: Accept: text/html </p><p>2）Accept-Encoding 作用: 浏览器申明自己接收的编码方法,通常指定压缩方法,是否支持压缩,支持什么压缩方法(gzip,deflate)</p><p>3）Accept-Language 作用: 浏览器申明自己接收的语言.例: Accept-Language: en-us</p><p>4）Connection 例如: Connection: keep-alive 当一个网页打开完成后,客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭,如果客户端再次访问这个服务器上的网页,会继续使用这一条已经建立的连接</p><p>5）Host(发送请求时,该报头域是必需的) 作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号,它通常从HTTP URL中提取出来的</p><p>6）Referer 作用: 当浏览器向web服务器发送请求的时候,一般会带上Referer,告诉服务器我是从哪个页面链接过来的</p><p>7）User-Agent 作用: 告诉HTTP服务器,客户端使用的操作系统和浏览器的名称和版本</p><p><strong>浏览器f5和强制刷新ctrl+f5</strong></p><ol><li>F5使用缓存,并且只有在资源内容发生变化的时候才会去更新资源.</li></ol><p>当刷新一个页面的时,浏览器会尝试使用各种类型的缓存,并发送If-Modified-Since头到服务器,如果服务器返回304 Not Modified,那么浏览器会使用本地的缓存;如果服务器返回200 OK和资源内容,那么浏览器会使用返回的资源内容,并把资源内容进行缓存,待下次使用.</p><ol start="2"><li>CTRL-F5 强制更新页面资源的缓存</li></ol><p>MSIE会发送Cache-Control: no-cache头,Firefox和Chrome除了发送Cache-Control: no-cache头之外,还会发送Pragma: no-cache头.Opera比较另类,不发送任何和缓存相关的头</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 初步了解</title>
      <link href="/2023/04/10/12.webpack/"/>
      <url>/2023/04/10/12.webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Webpack 是一种前端资源构建工具，一个静态模块打包器。当 Webpack 处理应用程序时，前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理，它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源。</p><p><img src="1.jpg"></p><h2 id="二、Webpack-五个核心概念"><a href="#二、Webpack-五个核心概念" class="headerlink" title="二、Webpack 五个核心概念"></a>二、Webpack 五个核心概念</h2><h3 id="2-1-Entry"><a href="#2-1-Entry" class="headerlink" title="2.1 Entry"></a>2.1 Entry</h3><p>入口(Entry)指示Webpack以哪个文件作为入口起点分析构建内部依赖图并进行打包。</p><h3 id="2-2-Output"><a href="#2-2-Output" class="headerlink" title="2.2 Output"></a>2.2 Output</h3><p>输出(Output)指示Webpack打包后的资源bundles输出到哪里去，以及如何命名。</p><h3 id="2-3-Loader"><a href="#2-3-Loader" class="headerlink" title="2.3 Loader"></a>2.3 Loader</h3><p>Loader让Webpack能够去处理那些非JavaScript语言的文件，Webpack本身只能理解JavaScript。</p><h3 id="2-4-Plugin"><a href="#2-4-Plugin" class="headerlink" title="2.4 Plugin"></a>2.4 Plugin</h3><p>插件(Plugins)可以用于执行范围更广的任务，插件的范围包括从打包和压缩，一直到重新定义环境中的变量等。</p><h3 id="2-5-Mode"><a href="#2-5-Mode" class="headerlink" title="2.5 Mode"></a>2.5 Mode</h3><p>模式(Mode)指示Webpack使用相应模式的配置。分为development和production两种模式，下面分别进行简述。</p><ul><li><strong>development:</strong> 开发模式，能让代码本地运行的环境，会将process.env.NODE_ENV的值设为development，同时启用NamedChunksPlugin和NamedModulesPlugin插件；</li><li><strong>production:</strong> 生产模式，能让代码优化运行的环境，会将process.env.NODE_ENV的值设为production，同时启用FlagDependencyUsagePlugin、FlagIncludedChunksPlugin、ModuleConcatenationPlugin、NoEmitreplaceStringsPlugin、OccurrenceOrderPlugin、SideEffectsFlagPlugin和UglifyJsPlugin插件。</li></ul><h2 id="三、Webpack-配置"><a href="#三、Webpack-配置" class="headerlink" title="三、Webpack 配置"></a>三、Webpack 配置</h2><h3 id="3-1-webpack-config-js-文件"><a href="#3-1-webpack-config-js-文件" class="headerlink" title="3.1 webpack.config.js 文件"></a>3.1 webpack.config.js 文件</h3><p>webpack.config.js是webpack的配置文件，用来指示webpack工作，运行webpack指令时，会加载里面的配置，所有构建工具都是基于nodejs平台运行的，默认采用commonjs模块化。</p><p><img src="3.1.jpg"></p><h3 id="3-2-devServer-配置"><a href="#3-2-devServer-配置" class="headerlink" title="3.2 devServer 配置"></a>3.2 devServer 配置</h3><p>开发服务器(devServer)用来实现自动化(自动编译、自动打开浏览器、自动刷新浏览器)，只会在内存中编译打包，不会有任何文件输出，本地安装webpack-dev-server后，通过npx webpack-dev-server命令启动devServer。</p><p><img src="3.2.jpg"></p><h3 id="3-3-打包-html-样式-图片-其它资源"><a href="#3-3-打包-html-样式-图片-其它资源" class="headerlink" title="3.3 打包 html/样式/图片/其它资源"></a>3.3 打包 html/样式/图片/其它资源</h3><p>打包不同的资源会使用不同的loader和插件，打包html/样式/图片/其它资源的流程如下所述。</p><h4 id="3-3-1-打包-html-资源"><a href="#3-3-1-打包-html-资源" class="headerlink" title="3.3.1 打包 html 资源"></a>3.3.1 打包 html 资源</h4><p>1.下载html-webpack-plugin插件；</p><p>2.引入html-webpack-plugin插件；</p><p>3.使用html-webpack-plugin插件，并进行相应配置。</p><h4 id="3-3-2-打包样式资源"><a href="#3-3-2-打包样式资源" class="headerlink" title="3.3.2 打包样式资源"></a>3.3.2 打包样式资源</h4><p>不同的样式文件需要配置不同的loader</p><p>1.下载loader；</p><p>2.配置loader，css样式文件使用css-loader和style-loader，less文件使用less-loader、css-loader和style-loader。其中css-loader的作用是将css文件变成commonjs模块加载到js文件中，style-loader的作用是创建style标签，将js中的样式资源插入进去，添加到head中生效。</p><h4 id="3-3-3-打包图片资源"><a href="#3-3-3-打包图片资源" class="headerlink" title="3.3.3 打包图片资源"></a>3.3.3 打包图片资源</h4><p>1.下载url-loader，file-loader</p><p>2.配置loader</p><h4 id="3-3-4-打包其它资源"><a href="#3-3-4-打包其它资源" class="headerlink" title="3.3.4 打包其它资源"></a>3.3.4 打包其它资源</h4><ol><li><p>下载file-loader</p></li><li><p>配置loader，配置该loader作用于不为html/css/less/js的其他文件</p></li></ol><h3 id="3-4-提取css成单独文件-css兼容性处理-压缩css"><a href="#3-4-提取css成单独文件-css兼容性处理-压缩css" class="headerlink" title="3.4 提取css成单独文件/css兼容性处理/压缩css"></a>3.4 提取css成单独文件/css兼容性处理/压缩css</h3><h4 id="3-4-1-提取-css-成单独文件"><a href="#3-4-1-提取-css-成单独文件" class="headerlink" title="3.4.1 提取 css 成单独文件"></a>3.4.1 提取 css 成单独文件</h4><p>样式文件打包后会默认和js文件一起输出，可以通过插件将打包后的css文件单独输出，流程如下所述。</p><p>1.下载mini-css-extract-plugin插件</p><p>2.引用该插件</p><p>3.配置</p><h4 id="3-4-2-css-兼容性处理"><a href="#3-4-2-css-兼容性处理" class="headerlink" title="3.4.2 css 兼容性处理"></a>3.4.2 css 兼容性处理</h4><p>1.下载postcss-loader和postcss-preset-env</p><p>2.在package.json中browsetslist属性中分别对开发环境和生产环境进行兼容性配置，设置支持样式的浏览器版本</p><p>3.通过postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式。</p><h4 id="3-4-3-压缩-css"><a href="#3-4-3-压缩-css" class="headerlink" title="3.4.3 压缩 css"></a>3.4.3 压缩 css</h4><p>1.下载optimize-css-assets-webpack-plugin插件</p><p>2.引用该插件</p><p>3.使用该插件</p><h3 id="3-5-js语法检查eslint-js兼容性处理-js压缩"><a href="#3-5-js语法检查eslint-js兼容性处理-js压缩" class="headerlink" title="3.5 js语法检查eslint/js兼容性处理/js压缩"></a>3.5 js语法检查eslint/js兼容性处理/js压缩</h3><h4 id="3-5-1-js-语法检查-eslint"><a href="#3-5-1-js-语法检查-eslint" class="headerlink" title="3.5.1 js 语法检查 eslint"></a>3.5.1 js 语法检查 eslint</h4><p>1.下载eslint-loader和eslint</p><p>2.在package.json中的eslintConfig中进行配置</p><p>3.配置eslint-loader，其中只需检测js文件并要排除第三方库，只检测自己写的源代码，同时可在options配置中设置fix:true，自动修复eslint的错误。</p><h4 id="3-5-2-js-兼容性处理"><a href="#3-5-2-js-兼容性处理" class="headerlink" title="3.5.2 js 兼容性处理"></a>3.5.2 js 兼容性处理</h4><ol><li><p>下载babel-loader、@babel/core、@babel/preset-env，通过@babel/preset-env做基本的js兼容性处理，然后通过corejs做前面无法实现的兼容性处理，并实现按需加载</p></li><li><p>配置loader</p></li></ol><p><img src="3.5.2.jpg"></p><h4 id="3-5-3-js-压缩"><a href="#3-5-3-js-压缩" class="headerlink" title="3.5.3 js 压缩"></a>3.5.3 js 压缩</h4><p>mode设置为production生产环境时会自动压缩js代码。</p><h2 id="四、webpack-性能优化"><a href="#四、webpack-性能优化" class="headerlink" title="四、webpack 性能优化"></a>四、webpack 性能优化</h2><p>可以从开发环境和生产环境分别对webpack进行性能优化。开发环境主要考虑从打包构建速度和代码调试两个方面进行优化，生产环境主要考虑从打包构建速度和代码运行性能两个方面进行优化。下面简单介绍下开发环境上通过HMR提升构建速度。</p><h3 id="4-1-HMR"><a href="#4-1-HMR" class="headerlink" title="4.1 HMR"></a>4.1 HMR</h3><p>HMR(热模块替换)，作用是一个模块发生变化后，只会更新打包这一个模块而不是所有模块，通过在devServer中设置hot:true属性启动HMR功能。</p><p>对于样式文件，可用HMR功能，因为style-loader内部实现了；</p><p>对于js文件，默认不能用HMR功能，解决方法：修改入口文件js代码，添加支持HMR功能的代码，另外HMR只能处理非入口js文件的其他文件，对入口文件不生效，因为一旦入口文件更新，入口文件引入的其他文件一定会被重新加载；</p><p>对于html文件，默认不能使用HMR功能，同时会导致html文件不能热更新，解决方法：修改entry入口文件，将html文件引入，只能解决html文件不能热更新的问题。</p><p><img src="4.1.jpg"></p><h3 id="4-2-HMR-效果"><a href="#4-2-HMR-效果" class="headerlink" title="4.2 HMR 效果"></a>4.2 HMR 效果</h3><p>在入口index.js文件中引入print.js文件，运行npx webpack-devserver后，页面如图：</p><p><img src="4.2.1.jpg"></p><p>修改print.js文件后，只会重新加载print.js文件，不会重新加载index.js文件，HMR效果如图：</p><p><img src="4.2.2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp 快速入门</title>
      <link href="/2023/01/09/11.gulp/"/>
      <url>/2023/01/09/11.gulp/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p>在确保你的电脑里装了 Node 的情况下，打开命令行执行以下代码：</p><pre><code>npm install --global gulp</code></pre><p>全局安装 gulp，打开命令行输入 <code>gulp -v</code> 有版本号则证明安装成功了。<br>然后创建一个文件夹，名字随意，我们接下来的操作都在这个文件夹中进行。<br>我创建的文件夹叫 <code>gulpexample</code>，如果安装了 git 进入这个文件夹，右键选择 <code>git bash here</code>，没有安装就进入 <code>cmd</code> 然后进入相应的文件目录下。</p><ul><li>执行 <code>npm init</code> 之后填写名字、作者、描述之类的，剩下的就一顿回车，之后你的文件夹中就会自动生成一个 <code>package.json</code> 文件</li><li>然后在命令行中执行 <code>npm instal gulp --save-dev</code> 在当前项目中安装 gulp。</li></ul><p>好了，现在 gulp 就安装完毕了，接下来我们可以操作了：</p><ul><li>在根目录创建一个文件命名为 <code>gulpfile.js</code> （必须是这个，不能变）</li><li>在根目录创建一个文件夹 <code>src</code></li></ul><h2 id="二、Gulp-的-API"><a href="#二、Gulp-的-API" class="headerlink" title="二、Gulp 的 API"></a>二、Gulp 的 API</h2><pre><code>gulp.task -- 定义任务    gulp.task('任务名，命名随意',fn);gulp.src  -- 找到需要执行任务的文件    gulp.src('要执行的文件的目录').pipe(要执行的api)gulp.dest -- 执行任务的文件的去处    gulp.dest('文件的去处目录（若没有回创建文件夹）')gulp.watch -- 观察文件是否变化    gulp.watch('要监控的文件目录下的文件','变化后要执行的task')</code></pre><h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><ul><li>打开 <code>gulpfile.js</code> 输入如下代码：</li></ul><pre><code>var gulp = require('gulp');// 定义任务gulp.task('message',function(){    return console.log('gulp is running!');});</code></pre><ul><li>然后再当前文件夹目录下的命令行中执行 gulp message，可以看到 <code>gulp is running</code> 证明任务已经执行了。</li></ul><p><strong>拷贝文件，压缩合并 js，sass编译，压缩图片</strong>的用法：<br>首先来安装上述功能相对应的插件（同样也是在相应的目录下执行才可以）</p><pre><code>npm install gulp-sass gulp-concat gulp-uglify gulp-imagemin --save-dev</code></pre><p>安装可能会有些慢，如果实在受不了的话可以安装淘宝的镜像 cnpm 然后用 cnpm 执行。<br>cnpm 的安装如下：</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>安装完 gulp 的插件后在项目根目录新建文件夹 <code>src</code>，打开 <code>gulpfile.js</code> 开始配置：</p><ul><li><strong>第一步，引入插件：</strong></li></ul><pre><code>// 引入gulp及插件var gulp = require('gulp'); var imagemin = require('gulp-imagemin'); // 图片压缩var uglify = require('gulp-uglify'); // js压缩var sass = require('gulp-sass'); // sass编译var concat = require('gulp-concat'); // 代码合并</code></pre><ul><li><strong>第二步，定义任务：</strong></li></ul><p>先定义个简单的任务来熟悉一下 <code>gulp</code> 用法，下面定义一个拷贝 html 的任务：</p><p><strong>任务一， 拷贝html</strong></p><pre><code>// 任务：拷贝htmlgulp.task('copyHtml',function(){    // 选取到src目录下的所有html文件 （为了测试效果，请自己再src目录下随便创建两个html文件咯）    gulp.src('src/*.html')        .pipe(gulp.dest('dist')); // 将html拷贝到dist目录下，没有dist会自动生成});</code></pre><p>在命令行里执行 gulp copyHtml 即可。</p><p><strong>任务二， 图片压缩</strong></p><p>准备工作：在 src 目录下新建 images 文件夹，里面随便放几张图片。</p><pre><code>// 任务： 图片压缩gulp.task('imagemin',function(){    gulp.src('src/images/*')        .pipe(imagemin()) // 调用插件imagemin        .pipe(gulp.dest('dist/image')) // 压缩后的图片输出目录});</code></pre><p>同样命令行执行 gulp imagemin 即可完成输出，<br>基本了解了 gulp 的任务写法后，接下来几个任务就不细说了，直接上代码：</p><pre><code>// sass 编译 src目录下件文件夹sass然后在里面新建一个sass文件，按照sass的语法写一些样式gulp.task('sass',function(){    gulp.src('src/sass/*') // 获取sass文件（*.scss）        .pipe(sass().on('error',sass.logError)) // 执行sass插件，并检查错误        .pipe(gulp.dest('dist/css')); // 输出css文件的路径});// 合并压缩代码，src目录下新建文件夹js然后在里面创建几个js文件gulp.task('scripts',function(){    gulp.src('src/js/*.js') // 获取js文件        .pipe(concat('main.js')) // 合并文件为main.js        .pipe(uglify()) // 压缩js代码        .pipe(gulp.dest('dist/js')) // 输出合并压缩后的文件路径});</code></pre><p>现在4个 api 已经用了3个，还有一个监听的 <code>watch</code> 没有用，就是监听相应目录下的文件是否发生改变，如果改变执行某个任务，即一个参数为监听目录，另一个参数为要执行的任务，（watch 是一个持续执行的任务结束的话是不会停止的）代码如下：</p><pre><code>// 监听文件是否发生变化gulp.task('watch',function(){    gulp.watch('src/js/*.js',['scripts']); // 监听src/js/下的所有js文件，如果发生变化则执行任务scripts,下面同理    gulp.watch('src/sass/*',['sass']);    gulp.watch('src/*.html',['copyHtml']);    gulp.watch('src/images/*',['imageMin']);});</code></pre><p>现在就已经有了5个任务了（算上最开始的 <code>message</code> 就6个了）每一个任务都要执行一遍命令行很麻烦。如果任务多了就更烦了，不要担心，<code>gulp</code> 为我们准备了默认任务 <code>default</code></p><pre><code>// 定义默认任务 , 这里的默认任务default不能随便定义 只能是default,后面接受一个数组作为参数，传入默认执行的任务，后面还可以接受一个回调函数用以执行默认任务代码这里就不给做展示了gulp.task('default',['message','copyHtml','sass','scripts','imageMin','watch']);</code></pre><p>定义好默认任务如上后，在命令行中输入 <code>gulp</code> 回车即可按照参数中的任务顺序全部执行。</p><h2 id="四、压缩-HEXO"><a href="#四、压缩-HEXO" class="headerlink" title="四、压缩 HEXO"></a>四、压缩 HEXO</h2><p><strong>使用方法：</strong></p><p>进入站点根目录依次执行下面的命令：</p><pre><code># 全局安装gulp模块npm install gulp -g# 安装各种小功能模块,执行这步可能会提示权限的问题，最好以管理员模式执行npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save# 额外的功能模块npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save</code></pre><p>在 Hexo 根目录新建文件 <code>gulpfile.js</code>，并复制以下内容到文件，有中文注释，根据自己需求修改。（注意：文件名不能错，一定为 <code>gulpfile.js</code>，否则会出错！）</p><pre><code>var gulp = require("gulp");var debug = require("gulp-debug");var cleancss = require("gulp-clean-css"); // css压缩组件var uglify = require("gulp-uglify"); // js压缩组件var htmlmin = require("gulp-htmlmin"); // html压缩组件var htmlclean = require("gulp-htmlclean"); // html清理组件var imagemin = require("gulp-imagemin"); // 图片压缩组件var changed = require("gulp-changed"); // 文件更改校验组件var gulpif = require("gulp-if"); //任务 帮助调用组件var plumber = require("gulp-plumber"); // 容错组件（发生错误不跳出任务，并报出错误内容）var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)var isDebug = true; //是否调试显示 编译通过的文件var gulpBabel = require("gulp-babel");var es2015Preset = require("babel-preset-es2015");var del = require("del");var Hexo = require("hexo");var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象// 清除public文件夹gulp.task("clean", function () {    return del(["public/**/*"]);});// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return// 创建静态页面 （等同 hexo generate）gulp.task("generate", function () {    return hexo.init().then(function () {        return hexo            .call("generate", {                watch: false            })            .then(function () {                return hexo.exit();            })            .catch(function (err) {                return hexo.exit(err);            });    });});// 启动Hexo服务器gulp.task("server", function () {    return hexo        .init()        .then(function () {            return hexo.call("server", {});        })        .catch(function (err) {            console.log(err);        });});// 部署到服务器gulp.task("deploy", function () {    return hexo.init().then(function () {        return hexo            .call("deploy", {                watch: false            })            .then(function () {                return hexo.exit();            })            .catch(function (err) {                return hexo.exit(err);            });    });});// 压缩public目录下的js文件gulp.task("compressJs", function () {    return gulp        .src(["./public/**/*.js", "!./public/libs/**"]) //排除的js        .pipe(gulpif(!isScriptAll, changed("./public")))        .pipe(gulpif(isDebug, debug({ title: "Compress JS:" })))        .pipe(plumber())        .pipe(            gulpBabel({                presets: [es2015Preset] // es5检查机制            })        )        .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩        .pipe(gulp.dest("./public")); //输出到目标目录});// 压缩public目录下的css文件gulp.task("compressCss", function () {    var option = {        rebase: false,        //advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]        compatibility: "ie7" //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式]        //keepBreaks: true, //类型：Boolean 默认：false [是否保留换行]        //keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀    };    return gulp        .src(["./public/**/*.css", "!./public/**/*.min.css"]) //排除的css        .pipe(gulpif(!isScriptAll, changed("./public")))        .pipe(gulpif(isDebug, debug({ title: "Compress CSS:" })))        .pipe(plumber())        .pipe(cleancss(option))        .pipe(gulp.dest("./public"));});// 压缩public目录下的html文件gulp.task("compressHtml", function () {    var cleanOptions = {        protect: /&lt;\!--%fooTemplate\b.*?%--&gt;/g, //忽略处理        unprotect: /&lt;script [^&gt;]*\btype="text\/x-handlebars-template"[\s\S]+?&lt;\/script&gt;/gi //特殊处理    };    var minOption = {        collapseWhitespace: true, //压缩HTML        collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input /&gt;        removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt;        removeScriptTypeAttributes: true, //删除&lt;script&gt;的type="text/javascript"        removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type="text/css"        removeComments: true, //清除HTML注释        minifyJS: true, //压缩页面JS        minifyCSS: true, //压缩页面CSS        minifyURLs: true //替换页面URL    };    return gulp        .src("./public/**/*.html")        .pipe(gulpif(isDebug, debug({ title: "Compress HTML:" })))        .pipe(plumber())        .pipe(htmlclean(cleanOptions))        .pipe(htmlmin(minOption))        .pipe(gulp.dest("./public"));});// 压缩 public/medias 目录内图片gulp.task("compressImage", function () {    var option = {        optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级）        progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片        interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染        multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化    };    return gulp        .src("./public/medias/**/*.*")        .pipe(gulpif(!isScriptAll, changed("./public/medias")))        .pipe(gulpif(isDebug, debug({ title: "Compress Images:" })))        .pipe(plumber())        .pipe(imagemin(option))        .pipe(gulp.dest("./public"));});// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器gulp.task(    "build",    gulp.series(        "clean",        "generate",        "compressHtml",        "compressCss",        "compressJs",        "compressImage",        gulp.parallel("deploy")    ));// 默认任务gulp.task(    "default",    gulp.series(        "clean",        "generate",        gulp.parallel("compressHtml", "compressCss", "compressJs","compressImage")    ));//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数</code></pre><p>以后的执行方式有两种：</p><ul><li>直接在 Hexo 根目录执行 <code>gulp</code> 或者 <code>gulp default</code> ，这个命令相当于 <code>hexo cl&amp;&amp;hexo g</code> 并且再把代码和图片压缩。</li><li>在 Hexo 根目录执行 <code>gulp build</code> ，这个命令与第 1 种相比是：在最后又加了个 <code>hexo d</code> ，等于说生成、压缩文件后又帮你自动部署了。</li></ul><blockquote><p>注意：这个加入了图片压缩，不想用图片压缩可以把第 154 行的 <code>"compressImage"</code> 和第 165 行的 <code>"compressImage"</code> 去掉即可.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PS去水印</title>
      <link href="/2022/12/15/10.ps-qu-shui-yin/"/>
      <url>/2022/12/15/10.ps-qu-shui-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="一、仿制图章工具"><a href="#一、仿制图章工具" class="headerlink" title="一、仿制图章工具"></a>一、仿制图章工具</h2><p>选取仿制图章工具，按住Alt键，在无文字区域点击相似的色彩或图案，然后在有水印区域拖动鼠标覆盖有水印的区域；仿制图章工具的大小根据水印的大小去灵活设置，提高去水印效率。</p><h2 id="二、修补工具"><a href="#二、修补工具" class="headerlink" title="二、修补工具"></a>二、修补工具</h2><p>在使用修补工具前，首先要确定图片的背景色彩或图案较一致；具体操作为：先选取修补工具，然后要将去水印的区域用鼠标拖着圈住，开始向背景色彩相似的地方左移或右移修补，大道去水印的效果。</p><h2 id="三、复制叠加"><a href="#三、复制叠加" class="headerlink" title="三、复制叠加"></a>三、复制叠加</h2><p>当背景色彩或图案与要取水印的区域一致时，可采用此方法；首先用矩形工具框选一个选区；</p><p>然后Ctrl+J复制选取图层；</p><p>点击移动工具，开始向有水印的地方移动所选的区域，同时按住Alt键，就会不断重复复制图层，达到复制叠加的效果。</p><h2 id="四、污点修复画笔工具"><a href="#四、污点修复画笔工具" class="headerlink" title="四、污点修复画笔工具"></a>四、污点修复画笔工具</h2><p>点击污点修复画笔工具，根据图片水印或要处理的污点大小，适当选择修复工具大小，然后在图片水印处进行涂抹处理，达到去水印效果。</p><h2 id="五、背景色填充"><a href="#五、背景色填充" class="headerlink" title="五、背景色填充"></a>五、背景色填充</h2><p>此种方法适用于图片背景色与主体分明，要去除水印的地方与背景色彩或图案基本一致才能达到预期去水印效果；具体操作为：点击前景色或背景色，用吸管吸取图片背景色彩或图案颜色，设置颜色代码；</p><p>利用矩形选框工具框选水印区域，然后进行颜色填充覆盖水印区域。</p><h2 id="六、橡皮檫"><a href="#六、橡皮檫" class="headerlink" title="六、橡皮檫"></a>六、橡皮檫</h2><p>此种方法也是常用的，属于最简单的，就不详细介绍，适合图片背景是纯白色的。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PR 重拾</title>
      <link href="/2022/10/31/09.pr/"/>
      <url>/2022/10/31/09.pr/</url>
      
        <content type="html"><![CDATA[<h2 id="一、导入素材"><a href="#一、导入素材" class="headerlink" title="一、导入素材"></a>一、导入素材</h2><p>打开 PR （2020破解版）<strong>新建项目：</strong></p><p><img src="1.1.png"></p><p><strong>修改 名称、位置</strong>，其他不用变，点击确定</p><p><img src="1.2.png"></p><p><strong>进入界面如下：</strong></p><p><img src="1.3.png"></p><p><strong>认识、添加必要 窗口</strong></p><p><img src="1.4.png"></p><p><strong>导入媒体以开始，部分右键创建 素材箱</strong></p><p><img src="1.5.png"></p><p><strong>进入素材箱，右键选择导入，要导入的素材</strong></p><p><img src="1.6.png"></p><p><strong>将其拖到时间轴窗口</strong></p><p><img src="1.7.png"></p><h2 id="二、剪辑添加音乐"><a href="#二、剪辑添加音乐" class="headerlink" title="二、剪辑添加音乐"></a>二、剪辑添加音乐</h2><p><strong>使用剃刀工具（快捷键 C）</strong></p><p><img src="2.1.png"></p><p><strong>将视频剪成几部分，用选择工具拖拽</strong></p><p><img src="2.2.png"></p><p><strong>添加音乐，很简单，将音乐素材拖到时间轴窗口，注意M、S，M为静音轨道，S为独奏轨道</strong></p><p><img src="2.3.png"></p><p><strong>背景音乐声音大小调试，在剪辑混合器</strong></p><p><img src="2.4.png"></p><h2 id="三、添加字幕"><a href="#三、添加字幕" class="headerlink" title="三、添加字幕"></a>三、添加字幕</h2><p><strong>字幕 -&gt; 新建字幕 -&gt; 默认静态字幕</strong></p><p><img src="3.1.png"></p><p><strong>输入文字，可改变字体，颜色等自己想要的，CTRL+S 保存</strong></p><p><strong>将字幕拖到时间轴窗口，放到合适位置。</strong></p><p><img src="3.2.png"></p><h2 id="四、速度与持续时间"><a href="#四、速度与持续时间" class="headerlink" title="四、速度与持续时间"></a>四、速度与持续时间</h2><p><strong>右击，选择速度与持续时间，可改变视频播放速度</strong></p><p><img src="4.1.png"></p><p><img src="4.2.png"></p><p><strong>选中倒放速度是可以实现倒放效果的</strong></p><h2 id="五、过渡"><a href="#五、过渡" class="headerlink" title="五、过渡"></a>五、过渡</h2><p><strong>两个视频过度效果，选一个拖到时间轴窗口。</strong></p><p><img src="5.1.png"></p><h2 id="六、移动、缩放"><a href="#六、移动、缩放" class="headerlink" title="六、移动、缩放"></a>六、移动、缩放</h2><p><strong>移动、缩放。选择效果控件窗口，打锚点</strong></p><p><img src="6.1.png"></p><h2 id="七、渲染"><a href="#七、渲染" class="headerlink" title="七、渲染"></a>七、渲染</h2><p><strong>不要有红色。应按回车，渲染，可以使视频更顺畅</strong></p><p><img src="7.1.png"></p><h2 id="八、创意"><a href="#八、创意" class="headerlink" title="八、创意"></a>八、创意</h2><p><strong>打开 Lumetri Clolor 窗口，点创意，可选择视频颜色</strong></p><p><img src="8.1.png"></p><h2 id="九、视频导出"><a href="#九、视频导出" class="headerlink" title="九、视频导出"></a>九、视频导出</h2><p><strong>文件-&gt;导出-&gt;媒体，格式一般选择 H.264，点导出。PR 能力有限，需要120帧得用到 DAINAPP、Topaz 等特别考验显卡性能的软件耗子尾汁。</strong></p><h2 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h2><p><a href="https://www.bilibili.com/video/BV1Vt411n7Bb">https://www.bilibili.com/video/BV1Vt411n7Bb</a></p><p><a href="https://www.bilibili.com/video/BV1kz411i76K">https://www.bilibili.com/video/BV1kz411i76K</a></p><p><a href="https://www.bilibili.com/video/BV1HJ411h78u">https://www.bilibili.com/video/BV1HJ411h78u</a></p><p><a href="https://www.bilibili.com/video/BV1R441177my">https://www.bilibili.com/video/BV1R441177my</a></p><p><a href="https://www.bilibili.com/video/BV1st411n75R">https://www.bilibili.com/video/BV1st411n75R</a></p><p>顺带放上 <strong>PS</strong> 的教程⑧：</p><p><a href="https://www.bilibili.com/video/BV1Xs411q7DW">https://www.bilibili.com/video/BV1Xs411q7DW</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lazyload 优化</title>
      <link href="/2022/08/12/08.lazyload/"/>
      <url>/2022/08/12/08.lazyload/</url>
      
        <content type="html"><![CDATA[<h2 id="一、懒加载和预加载"><a href="#一、懒加载和预加载" class="headerlink" title="一、懒加载和预加载"></a>一、懒加载和预加载</h2><p>图片加载方式有两种，一个是预加载，另一个就是懒加载。</p><ul><li>图片预加载：顾名思义，图片预加载就是在网页全部加载之前，提前加载图片。当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，这样浏览者可能以为图片预览慢而没兴趣浏览，把网页关掉，这时，就需要图片预加载。当然这种做法实际上牺牲了服务器的性能换取了更好的用户体验。</li><li>图片懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片。这样做的好处是减少不必要的访问数据库或延迟访问数据库的次数，因为每次访问数据库都是比较耗时的即只有真正使用该对象的数据时才会创建。懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</li></ul><p><strong>预加载与懒加载的区别之处：</strong></p><p>两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预载则会增加服务器前端压力。</p><p>使用图片懒加载需要安装插件：<a href="https://github.com/Troy-Yang/hexo-lazyload-image">hexo-lazyload-image</a></p><p>在站点根目录执行下面的命令：</p><pre><code>npm install hexo-lazyload-image --save</code></pre><p>之后在站点配置文件下添加下面的代码：</p><pre><code>lazyload:  enable: true  # 是否开启图片懒加载  onlypost: false  # 是否只对文章的图片做懒加载  loadingImg: # eg ./images/loading.gif</code></pre><p>最后执行 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> 就可以看到效果了。</p><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><ul><li>问题 1：查看大图，发现全部为 loading 加载图，原因是懒加载插件与 <strong>lightgallery 插件</strong>冲突，解决办法如下：</li></ul><p>修改主题文件下的 <strong>matery.js</strong>，在 108 行左右添加以下代码：</p><pre><code>$(document).find('img[data-original]').each(function(){    $(this).parent().attr("href", $(this).attr("data-original"));});</code></pre><ul><li>问题 2：点击首页 <strong>logo</strong> 不是跳转到首页，而是查看 <strong>logo</strong> 图片，解决办法如下：</li></ul><p>修改主题的 <strong>header.ejs</strong> 文件，原代码为：</p><pre><code>&lt;div class="brand-logo"&gt;    &lt;a href="&lt;%- url_for() %&gt;" class="waves-effect waves-light"&gt;         &lt;% if (theme.logo !== undefined &amp;&amp; theme.logo.length &gt; 0) { %&gt;         &lt;img src="&lt;%= theme.logo %&gt;" class="logo-img" alt="LOGO"&gt;         &lt;% } %&gt;         &lt;span class="logo-span"&gt;&lt;%- config.title %&gt;&lt;/span&gt;    &lt;/a&gt;&lt;/div&gt;</code></pre><p>修改为：</p><pre><code>&lt;div class="brand-logo"&gt;    &lt;a href="&lt;%- url_for() %&gt;" class="waves-effect waves-light"&gt;        &lt;div&gt;            &lt;% if (theme.logo !== undefined &amp;&amp; theme.logo.length &gt; 0) { %&gt;            &lt;img src="&lt;%= theme.logo %&gt;" class="logo-img" alt="LOGO"&gt;            &lt;% } %&gt;            &lt;span class="logo-span"&gt;&lt;%- config.title %&gt;&lt;/span&gt;        &lt;/div&gt;    &lt;/a&gt;&lt;/div&gt;</code></pre><h2 id="三、优化"><a href="#三、优化" class="headerlink" title="三、优化"></a>三、优化</h2><ul><li>第一次加载后本地都是有缓存的，每次都把 loading 显示出来不好看</li><li>得对插件进行魔改，让图片稍微提前加载，避开加载动画</li><li>打开 <code>Hexo根目录</code> &gt;<code>node_modules</code> &gt; <code>hexo-lazyload-image</code> &gt; <code>lib</code> &gt; <code>simple-lazyload.js</code> 文件</li><li>第 11 行修改为：</li></ul><pre><code>&amp;&amp; rect.top &lt;= (window.innerHeight +240 || document.documentElement.clientHeight +240)</code></pre><p>作用：提前 240 个像素加载图片，当然这个值也可以根据自己情况修改。</p><h2 id="四、添加-loading-pages"><a href="#四、添加-loading-pages" class="headerlink" title="四、添加 loading-pages"></a>四、添加 loading-pages</h2><p>在站点根目录下新建<strong>scripts</strong>文件夹，在该文件夹下新建名为 <strong>loading-pages</strong> 的 <strong>js</strong> 文件，加入下面代码：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/* global hexo */</span><span class="token string">"use strict"</span><span class="token punctuation">;</span>hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>filter<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'after_render:html'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>htmlContent<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">const</span> injectHead <span class="token operator">=</span> <span class="token template-string"><span class="token string">`&lt;style type="text/css" lang="css">    #loading-container{        position: fixed;        top: 0;        left: 0;        min-height: 100vh;        width: 100vw;        z-index: 9999;        display: flex;        flex-direction: column;        justify-content: center;        align-items: center;        background: #FFF;        text-align: center;        /* loader页面消失采用渐隐的方式*/        -webkit-transition: opacity 1s ease;        -moz-transition: opacity 1s ease;        -o-transition: opacity 1s ease;        transition: opacity 1s ease;    }    .loading-image{        width: 120px;        height: 50px;        transform: translate(-50%);    }        .loading-image div:nth-child(2) {        -webkit-animation: pacman-balls 1s linear 0s infinite;        animation: pacman-balls 1s linear 0s infinite    }    .loading-image div:nth-child(3) {        -webkit-animation: pacman-balls 1s linear .33s infinite;        animation: pacman-balls 1s linear .33s infinite    }    .loading-image div:nth-child(4) {        -webkit-animation: pacman-balls 1s linear .66s infinite;        animation: pacman-balls 1s linear .66s infinite    }    .loading-image div:nth-child(5) {        -webkit-animation: pacman-balls 1s linear .99s infinite;        animation: pacman-balls 1s linear .99s infinite    }       .loading-image div:first-of-type {        width: 0;        height: 0;        border: 25px solid #49b1f5;        border-right-color: transparent;        border-radius: 25px;        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;        animation: rotate_pacman_half_up .5s 0s infinite;    }    .loading-image div:nth-child(2) {        width: 0;        height: 0;        border: 25px solid #49b1f5;        border-right-color: transparent;        border-radius: 25px;        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;        animation: rotate_pacman_half_down .5s 0s infinite;        margin-top: -50px;    }    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}        @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}           .loading-image div:nth-child(3),    .loading-image div:nth-child(4),    .loading-image div:nth-child(5),    .loading-image div:nth-child(6){        background-color: #49b1f5;        width: 15px;        height: 15px;        border-radius: 100%;        margin: 2px;        width: 10px;        height: 10px;        position: absolute;        transform: translateY(-6.25px);        top: 25px;        left: 100px;    }    .loading-text{        margin-bottom: 20vh;        text-align: center;        color: #2c3e50;        font-size: 2rem;        box-sizing: border-box;        padding: 0 10px;        text-shadow: 0 2px 10px rgba(0,0,0,0.2);    }    @media only screen and (max-width: 500px) {         .loading-text{            font-size: 1.5rem;         }    }    .fadeout {        opacity: 0;        filter: alpha(opacity=0);    }    /* logo出现动画 */    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}} &lt;/style> &lt;script>(function () {    const loaded = function(){       setTimeout(function(){            const loader = document.getElementById("loading-container");            loader.className="fadeout" ;//使用渐隐的方法淡出loading page            // document.getElementById("body-wrap").style.display="flex";            setTimeout(function(){                loader.style.display="none";            },1000);         },1000);//强制显示loading page 1s      };    loaded();})() &lt;/script>`</span></span><span class="token punctuation">;</span>     <span class="token keyword">const</span> injectBody <span class="token operator">=</span> <span class="token template-string"><span class="token string">` &lt;div id="loading-container">     &lt;p class="loading-text">玩命加载中 . . . &lt;/p>      &lt;div class="loading-image">         &lt;div>&lt;/div>         &lt;div>&lt;/div>         &lt;div>&lt;/div>         &lt;div>&lt;/div>          &lt;div>&lt;/div>     &lt;/div> &lt;/div>`</span></span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/&lt;\/head>/gi</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>htmlContent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">let</span> lastIndex <span class="token operator">=</span> htmlContent<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'&lt;/head>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         htmlContent <span class="token operator">=</span> htmlContent<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> lastIndex<span class="token punctuation">)</span> <span class="token operator">+</span> injectHead <span class="token operator">+</span> htmlContent<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lastIndex<span class="token punctuation">,</span> htmlContent<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/&lt;body>/gi</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>htmlContent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">let</span> index <span class="token operator">=</span> htmlContent<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'&lt;body>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         htmlContent <span class="token operator">=</span> htmlContent<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">+</span> injectBody <span class="token operator">+</span> htmlContent<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> htmlContent<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> htmlContent<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lazyload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 语法汇总</title>
      <link href="/2022/06/29/14.es6/"/>
      <url>/2022/06/29/14.es6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、兼容性"><a href="#一、兼容性" class="headerlink" title="一、兼容性"></a>一、兼容性</h2><p>目前各大浏览器基本上都能够支持 ES6 的新特性，其中 Chrome 和 Firefox 对 ES6 最为友好，但 IE7~11 基本不支持。</p><p>以下是各大浏览器支持情况以及开始时间：</p><p><img src="1.png"></p><h2 id="二、let-与-const"><a href="#二、let-与-const" class="headerlink" title="二、let 与 const"></a>二、let 与 const</h2><blockquote><p>let声明变量，const声明常量：两个都有块级作用域，ES5没有块级作用域。</p></blockquote><p>①变量提升(变量可在声明前使用,值为undefined): let,const不行,var可以,并将申明的变量挂载在window上。</p><p>②块级作用域: let和const只在块级作用域中有效,存在暂存死区,var不是。</p><p>③重复声明: 同一作用域下let和const命令都不允许重复声明同一个变量,var可以但不建议这么做。</p><p>④初始值: const一旦声明必须赋初始值,且声明后不许改变,如果声明的是复合类型数据,可以修改其属性,因为const只是指向对象的地址,地址不变,地址指向的内容是可以改变的。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// var: 输出十个10</span><span class="token comment" spellcheck="true">// 因为所有j都使用同一个引用,而j最终会被更新为10</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出: 0123456789</span><span class="token comment" spellcheck="true">// let不会在栈内存里预分配内存空间,在栈内存分配变量时检查是否存在相同变量名,有就报错,也就是暂时性死区</span><span class="token comment" spellcheck="true">// 块级作用域中let命令所声明的变量不受外部影响</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出 0</span><span class="token comment" spellcheck="true">// const声明后不许改变,所以为初始赋值0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、解构赋值"><a href="#三、解构赋值" class="headerlink" title="三、解构赋值"></a>三、解构赋值</h2><blockquote><p>针对<strong>数组</strong>或<strong>对象</strong>进行匹配，然后对其中的变量进行赋值。常用于交换变量值，取函数返回值，或设置默认值。</p></blockquote><h3 id="3-1-数组的解构赋值（Array）"><a href="#3-1-数组的解构赋值（Array）" class="headerlink" title="3.1 数组的解构赋值（Array）"></a>3.1 数组的解构赋值（Array）</h3><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 基本</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1  b = 2  c = 3</span><span class="token comment" spellcheck="true">// 可嵌套</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1  b = 2  c = 3</span><span class="token comment" spellcheck="true">// 可忽略</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1  b = 3</span><span class="token comment" spellcheck="true">// 不完全解构</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1, b = undefined</span><span class="token comment" spellcheck="true">// 剩余运算符</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a = 1  b = [2, 3]</span><span class="token comment" spellcheck="true">// 字符串等</span><span class="token comment" spellcheck="true">// 在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 'h'  b = 'e'  c = 'l'  d = 'l'  e = 'o'</span><span class="token comment" spellcheck="true">// 解构默认值</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>undefined<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 2</span><span class="token comment" spellcheck="true">// 当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 3, b = 3 </span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1, b = 1 </span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a = 1, b = 2</span><span class="token comment" spellcheck="true">// a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3</span><span class="token comment" spellcheck="true">// a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a = 1</span><span class="token comment" spellcheck="true">// a 与 b 正常解构赋值，匹配结果：a = 1，b = 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-对象的解构赋值（Object）"><a href="#3-2-对象的解构赋值（Object）" class="headerlink" title="3.2 对象的解构赋值（Object）"></a>3.2 对象的解构赋值（Object）</h3><p><strong>基本</strong></p><p><code>let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; // foo = 'aaa' // bar = 'bbb'  let { baz : foo } = { baz : 'ddd' }; // foo = 'ddd'</code></p><p><strong>可嵌套可忽略</strong></p><p><code>let obj = {p: ['hello', {y: 'world'}] }; let {p: [x, { y }] } = obj; // x = 'hello' // y = 'world' let obj = {p: ['hello', {y: 'world'}] }; let {p: [x, {  }] } = obj; // x = 'hello'</code></p><p><strong>不完全解构</strong></p><p><code>let obj = {p: [{y: 'world'}] }; let {p: [{ y }, x ] } = obj; // x = undefined // y = 'world'</code></p><p><strong>剩余运算符</strong></p><p><code>let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}; // a = 10 // b = 20 // rest = {c: 30, d: 40}</code></p><p><strong>解构默认值</strong></p><p><code>let {a = 10, b = 5} = {a: 3}; // a = 3; b = 5; let {a: aa = 10, b: bb = 5} = {a: 3}; // aa = 3; bb = 5;</code></p><h2 id="四、Symbol"><a href="#四、Symbol" class="headerlink" title="四、Symbol"></a>四、Symbol</h2><blockquote><p>ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。</p></blockquote><p><strong>作为属性名：</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">let</span> sy <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 写法1 </span><span class="token keyword">let</span> syObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> syObject<span class="token punctuation">[</span>sy<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"kk"</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>syObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {Symbol(key1): "kk"} </span><span class="token comment" spellcheck="true">// 写法2 </span><span class="token keyword">let</span> syObject <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">[</span>sy<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">"kk"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>syObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {Symbol(key1): "kk"} </span><span class="token comment" spellcheck="true">// 写法3 </span><span class="token keyword">let</span> syObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>syObject<span class="token punctuation">,</span> sy<span class="token punctuation">,</span> <span class="token punctuation">{</span>value<span class="token punctuation">:</span> <span class="token string">"kk"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>syObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// {Symbol(key1): "kk"}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、Map-与-Set"><a href="#五、Map-与-Set" class="headerlink" title="五、Map 与 Set"></a>五、Map 与 Set</h2><p><strong>应用场景：Set用于数据重组，Map用于数据储存</strong></p><p>　　<strong>Set:</strong>　</p><p>　　<strong>（1）成员不能重复</strong></p><p>　　<strong>（2）只有键值没有键名,类似数组</strong></p><p>　　<strong>（3）可以遍历,方法有add,delete,has</strong></p><p>　　<strong>Map:</strong></p><p>　　<strong>（1）本质上是健值对的集合,类似集合</strong></p><p>　　<strong>（2）可以遍历,可以跟各种数据格式转换</strong></p><h3 id="5-1-Map-对象"><a href="#5-1-Map-对象" class="headerlink" title="5.1 Map 对象"></a>5.1 Map 对象</h3><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p><p><strong>Maps 和 Objects 的区别：</strong></p><ul><li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li><li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li><li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li><li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul><h3 id="5-2-Map-中的-key"><a href="#5-2-Map-中的-key" class="headerlink" title="5.2 Map 中的 key"></a>5.2 Map 中的 key</h3><p><strong>key 是字符串</strong></p><pre><code>var myMap = new Map(); var keyString = "a string";   myMap.set(keyString, "和键'a string'关联的值");  myMap.get(keyString); // "和键'a string'关联的值" myMap.get("a string"); // "和键'a string'关联的值" 因为 keyString === 'a string'</code></pre><p><strong>key 是对象</strong></p><pre><code>var myMap = new Map(); var keyObj = {},   myMap.set(keyObj, "和键 keyObj 关联的值");  myMap.get(keyObj); // "和键 keyObj 关联的值" myMap.get({}); // undefined, 因为 keyObj !== {}</code></pre><p><strong>key 是函数</strong></p><pre><code>var myMap = new Map(); var keyFunc = function () {}, // 函数 myMap.set(keyFunc, "和键 keyFunc 关联的值");  myMap.get(keyFunc); // "和键 keyFunc 关联的值" myMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}</code></pre><p><strong>key 是 NaN</strong></p><pre><code>var myMap = new Map(); myMap.set(NaN, "not a number");  myMap.get(NaN); // "not a number"  var otherNaN = Number("foo"); myMap.get(otherNaN); // "not a number"</code></pre><p>虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。</p><h3 id="5-3-Map-的迭代"><a href="#5-3-Map-的迭代" class="headerlink" title="5.3 Map 的迭代"></a>5.3 Map 的迭代</h3><p>对 Map 进行遍历，以下两个最高级。</p><h4 id="5-3-1-for…of"><a href="#5-3-1-for…of" class="headerlink" title="5.3.1 for…of"></a>5.3.1 for…of</h4><p>可以遍历数组，Set和Map结构，某些类数组对象，以及字符串。</p><pre><code>var myMap = new Map(); myMap.set(0, "zero"); myMap.set(1, "one"); // 将会显示两个 log。 一个是 "0 = zero" 另一个是 "1 = one" for (var [key, value] of myMap) {    console.log(key + " = " + value);} for (var [key, value] of myMap.entries()) {   console.log(key + " = " + value); } /* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */  // 将会显示两个log。 一个是 "0" 另一个是 "1" for (var key of myMap.keys()) {    console.log(key); } /* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */  // 将会显示两个log。 一个是 "zero" 另一个是 "one" for (var value of myMap.values()) {    console.log(value); } /* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。*/</code></pre><h4 id="5-3-2-forEach"><a href="#5-3-2-forEach" class="headerlink" title="5.3.2 forEach()"></a>5.3.2 forEach()</h4><pre><code>var myMap = new Map(); myMap.set(0, "zero"); myMap.set(1, "one");  // 将会显示两个 logs。 一个是 "0 = zero" 另一个是 "1 = one" myMap.forEach(function(value, key) {    console.log(key + " = " + value); }, myMap)</code></pre><h3 id="5-4-Map-对象的操作"><a href="#5-4-Map-对象的操作" class="headerlink" title="5.4 Map 对象的操作"></a>5.4 Map 对象的操作</h3><p><strong>Map 与 Array的转换</strong></p><pre><code>var kvArray = [["key1", "value1"], ["key2", "value2"]];  // Map 构造函数可以将一个二维键值对数组转换成一个 Map 对象 var myMap = new Map(kvArray);  // 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组var outArray = Array.from(myMap);</code></pre><p><strong>Map 的克隆</strong></p><pre><code>var myMap1 = new Map([["key1", "value1"], ["key2", "value2"]]); var myMap2 = new Map(myMap1);  console.log(original === clone);  // 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</code></pre><p><strong>Map 的合并</strong></p><pre><code>var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]); var second = new Map([[1, 'uno'], [2, 'dos']]);  // 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three var merged = new Map([...first, ...second]);</code></pre><h3 id="5-5-Set-对象"><a href="#5-5-Set-对象" class="headerlink" title="5.5 Set 对象"></a>5.5 Set 对象</h3><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p><h3 id="5-6-类型转换"><a href="#5-6-类型转换" class="headerlink" title="5.6 类型转换"></a>5.6 类型转换</h3><p><strong>Array</strong></p><pre><code>// Array 转 Set var mySet = new Set(["value1", "value2", "value3"]); // 用...操作符，将 Set 转 Array var myArray = [...mySet]; String // String 转 Set var mySet = new Set('hello'); // Set(4) {"h", "e", "l", "o"}// 注：Set 中 toString 方法是不能将 Set 转换成 String</code></pre><h3 id="5-7-数组去重"><a href="#5-7-数组去重" class="headerlink" title="5.7 数组去重"></a>5.7 数组去重</h3><pre><code>var mySet = new Set([1, 2, 3, 4, 4]); [...mySet]; // [1, 2, 3, 4]</code></pre><h3 id="5-8-并集"><a href="#5-8-并集" class="headerlink" title="5.8 并集"></a>5.8 并集</h3><pre><code>var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var union = new Set([...a, ...b]); // {1, 2, 3, 4}</code></pre><h3 id="5-9-交集"><a href="#5-9-交集" class="headerlink" title="5.9 交集"></a>5.9 交集</h3><pre><code>var a = new Set([1, 2, 3]); var b = new Set([4, 3, 2]); var intersect = new Set([...a].filter(x =&gt; b.has(x))); // {2, 3}</code></pre><h3 id="5-10-差集"><a href="#5-10-差集" class="headerlink" title="5.10 差集"></a>5.10 差集</h3><pre><code>var a = new Set([1, 2, 3]);var b = new Set([4, 3, 2]); var difference = new Set([...a].filter(x =&gt; !b.has(x))); // {1}</code></pre><h2 id="六、Reflect-与-Proxy"><a href="#六、Reflect-与-Proxy" class="headerlink" title="六、Reflect 与 Proxy"></a>六、Reflect 与 Proxy</h2><p>Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。</p><p>Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。</p><p>Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。</p><h3 id="6-1-Proxy"><a href="#6-1-Proxy" class="headerlink" title="6.1 Proxy"></a>6.1 Proxy</h3><p>一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p><pre><code>let target = {    name: 'Tom',    age: 24}let handler = {    get: function(target, key) {        console.log('getting '+key);        return target[key]; // 不是target.key    },    set: function(target, key, value) {        console.log('setting '+key);        target[key] = value;    }}let proxy = new Proxy(target, handler)proxy.name     // 实际执行 handler.getproxy.age = 25 // 实际执行 handler.set// getting name// setting age// 25// target 可以为空对象let targetEpt = {}let proxyEpt = new Proxy(targetEpt, handler)// 调用 get 方法，此时目标对象为空，没有 name 属性proxyEpt.name // getting name// 调用 set 方法，向目标对象中添加了 name 属性proxyEpt.name = 'Tom'// setting name// "Tom"// 再次调用 get ，此时已经存在 name 属性proxyEpt.name// getting name// "Tom"// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相// 影响targetEpt)// {name: "Tom"}// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象let targetEmpty = {}let proxyEmpty = new Proxy(targetEmpty,{})proxyEmpty.name = "Tom"targetEmpty) // {name: "Tom"}</code></pre><h3 id="6-2-Reflect"><a href="#6-2-Reflect" class="headerlink" title="6.2 Reflect"></a>6.2 Reflect</h3><p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p><p>Reflect 对象对某些方法的返回结果进行了修改，使其更合理。</p><p>Reflect 对象使用函数的方式实现了 Object 的命令式操作。</p><p><strong>静态方法</strong></p><pre><code>Reflect.get(target, name, receiver)</code></pre><p>查找并返回 target 对象的 name 属性。</p><pre><code>let exam = {    name: "Tom",    age: 24,    get info(){        return this.name + this.age;    }}Reflect.get(exam, 'name'); // "Tom"// 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiverlet receiver = {    name: "Jerry",    age: 20}Reflect.get(exam, 'info', receiver); // Jerry20// 当 name 为不存在于 target 对象的属性时，返回 undefinedReflect.get(exam, 'birth'); // undefined// 当 target 不是对象时，会报错Reflect.get(1, 'name'); // TypeError</code></pre><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><p>ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。</p><ul><li>**includes()**：返回布尔值，判断是否找到参数字符串。</li><li>**startsWith()**：返回布尔值，判断参数字符串是否在原字符串的头部。</li><li>**endsWith()**：返回布尔值，判断参数字符串是否在原字符串的尾部。</li></ul><p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p><pre><code>let string = "apple,banana,orange";string.includes("banana");     // truestring.startsWith("apple");    // truestring.endsWith("apple");      // falsestring.startsWith("banana",6)  // true</code></pre><p><strong>注意点：</strong></p><ul><li>这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。</li><li>这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。</li></ul><h3 id="7-1-字符串重复"><a href="#7-1-字符串重复" class="headerlink" title="7.1 字符串重复"></a>7.1 字符串重复</h3><p>repeat()：返回新的字符串，表示将字符串重复指定次数返回。</p><pre><code>console.log("Hello,".repeat(2));  // "Hello,Hello,"</code></pre><p>如果参数是小数，向下取整</p><pre><code>console.log("Hello,".repeat(3.2));  // "Hello,Hello,Hello,"</code></pre><p>如果参数是 0 至 -1 之间的小数，会进行取整运算，0 至 -1 之间的小数取整得到 -0 ，等同于 repeat 零次</p><pre><code>console.log("Hello,".repeat(-0.5));  // "" </code></pre><p>如果参数是 NaN，等同于 repeat 零次</p><pre><code>console.log("Hello,".repeat(NaN));  // "" </code></pre><p>如果参数是负数或者 Infinity ，会报错:</p><pre><code>console.log("Hello,".repeat(-1));  // RangeError: Invalid count valueconsole.log("Hello,".repeat(Infinity));  // RangeError: Invalid count value</code></pre><p>如果传入的参数是字符串，则会先将字符串转化为数字</p><pre><code>console.log("Hello,".repeat("hh")); // ""console.log("Hello,".repeat("2"));  // "Hello,Hello,"</code></pre><h3 id="7-2-字符串补全"><a href="#7-2-字符串补全" class="headerlink" title="7.2 字符串补全"></a>7.2 字符串补全</h3><ul><li><strong>padStart</strong>：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</li><li><strong>padEnd</strong>：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。</li></ul><p>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</p><pre><code>console.log("h".padStart(5,"o"));  // "ooooh"console.log("h".padEnd(5,"o"));    // "hoooo"console.log("h".padStart(5));      // "    h"</code></pre><p>如果指定的长度小于或者等于原字符串的长度，则返回原字符串:</p><pre><code>console.log("hello".padStart(5,"A"));  // "hello"</code></pre><p>如果原字符串加上补全字符串长度大于指定长度，则截去超出位数的补全字符串:</p><pre><code>console.log("hello".padEnd(10,",world!"));  // "hello,worl"</code></pre><p>常用于补全位数：</p><pre><code>console.log("123".padStart(10,"0"));  // "0000000123"</code></pre><h3 id="7-3-模板字符串"><a href="#7-3-模板字符串" class="headerlink" title="7.3 模板字符串"></a>7.3 模板字符串</h3><p>模板字符串相当于加强版的字符串，<code>${}</code> 拼接参数，可以在字符串中加入变量和表达式。</p><p><strong>基本用法</strong></p><p>普通字符串</p><pre><code>let string = `Hello'\n'world`; console.log(string);  // "Hello'// 'world"</code></pre><p>多行字符串:</p><pre><code>let string1 =  `Hey, can you stop angry now?`; console.log(string1); // Hey, // can you stop angry now?</code></pre><p>字符串插入变量和表达式。</p><p>变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。</p><pre><code>let name = "Mike"; let age = 27; let info = `My Name is ${name},I am ${age+1} years old next year.` console.log(info); // My Name is Mike,I am 28 years old next year.</code></pre><p>字符串中调用函数：</p><pre><code>function f(){  return "have fun!"; } let string2= `Game start,${f()}`; console.log(string2);  // Game start,have fun!</code></pre><p><strong>注意要点</strong></p><p>模板字符串中的换行和空格都是会被保留的</p><p><strong>应用</strong></p><p>过滤 HTML 字符串，防止用户输入恶意内容。</p><pre><code>function f(stringArr,...values){ let result = ""; for(let i=0;i&lt;stringArr.length;i++){  result += stringArr[i];   if(values[i]){     result += String(values[i]).replace(/&amp;/g, "&amp;amp;")               .replace(/&lt;/g, "&amp;lt;")               .replace(/&gt;/g, "&amp;gt;");    } } return result;}name = '&lt;Amy&amp;MIke&gt;';f`&lt;p&gt;Hi, ${name}.I would like send you some message.&lt;/p&gt;`;// &lt;p&gt;Hi, &amp;lt;Amy&amp;amp;MIke&amp;gt;.I would like send you some message.&lt;/p&gt;</code></pre><p><strong>国际化处理（转化多国语言）</strong></p><pre><code>i18n`Hello ${name}, you are visitor number ${visitorNumber}.`;  // 你好**，你是第**位访问者</code></pre><h2 id="八、箭头函数"><a href="#八、箭头函数" class="headerlink" title="八、箭头函数"></a>八、箭头函数</h2><p>箭头函数：省去function关键字,用 () = &gt; 来定义，函数的参数放在箭头前的括号，函数体在箭头后的花括号。</p><p>它的 this 继承了外层执行环境的 this，不能被 call() apply() bind() 改变指向。</p><p>没有自己的arguments，用rest参数代替arguments对象，来访问箭头函数的参数列表。</p><p>没有原型prototype，打印显示undefined。</p><p>不能用作Generator函数，所以不能使用yeild关键字。</p><p>不能用作构造函数,也就是说不能使用new命令,否则报错</p><p><strong>适合使用的场景：</strong></p><p>ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。</p><p><strong>不适合使用的场景：</strong></p><p>定义函数的方法，且该方法中包含 this 或需要动态 this 的时候。</p><h2 id="九、…-拓展运算符"><a href="#九、…-拓展运算符" class="headerlink" title="九、… 拓展运算符"></a>九、… 拓展运算符</h2><p>将数组或对象里面的值展开，或将多个值收集为一个变量，代替argument对象，对象未嵌套可用来浅拷贝。</p><h2 id="十、Iterator-迭代器"><a href="#十、Iterator-迭代器" class="headerlink" title="十、Iterator 迭代器"></a>十、Iterator 迭代器</h2><p>Iterator 是 ES6 引入的一种新的遍历机制，迭代器有两个核心概念：</p><ul><li>迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为Symbol.iterator 的方法来实现。</li><li>迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。</li></ul><p>迭代的过程如下：</p><ul><li>通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置</li><li>随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束</li><li>当 done 为 true 时则遍历结束<br>```javascript<br>const items = [“zero”, “one”, “two”];<br>const it = items<a href="">Symbol.iterator</a>;</li></ul><p>it.next();</p><blockquote><p>{value: “zero”, done: false}<br>it.next();<br>{value: “one”, done: false}<br>it.next();<br>{value: “two”, done: false}<br>it.next();<br>{value: undefined, done: true}</p></blockquote><pre><code>上面的例子，首先创建一个数组，然后通过 Symbol.iterator 方法创建一个迭代器，之后不断的调用 next 方法对数组内部项进行访问，当属性 done 为 true 时访问结束。迭代器是协议（使用它们的规则）的一部分，用于迭代。该协议的一个关键特性就是它是顺序的：迭代器一次返回一个值。这意味着如果可迭代数据结构是非线性的（例如树），迭代将会使其线性化。**可迭代的数据结构：**以下是可迭代的值:- Array- String- Map- Set- Dom元素（正在进行中）## 十一、Class 类在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。class 的本质是 function。它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。定义类更简便地实现类的继承。**类定义**类表达式可以为匿名或命名。</code></pre><p>// 匿名类<br>let Example = class {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}<br>// 命名类<br>let Example = class Example {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}</p><pre><code>**类声明**</code></pre><p>class Example {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}</p><pre><code>**注意要点：**不可重复声明。方法间不能加分号。类中方法不需要 function 关键字。类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。修饰器@: decorator是一个函数，用来修改类甚至于是方法的行为，修饰器本质就是编译时执行的函数。**属性**prototype，ES6 中，prototype 仍旧存在，虽然可以直接自类中定义方法，但是其实方法还是定义在 prototype 上的。 覆盖方法 / 初始化时添加方法。</code></pre><p>Example.prototype={<br>    //methods<br>}</p><pre><code>添加方法</code></pre><p>Object.assign(Example.prototype,{<br>    //methods<br>})</p><pre><code>静态属性：class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。</code></pre><p>class Example {<br>// 新提案<br>    static a = 2;<br>}<br>// 目前可行写法<br>Example.b = 2;</p><pre><code>公共属性</code></pre><p>class Example{}<br>Example.prototype.a = 2;</p><pre><code>实例属性：定义在实例对象（ this ）上的属性。</code></pre><p>class Example {<br>    a = 2;<br>    constructor () {<br>        console.log(this.a);<br>    }<br>}</p><pre><code>name 属性，返回跟在 class 后的类名(存在时)。</code></pre><p>let Example=class Exam {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}<br>console.log(Example.name); // Exam</p><p>let Example=class {<br>    constructor(a) {<br>        this.a = a;<br>    }<br>}<br>console.log(Example.name); // Example</p><pre><code>constructor 方法是类的默认方法，创建类的实例化对象时被调用。</code></pre><p>class Example{<br>    constructor(){<br>      console.log(‘我是constructor’);<br>    }<br>}<br>new Example(); // 我是constructor</p><pre><code>返回对象</code></pre><p>class Test {<br>    constructor(){<br>        // 默认返回实例对象 this<br>    }<br>}<br>console.log(new Test() instanceof Test); // true</p><p>class Example {<br>    constructor(){<br>        // 指定返回对象<br>        return new Test();<br>    }<br>}<br>console.log(new Example() instanceof Example); // false</p><pre><code>静态方法</code></pre><p>class Example{<br>    static sum(a, b) {<br>        console.log(a+b);<br>    }<br>}<br>Example.sum(1, 2); // 3</p><pre><code>原型方法</code></pre><p>class Example {<br>    sum(a, b) {<br>        console.log(a + b);<br>    }<br>}<br>let exam = new Example();<br>exam.sum(1, 2); // 3</p><pre><code>实例方法</code></pre><p>class Example {<br>    constructor() {<br>        this.sum = (a, b) =&gt; {<br>            console.log(a + b);<br>        }<br>    }<br>}</p><pre><code>## 十二、模块ES6 模块自动开启严格模式，即使没加 `use strict;`。模块中可以导入和导出各类型变量，如函数，对象，字符串，数字，布尔值，类等。每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。模块导入导出各种类型的变量，如字符串，数值，函数，类。- 导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 - 不仅能导出声明还能导出引用（例如函数）。- export 命令可以出现在模块的任何位置，但必需处于模块顶层。- import 命令会提升到整个模块的头部，首先执行。</code></pre><p>/<em>—–export [test.js]—–</em>/<br>let myName = “Tom”;<br>let myAge = 20;<br>let myfn = function(){<br>    return “My name is” + myName + “! I’m ‘“ + myAge + “years old.”<br>}<br>let myClass =  class myClass {<br>    static a = “yeah!”;<br>}<br>export { myName, myAge, myfn, myClass }</p><p>/<em>—–import [xxx.js]—–</em>/<br>import { myName, myAge, myfn, myClass } from “./test.js”;<br>console.log(myfn());// My name is Tom! I’m 20 years old.<br>console.log(myAge);// 20<br>console.log(myName);// Tom<br>console.log(myClass.a );// yeah!</p><pre><code>建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。不同模块导出接口名称命名重复， 使用 as 重新定义变量名。**export default 命令：**- 在一个文件或模块中，export、import 可以有多个，export default 仅有一个。- export default 中的 default 是对应的导出接口变量。- 通过 export 方式导出，在导入时要加{ }，export default 则不需要。- export default 向外暴露的成员，可以使用任意变量来接收。## 十三、Promise 对象是异步编程的一种解决方案。比传统的解决方案（回调函数和事件）更强大合理。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。**状态的缺点**无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。**then 方法**then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。**then 方法的特点**在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。注意总是返回或终止 Promise 链。</code></pre><p>const p1 = new Promise(function(resolve,reject){<br>  resolve(1);<br>}).then(function(result) {<br>  p2(result).then(newResult =&gt; p3(newResult));<br>}).then(() =&gt; p4());</p><pre><code>创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 `catch(error =&gt; console.log(error));`reject是用来抛出异常,catch是用来处理异常；reject是Promise的方法,而catch是Promise实例的方法；reject后的东西,一定会进入then中的第二个回调,如果then中没有写第二个回调,则进入catch；网络异常(比如断网),会直接进入catch而不会进入then的第二个回调。**手写 promise：**&gt; promise 的三种状态：pending、fulfilled、rejected。```javascriptclass Promise {  constructor(executor) {    // Promise接一个方法  （resolve，reject）=&gt;{}    // 开始的状态    this.state = 'pending'    // 成功的状态    this.value = undefined    // 失败的状态    this.result = undefined    // 状态执行的时候，要立即改变，且不可逆转    const resolve = (value) =&gt; {      if (this.state === 'pending') {        this.state = 'fulfilled'        this.value = value      }    }    const reject = (reason) =&gt; {      if (this.state === 'pending') {        this.state = 'rejected'        this.result = reason      }    }    executor(resolve, reject) //这个方法要立即执行  }  // then接受两个参数，都是方法  then(onFulfilled, onRejected) {    // 如果这样写是同步的，this.state一直是padding的状态    console.log(this.state)    // 如果成功，传入成功的参数    if (this.state === 'fulfilled') {      onFulfilled(this.value)    }    // 如果失败，传入失败的参数    if (this.state === 'rejected') {      onRejected(this.result)    }  }}</code></pre><blockquote><p>上面是同步的，执行 then 方法后，this.state 一直是 pending 的状态。</p><p>发布订阅者模式。</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Promise接一个方法  （resolve，reject）=>{}</span>    <span class="token comment" spellcheck="true">// 开始的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span>    <span class="token comment" spellcheck="true">// 成功的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> undefined    <span class="token comment" spellcheck="true">// 失败的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> undefined    <span class="token comment" spellcheck="true">// 成功的订阅者数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 失败的订阅者数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 状态执行的时候，要立即改变，且不可逆转</span>    <span class="token keyword">const</span> resolve <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value        <span class="token comment" spellcheck="true">// 执行resolve的时候，把 this.onResolvedCallbacks里面的方法全部执行一遍</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> reject <span class="token operator">=</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> reason        <span class="token comment" spellcheck="true">// 执行reject的时候，把 this.onRejectedCallbacks里面的方法全部执行一遍</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这个方法要立即执行</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// then接受两个参数，都是方法</span>  <span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果这样写是同步的，this.state一直是padding的状态</span>    <span class="token comment" spellcheck="true">// 如果成功，传入成功的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'fulfilled'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果失败，传入失败的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'rejected'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 发布订阅者模式</span>    <span class="token comment" spellcheck="true">// 如果状态是   pending</span>    <span class="token comment" spellcheck="true">// 就把要做的方法传入 待发布状态中去</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'padding'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>但是上面没有链式调用。then() 方法后面不能接 then()。</p><p>解决 then() 方法不返回 promise 的问题。</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Promise接一个方法  （resolve，reject）=>{}</span>    <span class="token comment" spellcheck="true">// 开始的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span>    <span class="token comment" spellcheck="true">// 成功的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> undefined    <span class="token comment" spellcheck="true">// 失败的状态</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> undefined    <span class="token comment" spellcheck="true">// 成功的订阅者数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 失败的订阅者数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 状态执行的时候，要立即改变，且不可逆转</span>    <span class="token keyword">const</span> resolve <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value        <span class="token comment" spellcheck="true">// 执行resolve的时候，把 this.onResolvedCallbacks里面的方法全部执行一遍</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">const</span> reject <span class="token operator">=</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> reason        <span class="token comment" spellcheck="true">// 执行reject的时候，把 this.onRejectedCallbacks里面的方法全部执行一遍</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这个方法要立即执行</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// then接受两个参数，都是方法</span>  <span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果这样写是同步的，this.state一直是padding的状态</span>    <span class="token comment" spellcheck="true">// 如果成功，传入成功的参数</span>    <span class="token keyword">const</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 解决不能链式调用的问题。需要再返回一个promise</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'fulfilled'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 如果失败，传入失败的参数</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'rejected'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span>          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 发布订阅者模式</span>      <span class="token comment" spellcheck="true">// 如果状态是   padding</span>      <span class="token comment" spellcheck="true">// 就把要做的方法传入 待发布状态中去</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'padding'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">)</span>            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> promise2  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义resolvePromise 方法</span><span class="token keyword">const</span> resolvePromise <span class="token operator">=</span> <span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// console.log(promise2, x, resolve, reject)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11111</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'循环引用！'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 判断 x 的类型</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 复杂类型</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">const</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 认为这个确实是一个promise</span>        then<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 只能解决一次，如果resolve里面嵌套n个promise</span>          <span class="token comment" spellcheck="true">// resolve(y)</span>          <span class="token comment" spellcheck="true">// 递归解析当前的x</span>          <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 基本类型</span>    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十四、Generator-函数"><a href="#十四、Generator-函数" class="headerlink" title="十四、Generator 函数"></a>十四、Generator 函数</h2><p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法：</p><p>Generator 有两个区分于普通函数的部分：</p><ul><li>一是在 function 后面，函数名之前有个 * 。</li><li>函数内部有 yield 表达式。</li></ul><p>其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。</p><pre><code>function* func(){ console.log("one"); yield '1'; console.log("two"); yield '2';  console.log("three"); return '3';}</code></pre><p>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。</p><h2 id="十五、async-函数"><a href="#十五、async-函数" class="headerlink" title="十五、async 函数"></a>十五、async 函数</h2><p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联。通过编写类似同步的代码来处理异步流程，提高代码的简洁性和可读性。</p><pre><code>async function name([param[, param[, ... param]]]) { statements }</code></pre><ul><li>name: 函数名称。</li><li>param: 要传递给函数的参数的名称。</li><li>statements: 函数体语句。</li></ul><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p><pre><code>async function helloAsync(){    return "helloAsync";  }  console.log(helloAsync())  // Promise {&lt;resolved&gt;: "helloAsync"} helloAsync().then(v=&gt;{   console.log(v);         // helloAsync})</code></pre><p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p><p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p><pre><code>function testAwait(){   return new Promise((resolve) =&gt; {       setTimeout(function(){          console.log("testAwait");          resolve();       }, 1000);   });} async function helloAsync(){   await testAwait();   console.log("helloAsync"); }helloAsync();// testAwait// helloAsync</code></pre><p>await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。</p><pre><code>[return_value] = await expression;</code></pre><p>expression: 一个 Promise 对象或者任何要等待的值。</p><p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p><p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</p><pre><code>function testAwait (x) {  return new Promise(resolve =&gt; {    setTimeout(() =&gt; {      resolve(x);    }, 2000);  });} async function helloAsync() {  var x = await testAwait ("hello world");  console.log(x); }helloAsync ();// hello world</code></pre><p>正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。</p><pre><code>function testAwait(){   console.log("testAwait");}async function helloAsync(){   await testAwait();   console.log("helloAsync");}helloAsync();// testAwait// helloAsync</code></pre><p>await针对所跟不同表达式的处理方式：</p><p>Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。<br>非 Promise 对象：直接返回对应的值。</p><p>async较Generator的优势：</p><p>　（1）内置执行器: Generator函数的执行必须依靠执行器,而 Aysnc函数自带执行器,调用方式跟普通函数的调用一样</p><p>　（2）更好的语义: async和await相较于*和yield更加语义化　　</p><p>　（3）更广的适用性: yield命令后面只能是Thunk函数或Promise对象,async函数的await后面可以是Promise也可以是原始类型的值</p><p>​    （4）返回值是 Promise: async函数返回的是Promise对象,比Generator函数返回的Iterator对象方便,可以直接使用then()方法进行调用</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器差异及渲染</title>
      <link href="/2022/06/09/07.liu-lan-qi-chai-yi-ji-xuan-ran/"/>
      <url>/2022/06/09/07.liu-lan-qi-chai-yi-ji-xuan-ran/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常见浏览器及其内核"><a href="#一、常见浏览器及其内核" class="headerlink" title="一、常见浏览器及其内核"></a>一、常见浏览器及其内核</h2><p><img src="1.png"></p><p>微软的新一代浏览器Microsoft Edge，宣布打算采用 Chromium 开源项目开发桌面版的 Microsoft Edge 浏览器，详情见<a href="https://blogs.windows.com/windowsexperience/2018/12/06/microsoft-edge-making-the-web-better-through-more-open-source-collaboration/#Q4eKSlPUTUfiWhxF.97">Microsoft Edge: Making the web better through more open source collaboration</a>.</p><p>对此表示喜大普奔，毕竟IE太难用了，开发的时候做兼容也是非常恶心，(╥╯^╰╥)</p><hr><h2 id="二、什么是内核"><a href="#二、什么是内核" class="headerlink" title="二、什么是内核"></a>二、什么是内核</h2><blockquote><p>浏览器最重要或者说核心的部分是<strong>“Rendering Engine”</strong>，可大概译为“解释引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如HTML、JavaScript）并渲染（显示）网页。<br> 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。<br> 不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</p></blockquote><blockquote><p>另一种关于内核的说明：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E">维基百科(↓)</a></p></blockquote><h3 id="2-1-排版引擎"><a href="#2-1-排版引擎" class="headerlink" title="2.1 排版引擎"></a>2.1 排版引擎</h3><p> <strong>排版引擎</strong>（layout engine），也称为<strong>浏览器引擎</strong>（web browser engine）、<strong>页面渲染引擎</strong>（rendering engine）或<strong>样版引擎</strong>，负责获取标记式内容（如<a href="https://zh.wikipedia.org/wiki/HTML">HTML</a>、<a href="https://zh.wikipedia.org/wiki/XML">XML</a>及图像文件等等）、整理信息（如<a href="https://zh.wikipedia.org/wiki/CSS">CSS</a>及<a href="https://zh.wikipedia.org/wiki/XSL">XSL</a>等），并将排版后的内容输出至显示器或打印机。</p><h3 id="2-2-JavaScript-引擎"><a href="#2-2-JavaScript-引擎" class="headerlink" title="2.2 JavaScript 引擎"></a>2.2 JavaScript 引擎</h3><p>  <strong>JavaScript 引擎</strong>是一个专门处理<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>脚本的<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a>，一般会附带在<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8">网页浏览器</a>之中。</p><table><thead><tr><th align="center">JS引擎</th><th align="center">应用程序(实现)</th></tr></thead><tbody><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/V8_(JavaScript%E5%BC%95%E6%93%8E)">V8</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Google_Chrome">Google Chrome</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/SpiderMonkey">SpiderMonkey</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Mozilla_Firefox">Mozilla Firefox</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/WebKit#JavaScriptCore">JavaScriptCore</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Safari">Safari</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/Chakra_(JScript%E5%BC%95%E6%93%8E)">Chakra (JScript引擎)</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Internet_Explorer">Internet Explorer</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/Chakra_(JavaScript%E5%BC%95%E6%93%8E)">Chakra (JavaScript引擎)</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Microsoft_Edge">Microsoft Edge</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/KJS">KJS</a></td><td align="center">Konqueror</td></tr></tbody></table><hr><h2 id="三、浏览器渲染原理"><a href="#三、浏览器渲染原理" class="headerlink" title="三、浏览器渲染原理"></a>三、浏览器渲染原理</h2><p>Web页面运行在各种各样的浏览器当中，浏览器载入、渲染页面的速度直接影响着用户体验简单地说，页面渲染就是浏览器将html代码根据CSS定义的规则显示在浏览器窗口中的这个过程。</p><p>先来大致了解一下浏览器都是怎么干活的：</p><ol><li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li><li>浏览器开始载入html代码，发现<code>&lt;head&gt;</code>标签内有一个<code>&lt;link&gt;</code>标签引用外部CSS文件；</li><li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li><li>浏览器继续载入html中<code>&lt;body&gt;</code>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li><li>浏览器在代码中发现一个<code>&lt;img&gt;</code>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li><li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li><li>浏览器发现了一个包含一行Javascript代码的<code>&lt;script&gt;</code>标签，赶快运行它；</li><li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</li><li>终于等到了<code>&lt;/html&gt;</code>的到来，浏览器泪流满面……</li><li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下<code>&lt;link&gt;</code>标签的CSS路径；</li><li>浏览器召集了在座的各位<br> <code>&lt;span&gt;&lt;ul&gt;&lt;li&gt;</code>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li></ol><p>说到页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，这个回退的过程叫<strong>reflow</strong>。</p><p>reflow几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。</p><p>鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。</p><p>通常我们都无法预估浏览器到底会reflow哪一部分的代码，它们都彼此相互影响着。</p><p>reflow问题是可以优化的，我们可以尽量减少不必要的reflow。</p><p>如开头例子中的<code>&lt;img&gt;</code>图片载入问题，这其实就是一个可以避免的reflow——给图片设置宽度和高度。</p><p>这样浏览器就知道了图片的占位面积，在载入图片前就预留好了位置。</p><p><strong>repaint：重绘</strong></p><p>如果只是改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器repaint。</p><p>repaint的速度明显快于 reflow（在IE下需要换一下说法，reflow要比repaint 更缓慢）。</p><h2 id="四、CSS性能"><a href="#四、CSS性能" class="headerlink" title="四、CSS性能"></a>四、CSS性能</h2><p><strong>最终决定浏览器表现出来的页面效果的差异是：渲染引擎 Rendering Engine（也叫做排版引擎），也就是我们通常所说的<a href="http://www.smallni.com/?p=106">“浏览器内核”</a>，负责解析网页语法（如HTML、JavaScript）并渲染、展示网页。相同的代码在不同的浏览器呈现出来的效果不一样，那么就很有可能是不同的浏览器内核导致的。</strong></p><p><strong>加载页面时浏览器的工作流程：</strong></p><p><strong>1、解析HTML以重建DOM树（Parsing HTML to construct the DOM tree ）</strong>：<br> 渲染引擎开始解析HTML文档，转换树中的标签到DOM节点，它被称为“内容树”。</p><p><strong>2、构建渲染树（Render tree construction）</strong>：<br> 解析CSS（包括外部CSS文件和样式元素），根据CSS选择器计算出节点的样式，创建另一个树 —- 渲染树。</p><p><strong>3、布局渲染树（Layout of the render tree）:</strong><br> &lt;wbr style=”font-family: “Microsoft Yahei”, sans-serif;”&gt;从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标。</p><p><strong>4、绘制渲染树（Painting the render tree）</strong><br> &lt;wbr style=”font-family: “Microsoft Yahei”, sans-serif;”&gt;: 遍历渲染树，每个节点将使用UI后端层来绘制。</p><p>主要的流程就是：构建一个dom树，页面要显示的各元素都会创建到这个dom树当中，每当一个新元素加入到这个dom树当中，浏览器便会通过css引擎查遍css样式表，找到符合该元素的样式规则应用到这个元素上。</p><p><strong>注意了：css引擎查找样式表，对每条规则都按从右到左的顺序去匹配。</strong></p><p>对此，在CSS书写过程中，总结出如下性能提升的方案：</p><ol><li>避免使用通配规则：如 *{} 计算次数惊人！只对需要用到的元素进行选择</li><li>尽量少的去对标签进行选择，而是用class，如：#nav li{},可以为li加上nav_item的类名，选择.nav_item{}</li><li>不要去用标签限定ID或者类选择符，如：ul#nav，应该简化为#nav</li><li>尽量少的去使用后代选择器，降低选择器的权重值，后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>考虑继承样式，了解哪些属性是可以通过继承而来的，避免对这些属性重复指定规则。</li></ol><h2 id="五、CSS初始化"><a href="#五、CSS初始化" class="headerlink" title="五、CSS初始化"></a>五、CSS初始化</h2><p><strong>浏览器 CSS 样式初始化：</strong></p><ul><li>若要求不高追求方便可以直接：</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">*</span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>normalize.css</p></li><li><p>reset.css</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配方案汇总</title>
      <link href="/2022/04/15/06.yi-dong-duan-gua-pei/"/>
      <url>/2022/04/15/06.yi-dong-duan-gua-pei/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>由于屏幕尺寸<strong>、</strong>分辨率不同，还要考虑横竖屏问题，为了使 web 页面在不同移动设备上适配，需要在开发过程中使用合理的适配方案。</p><p>早期网页设计采用<strong>静态布局</strong>，通过<code>&lt;meta&gt;</code>标签中的<code>applicable-device</code>设备标识识别移动设备，即<code>&lt;meta name = 'applicable-device' content = 'mobile'&gt;</code>，在<code>&lt;meta&gt;</code>标签中的<code>viewport</code>标签中设置<code>width</code>，通过<code>js</code>动态修改标签的<code>initial-scale</code>使得页面等比缩放刚好占满屏幕。静态布局各个元素采用<code>px</code>为单位，这种方案实现简单，不存在兼容性问题，但用户体验很不友好。</p><p>后面出现了<strong>流式布局</strong>，使用百分比<code>%</code>定义宽度，高度使用<code>px</code>固定，根据可视区域的大小实时进行尺寸调整，通常使用<code>max-width/min-width</code>控制尺寸范围过大或者过小。这种方案实现比较简单，但在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化。</p><p>为了适应不同页面字体大小展现问题，出现了<strong>弹性布局</strong>。这种布局方案下，包裹文字的元素的尺寸采用<code>em/rem</code>为单位，页面主要划分区域依据情况使用<code>px</code>、百分数或者<code>em/rem</code>。如一些高校的网站，页面的主要划分区域使用<code>px</code>和百分比，包裹文字的元素和文字采用<code>em</code>。</p><p>上面几种方案，页面元素的大小按照屏幕分辨率进行适配调整，但整体布局不变，对于<strong>响应式web设计</strong>，网页布局会随着访问它的视口及设备的不同从而呈现不同的样式，在实现上会以上多种方案相结合，搭配<strong>媒体查询</strong>，使得一个页面在多个终端 (PC, mobile, pad) 呈现满意效果。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><h3 id="2-1-像素"><a href="#2-1-像素" class="headerlink" title="2.1 像素"></a>2.1 像素</h3><h4 id="px-pixel"><a href="#px-pixel" class="headerlink" title="px (pixel)"></a>px (pixel)</h4><p><strong>像素，（物理像素/设备像素），是分辨率的尺寸单位，用来显示图像的基本单元。</strong>不同分辨率下相同长度的<code>px</code>显示会不一样，因为像素点的个数相同情况下，不同分辨率下每个像素点对应像素宽度不同。同样是<code>14px</code>大小的字，在<code>1366×768</code>显示屏下会显示小些，在<code>1024×768</code>显示屏下会相对大。</p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p><strong>分辨率：</strong>屏幕上纵横的像素点。</p><h4 id="CSS-像素"><a href="#CSS-像素" class="headerlink" title="CSS 像素"></a>CSS 像素</h4><p><strong>逻辑像素(逻辑分辨率) = 设备独立像素(DIP) = CSS像素：是非真实存在的，代码中用来衡量页面内容的大小。</strong>不同屏幕上，<code>css</code>像素呈现的物理尺寸一致，但<code>css</code>像素对应的物理像素具数不同。标准的显示密度下，<code>1</code>个<code>css</code>像素对应一个物理像素，缩放时，<code>1</code>个<code>css</code>像素对应的物理像素会减增。</p><h4 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h4><p><strong>物理像素(物理分辨率) = 设备像素(DP) ：</strong> 设备屏幕的显示单位，设计图一般给的是物理分辨率</p><h4 id="PPI-pixel-per-inch"><a href="#PPI-pixel-per-inch" class="headerlink" title="PPI (pixel per inch)"></a>PPI (pixel per inch)</h4><p><strong>屏幕像素密度(ppi)：</strong>屏幕每英寸可显示像素点的数量，与之类似的还有dpi。值越高，显示画面细节越丰富。计算公式为：</p><p><img src="2.1.1.png"></p><p>其中 <strong>W</strong> 和 <strong>H</strong> 是分辨率的宽高，<strong>S</strong> 是屏幕尺寸。</p><h4 id="DPI-dot-per-inch"><a href="#DPI-dot-per-inch" class="headerlink" title="DPI (dot per inch)"></a>DPI (dot per inch)</h4><p>打印设备每英寸印刷出来的点有多少个，值越高，图片越细腻。</p><h4 id="DPR-devicePixelRatio"><a href="#DPR-devicePixelRatio" class="headerlink" title="DPR (devicePixelRatio)"></a>DPR (devicePixelRatio)</h4><p><strong>设备像素比</strong>，即：</p><p><img src="2.1.2.png"></p><p>指用多少个物理像素来渲染一个css像素。js中通过<code>window.devicePixelRatio</code>获取，css中通过<code>-webkit-device-pixel-ratio</code>,<code>-webkit-min-device-pixel-ratio</code>,<code>-webkit-max-device-pixel-ratio</code>进行媒体查询。</p><p>dpr 的出现是苹果在 iphone4 产品中推出了所谓的 retina 视网膜屏幕。因为屏幕的 ppi 太高，达到了人类视网膜的分辨极限。它在保持屏幕大小尺寸不变的情况下将它物理分辨率提高了一倍，在同样大小的屏幕上，像素多了一倍。</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>大小<strong>取决于当前对象的 font-size</strong>，未设置的话则 1 em 默认为 16 px，此时 10 px = 0.625 em。</p><p>换算:</p><blockquote><p>1em = 16px =&gt; 62.5%em = 10px</p></blockquote><p>需要在 css 中的 body 选择器中声明 font-size = 62.5% ，使 1 em = 10 px，再把之前的 px 数值除以 10，然后换上 em 作为单位。</p><p>特点:</p><ol><li>em 的值并不是固定的,em <strong>会继承父级元素的字体大小</strong></li><li>比如要设置 p 标签内的文本为 12 px,但包裹 p 标签的 #content 中已经声明了 font-size = 1.2 em,在声明 p 的字体大小时就只能是 1 em</li></ol><h4 id="rem-root-em"><a href="#rem-root-em" class="headerlink" title="rem (root em)"></a>rem (root em)</h4><p>CSS3 新增的一个单位，<strong>相对于 HTML 根元素 font-size</strong> 。</p><p>特点:</p><ol><li>修改根元素大小比例地调整所有字体大小，避免了字体大小的逐层复合。</li><li>对于 IE8 及更早版本不兼容。</li></ol><h4 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h4><p>CSS3 引入与视口有关的新单位：<strong>vw 表示相对于视口的宽度，vh 表示相对于视口高度</strong>。</p><p>平时拿到的设计图是基于 px ，怎么将 px 转为 vw 呢？</p><p><strong>vw 单位换算：</strong>视口宽度为 100 vw 占满整个视口区域，1 vw 相当于占整个视口宽度的 1%，所以 375 px = 100 vw =&gt; 1 px = 1/375*100  vw</p><p>所有页面元素都可换算成 vw 单位，但和百分比方案计算类似，会比较麻烦。</p><p>用插件 postcss-px-to-viewport，来预处理 CSS，将 px 转换为 vw，需要进行一些相关 Webpack 配置：</p><pre><code>{  loader: 'postcss-loader',  options: {​      plugins: ()=&gt;[​        require('autoprefixer')({​            browsers: ['last 5 versions']​        }),​        require('postcss-px-to-viewport')({​            viewportWidth: 375,​            viewportHeight: 1334,​            unitPrecision: 3,​            viewportUnit: 'vw',​            selectorBlackList: ['.ignore', '.hairlines'],​        minPixelValue: 1,​        mediaQuery: false​        })​      ]}</code></pre><p>优点：</p><ol><li> vw \ vh相对于视口的宽高，通过 postcss-px-to-viewport 插件进行单位转换比较方便。</li></ol><p>缺点：</p><ol><li>直接进行单位换算时百分比可能出现小数。</li><li>兼容性 - ie11和少数低版本手机系统 ios8、android4.4 以下不支持。</li></ol><h3 id="2-2-视口"><a href="#2-2-视口" class="headerlink" title="2.2 视口"></a>2.2 视口</h3><meta>标签中定义了一些元数据信息，通过设置<meta name="viewport">，提供有关 视口初始大小 的信息，供移动设备 使用。属性值为：<table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>width</code></td><td align="center">数值 / <code>device-width</code></td><td align="center">视口宽度</td></tr><tr><td align="center"><code>height</code></td><td align="center">数值 / <code>device-height</code></td><td align="center">视口高度</td></tr><tr><td align="center"><code>initial-scale</code></td><td align="center">0.0 ~ 10.0</td><td align="center">设备宽度与视口大小之间的缩放比率</td></tr><tr><td align="center"><code>maximum-scale</code></td><td align="center">0.0 ~ 10.0</td><td align="center">缩放最大值</td></tr><tr><td align="center"><code>minimum-scale</code></td><td align="center">0.0 ~ 10.0</td><td align="center">缩放最小值</td></tr><tr><td align="center"><code>user-scalable</code></td><td align="center">布尔值</td><td align="center">默认<code>yes</code>，为<code>no</code>时用户不能缩放网页</td></tr></tbody></table><p>移动端涉及<strong>布局视口</strong>（Layout Viewport）、<strong>视觉视口</strong>（Visual ViewPort）和<strong>理想视口</strong>（Ideal ViewPort）。</p><ul><li><strong>布局视口</strong>指用视口元标签（viewport meta）来进行布局视口设置，<code>css</code>布局是相对于布局视口计算。</li><li><strong>视觉视口</strong>指用户当前看到的区域。</li><li><strong>理想视口</strong>指屏幕分辨率的值，通过设置 <code>&lt;meta name = "viewport" content = "width = device-width， initial-scale = 1.0"&gt;</code>实现。</li></ul><h3 id="2-3-手机屏幕特性"><a href="#2-3-手机屏幕特性" class="headerlink" title="2.3 手机屏幕特性"></a>2.3 手机屏幕特性</h3><h4 id="像素分辨率"><a href="#像素分辨率" class="headerlink" title="像素分辨率"></a>像素分辨率</h4><p>硬件所支持的，屏幕每行的像素<code>*</code>每列的像素点数，单位是<code>px</code>。</p><h4 id="逻辑分辨率"><a href="#逻辑分辨率" class="headerlink" title="逻辑分辨率"></a>逻辑分辨率</h4><p>设备独立的，软件可以达到的，个人理解是使得软件/页面在不同屏幕上显示出来的效果一致。</p><h4 id="倍率"><a href="#倍率" class="headerlink" title="倍率"></a>倍率</h4><p>像素分辨率<code>÷</code>逻辑分辨率等于<strong>倍率</strong>，如<code>@3x</code>表示分辨率的<code>3</code>倍。一个已知物理像素大小的元素，如果在普通屏中其设备像素等于<code>css</code>像素，但在一些高清屏中，如 <strong>Retina</strong> 显示屏，一个css像素对应<code>2</code>或<code>3</code>个设备像素，这时显示出来的元素会变小。为了让元素如期待显示，需要传入<strong>原始设计稿尺寸<code>×</code>倍率</strong>的设计稿，根据 <strong>DPR</strong> 的定义，这样加载后能够达到同样的效果。</p><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><p>手机屏幕对角线长度换算成英寸的大小</p><h2 id="三、适配方案"><a href="#三、适配方案" class="headerlink" title="三、适配方案"></a>三、适配方案</h2><h3 id="3-1-百分比方案"><a href="#3-1-百分比方案" class="headerlink" title="3.1 百分比方案"></a>3.1 百分比方案</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>使用 <strong>百分比%</strong> 定义 <strong>宽度</strong>，<strong>高度</strong> 用**<code>px</code>**固定，根据可视区域实时尺寸进行调整，尽可能适应各种分辨率，通常使用<code>max-width</code>/<code>min-width</code>控制尺寸范围过大或者过小。下表是子元素不同属性设置百分比的依据</p></blockquote><table><thead><tr><th align="left">属性</th><th align="left">设置参考</th></tr></thead><tbody><tr><td align="left"><code>height</code>/<code>width</code></td><td align="left">基于子元素的直接父元素，<code>width</code>相对于父元素的<code>width</code>，<code>height</code>相对于父元素的<code>height</code></td></tr><tr><td align="left"><code>top</code>/<code>bottom</code> 和<code>left</code>/<code>right</code></td><td align="left">相对于直接非<code>static</code>定位的父元素的<code>height</code>/<code>width</code></td></tr><tr><td align="left"><code>padding</code>/<code>margin</code></td><td align="left">不论是垂直方向或者是水平方向，都相对于直接父亲元素的<code>width</code>，与父元素的<code>height</code>无关。</td></tr><tr><td align="left"><code>border-radius</code></td><td align="left">相对于自身的宽度</td></tr></tbody></table><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><blockquote><p>简单，不存在兼容问题</p></blockquote><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><blockquote><ul><li>如果屏幕尺度跨度太大，相对设计稿过大或者过小的屏幕不能正常显示，在大屏手机或横竖屏切换场景下可能会导致页面元素被拉伸变形，字体大小无法随屏幕大小发生变化。</li><li>设置盒模型的不同属性时，其百分比设置的参考元素不唯一，容易使布局问题变得复杂</li></ul></blockquote><h3 id="3-2-rem-方案"><a href="#3-2-rem-方案" class="headerlink" title="3.2 rem 方案"></a>3.2 rem 方案</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote><p><strong>rem</strong> 是相对长度单位，rem方案中的样式设计为相对于 <strong>根元素</strong> <code>font-size</code>计算值的倍数。根据 <strong>屏幕宽度</strong> 设置<code>html</code>标签的<code>font-size</code>，在布局时使用 <strong>rem</strong> 单位布局，达到自适应的目的，是 <strong>弹性布局</strong> 的一种实现方式。</p></blockquote><blockquote><p><strong>实现过程：</strong>  首先获取文档根元素和设备<code>dpr</code>，设置 <strong>rem</strong>，在<code>html</code>文档加载和解析完成后调整<code>body</code>字体大小； 在页面<strong>缩放 / 回退 / 前进</strong>的时候， 获取元素的内部宽度 (不包括垂直滚动条，边框和外边距)，重新调整 <strong>rem</strong> 大小。</p></blockquote><blockquote><p><strong>实现方法：</strong>用 <strong>css</strong> 处理器或 <strong>npm</strong> 包将页面 <strong>css</strong> 样式中的<code>px</code>自动转换成 <strong>rem</strong>。在整个 <strong>flexible</strong> 适配方案中，文本使用<code>px</code>作为单位，使用<code>[data-dpr]</code>属性来区分不同<code>dpr</code>下的文本字号。由于手机浏览器对字体显示最小是<code>8px</code>，因此对于小尺寸文字需要采用<code>px</code>为单位，防止通过 <strong>rem</strong> 转化后出现显示问题。<strong>手机淘宝</strong>中的字体使用<code>px</code>为单位，<strong>腾讯新闻</strong>中的字体使用<code>rem</code>为单位。</p></blockquote><p><strong>贴上源码分析：</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>win<span class="token punctuation">,</span> lib<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> doc <span class="token operator">=</span> win<span class="token punctuation">.</span>document<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//当前文档对象</span>    <span class="token keyword">var</span> docEl <span class="token operator">=</span> doc<span class="token punctuation">.</span>documentElement<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//文档对象根元素的只读属性</span>    <span class="token keyword">var</span> metaEl <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'meta[name="viewport"]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> flexibleEl <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'meta[name="flexible"]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> dpr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> scale <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> tid<span class="token punctuation">;</span>    <span class="token keyword">var</span> flexible <span class="token operator">=</span> lib<span class="token punctuation">.</span>flexible <span class="token operator">||</span> <span class="token punctuation">(</span>lib<span class="token punctuation">.</span>flexible <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>metaEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//当meta中viewport的标签设置了scale时，将根据scale手动设置dpr</span>        console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'将根据已有的meta标签来设置缩放比例'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> match <span class="token operator">=</span> metaEl<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/initial\-scale=([\d\.]+)/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>match<span class="token punctuation">)</span> <span class="token punctuation">{</span>            scale <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>match<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dpr <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> scale<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>flexibleEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//当meta中flexible的标签存在时，据此设置dpr</span>        <span class="token keyword">var</span> content <span class="token operator">=</span> flexibleEl<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> initialDpr <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/initial\-dpr=([\d\.]+)/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> maximumDpr <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/maximum\-dpr=([\d\.]+)/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>initialDpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dpr <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>initialDpr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                scale <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> dpr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maximumDpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                dpr <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>maximumDpr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                scale <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> dpr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dpr <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//根据js获取到的devicePixelRatio设置dpr及scale，scale是dpr的倒数</span>        <span class="token keyword">var</span> isAndroid <span class="token operator">=</span> win<span class="token punctuation">.</span>navigator<span class="token punctuation">.</span>appVersion<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/android/gi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> isIPhone <span class="token operator">=</span> win<span class="token punctuation">.</span>navigator<span class="token punctuation">.</span>appVersion<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/iphone/gi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> devicePixelRatio <span class="token operator">=</span> win<span class="token punctuation">.</span>devicePixelRatio<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isIPhone<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// iOS下，对于2和3的屏，分别用2和3倍方案</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>devicePixelRatio <span class="token operator">>=</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>dpr <span class="token operator">||</span> dpr <span class="token operator">>=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                dpr <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>devicePixelRatio <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>dpr <span class="token operator">||</span> dpr <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dpr <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                dpr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 其他设备下，仍旧使用1倍的方案</span>            dpr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        scale <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> dpr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    docEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'data-dpr'</span><span class="token punctuation">,</span> dpr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//文本字号不建议使用rem，flexible适配方案中，文本使用px作为单位，使用[data-dpr]属性来区分不同dpr下的文本字号</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>metaEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//添加meta标签，设置name为viewport，content根据scale设置缩放比(默认、最大、最小缩放比)</span>        metaEl <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'meta'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        metaEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'viewport'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        metaEl<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">,</span> <span class="token string">'initial-scale='</span> <span class="token operator">+</span> scale <span class="token operator">+</span> <span class="token string">', maximum-scale='</span> <span class="token operator">+</span> scale <span class="token operator">+</span> <span class="token string">', minimum-scale='</span> <span class="token operator">+</span> scale <span class="token operator">+</span> <span class="token string">', user-scalable=no'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>docEl<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>            docEl<span class="token punctuation">.</span>firstElementChild<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>metaEl<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> wrap <span class="token operator">=</span> doc<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            wrap<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>metaEl<span class="token punctuation">)</span><span class="token punctuation">;</span>            doc<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>wrap<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">refreshRem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//更新rem值</span>        <span class="token keyword">var</span> width <span class="token operator">=</span> docEl<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>width <span class="token operator">/</span> dpr <span class="token operator">></span> <span class="token number">540</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            width <span class="token operator">=</span> <span class="token number">540</span> <span class="token operator">*</span> dpr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> rem <span class="token operator">=</span> width <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1rem = viewWidth / 10</span>        docEl<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> rem <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>        flexible<span class="token punctuation">.</span>rem <span class="token operator">=</span> win<span class="token punctuation">.</span>rem <span class="token operator">=</span> rem<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//resize与pageshow延时300ms触发refreshRem(),使用防抖函数，防止事件被高频触发可能引起性能问题</span>    win<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'resize'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>        tid <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>refreshRem<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'pageshow'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//当一条会话历史纪录被执行的时候触发事件，包括后退/前进按钮，同时会在onload页面触发后初始化页面时触发</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>persisted<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//表示网页是否来自缓存</span>            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>tid<span class="token punctuation">)</span><span class="token punctuation">;</span>            tid <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>refreshRem<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在html文档加载和解析完成后设置body元素字体大小</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token string">'complete'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        doc<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token number">12</span> <span class="token operator">*</span> dpr <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        doc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            doc<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token number">12</span> <span class="token operator">*</span> dpr <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//浏览器有最小字体限制，css在pc上font-size是12px(移动端最小是8px), 也就是css像素是12，其DPR为1，在移动端dpr有可能为2和3，为了保证字体不变小，需要用12*dpr进行换算。</span>       <span class="token function">refreshRem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//实现rem与px相互转换</span>    flexible<span class="token punctuation">.</span>dpr <span class="token operator">=</span> win<span class="token punctuation">.</span>dpr <span class="token operator">=</span> dpr<span class="token punctuation">;</span>    flexible<span class="token punctuation">.</span>refreshRem <span class="token operator">=</span> refreshRem<span class="token punctuation">;</span>    flexible<span class="token punctuation">.</span>rem2px <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> val <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>rem<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> d <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/rem$/</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            val <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'px'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    flexible<span class="token punctuation">.</span>px2rem <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> val <span class="token operator">=</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>rem<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> d <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/px$/</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            val <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">'rem'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> window<span class="token punctuation">[</span><span class="token string">'lib'</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>window<span class="token punctuation">[</span><span class="token string">'lib'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><blockquote><p>兼容性好</p></blockquote><ul><li><p>ios: 6.1系统以上都支持</p></li><li><p>android: 2.1系统以上都支持</p></li><li><p>大部分主流浏览器都支持</p><p><img src="3.2.png"></p></li></ul><blockquote><ul><li>相较于之前的静态布局和百分比方案，页面不会因为伸缩发生变形，自适应效果更佳。</li></ul></blockquote><h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4><blockquote><ul><li><strong>不是纯css移动适配方案，需要引入js脚本</strong> 在头部内嵌一段 <code>js</code>脚本 <strong>监听分辨率的变化来动态改变根元素的字体大小</strong>，<code>css</code>样式和 <code>js</code> 代码有一定 <strong>耦合性</strong>，并且必须将改变<code>font-size</code>的代码放在 <strong>css</strong> 样式之前。</li><li><strong>小数像素问题：</strong>通过 <strong>rem</strong> 计算后可能会出现小数像素，浏览器会对这部分小数四舍五入，按照整数渲染。浏览器在渲染时所做的摄入处理只是应用在元素的尺寸渲染上，其真实占据的空间依旧是原始大小。也就是说如果一个元素尺寸是 <code>0.625px</code>，那么其渲染尺寸应该是 <code>1px</code>，空出的 <code>0.375px</code> 空间由其临近的元素填充；同样道理，如果一个元素尺寸是 <code>0.375px</code>，其渲染尺寸就应该是<code>0</code>，但是其会占据临近元素 <code>0.375px</code> 的空间。会导致：<strong>缩放到低于<code>1px</code>的元素时隐时现</strong>（解决办法：指定最小转换像素，对于比较小的像素，不转换为 <strong>rem</strong> 或 <strong>vw</strong>）；两个同样宽度的元素因为各自周围的元素宽度不同，导致两元素相差<code>1px</code>；宽高相同的正方形，长宽不等了；<code>border-radius: 50%</code> 画的圆不圆。</li><li><strong>Android 浏览器下 line-height 垂直居中偏离的问题</strong>。常用的垂直居中方式就是使用line-height，这种方法在Android设备下并不能完全居中。</li><li><strong>cursor: pointer 元素点击背景变色的问题</strong>，对添加了 cursor:pointer 属性的元素，在移动端点击时，背景会高亮。为元素添加<code>tag-highlight-color:transparent</code> 属性可以隐藏背景高亮。</li></ul></blockquote><h3 id="3-3-vh-vw-方案"><a href="#3-3-vh-vw-方案" class="headerlink" title="3.3 vh / vw 方案"></a>3.3 vh / vw 方案</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p><strong>视口</strong>是浏览器中用于呈现网页的区域，移动端的视口通常指的是 <strong>布局视口</strong></p><ul><li><strong>vw</strong> : <strong>1vw</strong> 等于 <strong>视口宽度</strong> 的 <strong>1%</strong></li><li><strong>vh</strong> : <strong>1vh</strong>  等于 <strong>视口高度</strong> 的 **1% **</li><li><strong>vmin</strong> : 选取 <strong>vw</strong> 和 <strong>vh</strong> 中 <strong>最小</strong> 的那个</li><li><strong>vmax</strong> : 选取 <strong>vw</strong> 和 <strong>vh</strong> 中 <strong>最大</strong> 的那个</li></ul><p>使用 <strong>css</strong> 预处理器把设计稿尺寸转换为 <strong>vw</strong> 单位，包括 <strong>文本</strong>，<strong>布局高宽</strong>，<strong>间距</strong> 等，使得这些元素能够随视口大小自适应调整。以<code>1080px</code>设计稿为基准，转化的计算表示为：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 以1080px作为设计稿基准</span>$vw_base<span class="token punctuation">:</span> <span class="token number">1080</span>@<span class="token keyword">function</span> <span class="token function">vw</span><span class="token punctuation">(</span>$px<span class="token punctuation">)</span> <span class="token punctuation">{</span>    @<span class="token keyword">return</span><span class="token punctuation">(</span>$px <span class="token operator">/</span> <span class="token number">1080</span><span class="token punctuation">)</span> <span class="token operator">*</span> 100vw<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><blockquote><ul><li>纯 <strong>css</strong> 移动端适配方案，不存在脚本依赖问题。</li><li>相对于 <strong>rem</strong> 以<strong>根元素字体大小的倍数</strong> 定义 <strong>元素大小</strong>，逻辑清晰简单，视口单位依赖于视口的尺寸 <code>"1vw ＝ 1/100 viewport width"</code>，根据 <strong>视口尺寸的百分比</strong> 来定义 <strong>元素宽度</strong>。</li></ul></blockquote><h4 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h4><blockquote><ul><li>存在一些兼容性问题，Android4.4以下不支持</li></ul></blockquote><p><img src="3.3.png"></p><h3 id="3-4-rem-vw-vh-方案"><a href="#3-4-rem-vw-vh-方案" class="headerlink" title="3.4 rem + vw / vh 方案"></a>3.4 rem + vw / vh 方案</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><blockquote><p><strong>vw / vh</strong>  方案能够实现宽度和高度的自适应，并且逻辑清晰，由于其被支持得较晚，所以存在一定的兼容性问题。将  <strong>vw/vh</strong>  方案与 <strong>rem</strong> 方案相结合，<strong>给根元素设置随视口变化的 vw 单位</strong>，可以通过 <code>postcss-plugin-vwtorem</code> 将其转换。具体的<strong>计算过程</strong>为：</p></blockquote><blockquote><p>对于<code>1080px</code>宽的设计稿，设置默认根字号的大小为<code>100px</code>，那么设计稿中<code>1px</code>对应的是 <code>100vw/1080 = 0.0925926vw</code>，并且 <code>1rem = 100px</code>，也就可以得到<code>1rem = 9.256926vw</code></p></blockquote><blockquote><p>同时可以使用媒体查询限制根元素的最大最小值，实现对页面的最大最小宽度限制，对用户的视觉体验更好。</p></blockquote><h4 id="实用性"><a href="#实用性" class="headerlink" title="实用性"></a>实用性</h4><blockquote><p><strong>rem</strong> 弹性布局方式作为移动端web页面适配方法，后期从 <strong>rem</strong> 过渡到 <strong>vw</strong> ，只需要通过 <strong>改变根元素大小的计算方式</strong> 不需要其他处理。<strong>vw</strong> 将会成为一种更好的适配方式，目前由于兼容性的原因得不到广泛应用。<strong>rem + vw / vh</strong>  不存在 <strong>vw/vh</strong> 的兼容性问题，可以成为由 <strong>rem</strong> 向 <strong>vw / vh</strong> 转变的一种过渡方案。</p></blockquote><h3 id="3-5-基于媒体查询的响应式设计"><a href="#3-5-基于媒体查询的响应式设计" class="headerlink" title="3.5 基于媒体查询的响应式设计"></a>3.5 基于媒体查询的响应式设计</h3><p><strong>响应式设计</strong> 使得一个网站同时适配 <strong>多种设备</strong> 和 <strong>多个屏幕</strong>，让网站的布局和功能随用户的使用环境（屏幕大小、输出方式、设备/浏览器能力而变化），使其视觉合理，交互方式符合习惯。如使得内容区块可伸缩与自由排布，边距适应页面尺寸，图片适应比例变化，能够自动隐藏/部分显示内容等。</p><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><blockquote><p>主要实现是通过 <strong>媒体查询</strong>，通过给不同分辨率的设备编写不同的样式实现响应式布局，用于解决不同设备不同分辨率之间兼容问题，一般是指PC、平板、手机设备之间较大的分辨率差异。实现上不局限于具体的方案，通常结合了 <strong>流式布局</strong> <code>+</code> <strong>弹性布局</strong> 方案。比如给小屏幕手机设置 <code>@2x</code> 图，为大屏手机设置 <code>@3x</code> 图</p></blockquote><pre class="line-numbers language-javascript"><code class="language-javascript">@media only screen and <span class="token punctuation">(</span>min<span class="token operator">-</span>width<span class="token punctuation">:</span> 375px<span class="token punctuation">)</span><span class="token punctuation">{</span>    样式<span class="token number">1</span><span class="token punctuation">}</span>@media only screen and <span class="token punctuation">(</span>min<span class="token operator">-</span>width<span class="token punctuation">:</span> <span class="token number">750</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    样式<span class="token number">2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><blockquote><p>能够使网页在不同设备、不同分辨率屏幕上呈现合理布局，不仅仅是样式伸缩变换</p></blockquote><h4 id="不足-3"><a href="#不足-3" class="headerlink" title="不足"></a>不足</h4><blockquote><ul><li>要匹配足够多的设备与屏幕，一个web页面需要多个设计方案，工作量比较大</li><li>通过媒体查询技术需要设置一定量的断点，到达某个断点前后的页面发生显著变化</li></ul></blockquote><h2 id="四、移动端web页面适配方案中的通用问题"><a href="#四、移动端web页面适配方案中的通用问题" class="headerlink" title="四、移动端web页面适配方案中的通用问题"></a>四、移动端web页面适配方案中的通用问题</h2><h3 id="4-1-像素问题"><a href="#4-1-像素问题" class="headerlink" title="4.1 像素问题"></a>4.1 像素问题</h3><blockquote><p>设置边框 为<code>1px</code> <strong>css</strong>像素，在 <strong>普通屏幕</strong> 下<code>1px</code>，<strong>高清屏幕</strong> (<code>dpr</code>为<code>2</code>)下<code>2px</code>的情况。是由于不同移动设备的<code>dpr</code>不同，导致<code>1px</code> <strong>css</strong>像素，转换成物理像素后显示不一样。</p></blockquote><h4 id="4-1-1-设置scale-为-1-dpr"><a href="#4-1-1-设置scale-为-1-dpr" class="headerlink" title="4.1.1 设置scale 为 1/dpr"></a>4.1.1 设置scale 为 1/dpr</h4><blockquote><p><strong>css</strong> 中涉及<code>1</code>像素的地方仍然使用<code>px</code>作为单位，设置<code>&lt;meta&gt;</code> 标签中 <code>initial-scale = 1/dpr</code> ，将整个页面缩小<code>dpr</code>倍，对于页面采用 <strong>rem</strong> 方案的情况，将页面的 <strong>根字体</strong> 再放大<code>dpr</code>倍，这个时候就能够在不改变页面其他布局的情况下，保持边框的 <strong>css</strong> 像素为<code>1px</code>。</p></blockquote><h4 id="4-1-2-transform-的-scale-属性"><a href="#4-1-2-transform-的-scale-属性" class="headerlink" title="4.1.2 transform 的 scale 属性"></a>4.1.2 transform 的 scale 属性</h4><blockquote><p><code>transform</code>的<code>scale</code>属性允许对元素进行缩放，其中<code>scaleY(y)</code>通过设置Y轴的值来定义缩放转换，并结合伪元素使用，通过<code>transform-origin: 50% 0%</code>修改元素变换的中心点实现。针对横着的边框线用<code>scaleY(y)</code>，针对竖着的边框线要用<code>scaleX(x)</code>，针对一圈的边框线用<code>scale()</code>，并且需要注意转移元素变换中心点。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token selector">//针对竖着的边框线<span class="token class">.className:</span> before </span><span class="token punctuation">{</span>  //其他样式  <span class="token property">transform-origin</span><span class="token punctuation">:</span> <span class="token number">50%</span> <span class="token number">0%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@media</span> only screen and <span class="token punctuation">(</span><span class="token property">-webkit-min-device-pixel-ratio</span><span class="token punctuation">:</span> 2<span class="token punctuation">)</span></span> <span class="token punctuation">{</span> <span class="token selector">//dpr为2时  <span class="token class">.className:</span> before </span><span class="token punctuation">{</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleY</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@media</span> only screen and <span class="token punctuation">(</span><span class="token property">-webkit-min-device-pixel-ratio</span><span class="token punctuation">:</span> 3<span class="token punctuation">)</span></span> <span class="token punctuation">{</span> <span class="token selector">//dpr为3时  <span class="token class">.className:</span> before </span><span class="token punctuation">{</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleY</span><span class="token punctuation">(</span><span class="token number">0.33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-border-image-属性"><a href="#4-1-3-border-image-属性" class="headerlink" title="4.1.3 border-image 属性"></a>4.1.3 border-image 属性</h4><blockquote><p>使用<code>border-image</code>，在元素的边框上设置一个一半透明一半显示的图片。</p></blockquote><h3 id="4-2-对图片的处理"><a href="#4-2-对图片的处理" class="headerlink" title="4.2 对图片的处理"></a>4.2 对图片的处理</h3><blockquote><p>加载网页时，平均<code>60%</code>以上的流量来自 <strong>加载图片</strong>。指定图像宽度时使用<strong>相对单位</strong>，<strong>防止意外溢出视口</strong>，如 <code>width: 50%</code>，将图片宽度设置为包含元素宽度的 <code>50%</code>。因为 <strong>css</strong> 允许内容溢出容器， 需要使用**<code>max-width: 100%</code> 来保证图像及其他内容不会溢出<strong>。使用 img 元素的 <code>alt</code> 属性提供描述，描述有助于提高网站的可访问性，能提供语境给屏幕阅读器及其他辅助性技术。</strong>维护自适应页面中图片宽高比固定<strong>比较常用的方法是使用</strong><code>padding</code>**设置。对于不同<code>dpr</code>以及不同分辨率/尺寸的屏幕，为了避免资源浪费和等待时间延长，需要针对不同的屏幕使用合适的图片，加载的图片分为通过标签引入的图片和背景图片。</p></blockquote><h4 id="4-2-1-srcse-和-sizes"><a href="#4-2-1-srcse-和-sizes" class="headerlink" title="4.2.1 srcse 和 sizes"></a>4.2.1 srcse 和 sizes</h4><blockquote><p><strong>对于<code>&lt;img&gt;</code>引入的图片，如果想要图片适应不同像素密度的屏幕，并且屏幕上显示图片的实际尺寸相同，使用</strong><code>srcset</code><strong>属性用来指定多张图像。</strong>它的值是一个逗号分隔的字符串，每个部分都是一张图像的 URL，后面接一个空格，后接是像素密度描述符。浏览器根据当前设备的像素密度，选择需要加载的图像。如果<code>srcset</code>属性都不满足条件，那么就加载<code>src</code>属性指定的默认图像。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo-320w.jpg,             foo-480w.jpg 1.5x,             foo-640w.jpg 2x<span class="token punctuation">"</span></span>     <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>foo-640w.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token comment" spellcheck="true">&lt;!--srcset属性给出了三个图像URL，适应三种不同的像素密度， 后面的像素密度描述符，格式是像素密度倍数 + 字母x。1x表示单倍像素密度，可以省略。--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>如果想要针对不同屏幕，使用不同分辨率版本和尺寸的图片，使用属性<code>srcse</code> 和 <code>sizes</code> 。<a href="https://links.jianshu.com/go?to=https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images">srcset</a> 定义了允许浏览器选择的图像集，以及每个图像的大小（使用w单位）。<code>sizes</code>定义了一组媒体条件（例如屏幕宽度），指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。</strong></p></blockquote><pre class="line-numbers language-html"><code class="language-html">&lt;img srcset = "elva-fairy-320w.jpg 320w,               elva-fairy-480w.jpg 480w,               elva-fairy-800w.jpg 800w"     sizes = "(max-width: 320px) 280px,              (max-width: 480px) 440px,              800px"     src = "elva-fairy-800w.jpg" alt="Elva dressed as a fairy"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>浏览器的查询过程：</p></blockquote><ul><li>查看设备宽度；</li><li>检查<code>sizes</code>列表中哪个媒体条件是第一个为真；</li><li>查看给予该媒体查询的槽大小；</li><li>加载<code>srcset</code>列表中引用的最接近所选的槽大小的图像</li></ul><h4 id="4-2-2-异步加载"><a href="#4-2-2-异步加载" class="headerlink" title="4.2.2 异步加载"></a>4.2.2 异步加载</h4><blockquote><p><strong>&lt; img&gt; 引入的图片，使用js自带的异步加载图片。</strong>根据不同的<code>dpr</code>，加载不同分辨率的图片。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img<span class="token punctuation">"</span></span> <span class="token attr-name">data-src1x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx@1x.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">data-src2x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx@2x.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">data-src3x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xxx@3x.jpg<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> dpr <span class="token operator">=</span> window<span class="token punctuation">.</span>devicePixelRatio<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>dpr <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    dpr <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> imgSrc <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">'src'</span><span class="token operator">+</span>dpr<span class="token operator">+</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>img<span class="token punctuation">.</span>src <span class="token operator">=</span> imgSrc<span class="token punctuation">;</span>img<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>imgObj<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#img'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span>imgObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//替换img对象</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-3-picture"><a href="#4-2-3-picture" class="headerlink" title="4.2.3 picture"></a>4.2.3 picture</h4><blockquote><p><strong>为不同的视口提供不同的图片，使用<code>&lt;picture&gt;</code>标签。</strong><code>&lt;picture&gt;</code>是<code>html5</code>中定义的一个容器标签，内部使用<code>&lt;source&gt;</code>和<code>&lt;image&gt;</code>，<strong>浏览器会匹配<code>&lt;source&gt;</code>的<code>type</code>,<code>media</code>,<code>srcset</code>等属性，找到最适合当前布局 / 视口宽度 / 设备像素密度的图像进行加载。</strong>这里的<code>&lt;img&gt;</code>标签是浏览器不支持<code>picture</code>元素，或者支持<code>picture</code>但没有合适的媒体定义时的后备，不能省略。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(min-width: 30px)<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cat-vertical.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(min-width: 60px)<span class="token punctuation">"</span></span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cat-horizontal.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cat.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-4-Image-set"><a href="#4-2-4-Image-set" class="headerlink" title="4.2.4 Image-set"></a>4.2.4 Image-set</h4><blockquote><p><strong>对于背景图片，使用<code>image-set</code>根据用户设备的分辨率匹配合适的图像</strong>， 同时要考虑兼容性问题。</p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token selector"><span class="token class">.css</span> </span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(1x.png)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*不支持image-set的情况下显示*/</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">-image-set</span><span class="token punctuation">(</span>            <span class="token url">url(1x.png)</span> <span class="token number">1</span>x,<span class="token comment" spellcheck="true">/* 支持image-set的浏览器的[普通屏幕]下 */</span>            <span class="token url">url(2x.png)</span> <span class="token number">2</span>x,<span class="token comment" spellcheck="true">/* 支持image-set的浏览器的[2倍Retina屏幕] */</span>            <span class="token url">url(3x.png)</span> <span class="token number">3</span>x<span class="token comment" spellcheck="true">/* 支持image-set的浏览器的[3倍Retina屏幕] */</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-5-media-query"><a href="#4-2-5-media-query" class="headerlink" title="4.2.5 media query"></a>4.2.5 media query</h4><blockquote><p><strong>对于背景图片，使用媒体查询自动切换不同分辨率的版本</strong></p></blockquote><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css"><span class="token comment" spellcheck="true">/* 普通显示屏(设备像素比例小于等于1)使用1倍的图 */</span><span class="token selector"><span class="token class">.css</span></span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(img_1x.png)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 高清显示屏(设备像素比例大于等于2)使用2倍图  */</span><span class="token atrule"><span class="token rule">@media</span> only screen and <span class="token punctuation">(</span><span class="token property">min-device-pixel-ratio</span><span class="token punctuation">:</span>2<span class="token punctuation">)</span></span><span class="token punctuation">{</span>    <span class="token selector"><span class="token class">.css</span></span><span class="token punctuation">{</span>        <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(img_2x.png)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 高清显示屏(设备像素比例大于等于3)使用3倍图  */</span><span class="token atrule"><span class="token rule">@media</span> only screen and <span class="token punctuation">(</span><span class="token property">min-device-pixel-ratio</span><span class="token punctuation">:</span>3<span class="token punctuation">)</span></span><span class="token punctuation">{</span>    <span class="token selector"><span class="token class">.css</span></span><span class="token punctuation">{</span>        <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(img_3x.png)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><blockquote><p><strong>对于国内的一些网站，查看源码发现，它可能不是某一种方案的单独使用，而是多种方案的结合。一个页面上，元素的宽度设置上有百分比，也有<code>rem</code>，字体的样式中有<code>rem</code>，有<code>em</code>，还有固定大小的<code>px</code>，宽度缩放上也会用到媒体查询。当然，市场上对于适配问题已经有了大量成熟的 webpack 插件和 npm 包，本文的初衷在于了解设备适配的历史发展过程，秉着不要重复造轮子的原则建议大家直接用插件包也方便后续他人维护 (ಡωಡ)</strong></p><p><strong>各种方案的具体代码示例可以参考<a href="https://www.cnblogs.com/tylerdonet/p/10146632.html">这篇文章</a>。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高项论文范文汇总</title>
      <link href="/2021/10/29/05.gao-xiang-lun-wen-fan-wen-hui-zong/"/>
      <url>/2021/10/29/05.gao-xiang-lun-wen-fan-wen-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="一、整合（1500）"><a href="#一、整合（1500）" class="headerlink" title="一、整合（1500）"></a>一、整合（1500）</h2><p>一、  制定项目章程，正式启动项目。</p><p>​    在项目初期。我与客户代表等人跟据<strong>项目合同协议、项目工作说明书</strong>等，多次召开<strong>会议</strong>讨论，并邀请<strong>专家进行指导</strong>，编制了<strong>项目章程</strong>，最后由王总进行签发。在项目章程中，记录了项目的发起人和批准项目章程的各方代表的姓名权职，明确了<strong>项目的目的</strong>是为了实现传统景区向智慧景区升级转型的战略，<strong>项目的总体要求和成功交付标准</strong>是建设满足合同需求的智慧旅游管理系统，项目的总体预算额为596万元，建设工期为7个月，制定了<strong>里程碑进度计划以及项目的审批要求</strong>等。<strong>并任命我作为项目经理</strong>，授予了我调用研发部、工程部、采购部等相关人力资源的权责。该项目章程的发布，<strong>标志着项目的正式启动</strong>。</p><p>二、  制定项目管理计划，为项目的执行、监控、收尾提供依据。 </p><p>​    我根据上阶段的<strong>项目章程</strong>和公司的<strong>项目管理计划模板</strong>，编制了<strong>初步的项目管理计划</strong>，随后邀请行业<strong>专家</strong>、客户代表、团队成员等人以<strong>会议</strong>的形式，对项目涉及到的管理和技术进行细化，分别<strong>制定出成本、进度、范围管理等子计划</strong>（具体描述子计划，项目建设预计投入200万元，用于平台搭建，软硬件购买，技术支持及管理的费用），接着把各个子计划进行<strong>综合汇总成项目管理计划</strong>。考虑到开发过程中需求不是特别明确可能产生变更，该系统早期采用原型法进行开发。当然，项目管理计划的制定并不是一蹴而就的，它是一个<strong>渐进明细</strong>的过程，需要在项目实施过程中根据实际情况不断调整，为后续指导项目执行、监控和收尾提供依据。</p><p>三、  指导与管理项目工作，取得可交付成果。</p><p>​    项目管理计划编制完成后，我们进入项目实施阶段。我依据<strong>项目管理计划</strong>，要求团队成员每天提交<strong>工作日志</strong>，每周五召开内部工作<strong>总结会</strong>，汇报项目的进度、存在的问题，共同讨论解决方案，及时<strong>收集工作绩效数据</strong>，并在每月的<strong>干系人会议</strong>中，将项目<strong>进度、成本</strong>等绩效数据向各干系人进行<strong>汇报</strong>，听取他们的反馈，做出必要<strong>变更</strong>；每完成一个<strong>里程碑的可交付开发模块</strong>时，我都会邀请客户代表进行<strong>签字确认</strong>，保证产品的有效性。</p><p>四、管理项目知识，使用现有知识生成新知识，帮助组织积累学习</p><p>​    为了帮助组织积累学习，使用现有知识生成新知识。我高度重视项目知识的管理并采取了以下措施：一是<strong>创建知识库</strong>，从组织过程资产中提取经验教训放入知识库中，并随着项目进行不断完善；二是<strong>分享显性知识</strong>，邀请专家、优秀员工进行专题讲座，进行<strong>业务培训和技术培训</strong>；三是<strong>交流隐性知识</strong>，通过<strong>引导鼓励</strong>团队成员多沟通项目工作上的心得领悟，形成一种乐于分享的团队文化来推动隐性知识的交流，我将这些经验教训和知识分享的成果进行归纳总结后<strong>更新了组织过程资产</strong>。</p><p>五、监控项目工作，及时发现问题并解决。</p><p>​    有效的监控可以及时发现问题进行纠偏。我将<strong>监控</strong>工作<strong>贯穿项目始终</strong>。如对于代码质量的控制，我们每周召开<strong>代码评审会</strong>查看代码是否符合规范。对于进度和成本的控制，我主要采用<strong>挣值分析</strong>的方法，例如在项目中期的一次挣值分析中，CPI=1.13，SPI=0.97，可知项目目前处于成本节约、进度落后的状态，我通过根本原因分析，发现小组成员对于BI大屏开发经验不足，影响到开发进度，我立刻向公司研发部申请调配了一名技术骨干协助开发，项目进度赶上了原定计划，随后<strong>更新了经验教训登记册</strong>。</p><p>六、实施整体变更控制，降低变更的不利影响</p><p>​    我深知项目很少会完全按照项目管理计划进行，为了降低变更对项目进度成本带来不利影响，项目初期我们<strong>成立了由甲方、监理方和我方代表组成的项目控制委员会CCB</strong>，制定了如下变更控制流程：<strong>1.提出、接受变更申请 2.对变更初审 3.变更方案论证 4.CCB审查 5.发出变更通知并组织实施 6.变更实施监控 7.变更效果评估 8.判断变更后项目是否纳入正常轨道</strong>。例如在项目实施过程中，客户想添加游客互动功能，我组织项目团队<strong>开会讨论</strong>、进行成本效益分析，认为该需求可行，于是进行变更申请，在审批通过后我根据<strong>工作绩效报告</strong>，<strong>更新了进度管理计划、成本管理计划和范围管理计划等相关文件</strong></p><p>七、结束项目或阶段，项目收尾，释放资源。</p><p>​    经过大家7个月的共同努力完成了项目的所有工作，于是我依据<strong>项目管理计划</strong>，组织<strong>项目验收会</strong>。项目<strong>验收小组由本市旅游局领导、监理方和相关专家组成</strong>，对该系统给予了很高评价，我代表公司和甲方<strong>签署了系统移交确认书</strong>。随后我组织全体项目组成员召开<strong>项目总结大会</strong>，对项目实施过程中的经验教训进行了<strong>总结</strong>，<strong>形成文档</strong>存入经验教训知识库供未来项目使用，将合同协议的相关文件和项目文件归档，最后保留2名开发人员转入运维阶段并妥善解散了项目团队，正式结束了该项目。</p><h2 id="二、范围（1900）"><a href="#二、范围（1900）" class="headerlink" title="二、范围（1900）"></a>二、范围（1900）</h2><p>一、规划范围管理，为如何进行范围管理活动提供指南和方向</p><p>​    规划范围管理是决定如何进行范围管理活动和制定范围管理计划的过程，为整个项目中如何管理范围提供了指南和方向。我对此非常重视，在项目规划阶段我们便根据<strong>项目章程、项目管理计划、和公司PMO发布的范围管理计划模版</strong>等资料，多次开会讨论，并邀请行业专家进行指导和优化，最终形成了一份详细的范围管理计划。计划<strong>内容包括如何制定项目范围说明书，如何处理项目范围说明书的变更等，例如对范围说明书的变更必须走变更控制流程</strong>。</p><p>二、收集需求，为实现项目目标而确定、记录并管理干系人的需求</p><p>​    该过程是为实现目标而确定、记录并管理干系人需求的过程。在制定范围管理计划和需求管理计划后，我们<strong>根据范围管理计划、需求管理计划、干系人登记册</strong>等展开收集需求，我带领需求分析人员到客户现场，通过<strong>访谈、调查问卷、引导式研讨会</strong>等多种方式收集需求。但是，在客户需求描述不清时，双方容易产生分歧，如票务管理的订单跟踪流程到底应该怎么走，针对这种技术难度不高、分析层面大的问题，我采用了<strong>原型法</strong>，制作一个演示产品，便于与客户沟通，消除歧义，充分挖掘客户需求，对客户需求进行引导、细化，最终形成<strong>需求文件和需求跟踪矩阵</strong>。</p><p>三、定义范围，确认做且只做的事。</p><p>​    定义范围。该过程是制定项目和产品详细描述的过程，其主要作用是明确所收集的需求哪些将包含项目范围内，哪些将排除在项目范围外，从而明确产品的边界。<strong>我们根据范围管理计划和需求文件</strong>，组织了各干系人和专家进行产品分析，<strong>制定了范围说明书</strong>，对以下内容进行了详细的说明：项目的产品范围描述（例如系统的五大子系统等）、验收标准（例如功能满足需求、系统运行稳定、相关文档齐全等）、可交付成果（例如应用系统、相关文档等）、项目的除外责任（例如该项目涉及的机房建设不包含在该项目中）、制约因素、假设条件等。</p><p>四、创建工作分解结构，形成范围基准。</p><p>​    该过程是将项目可交付成果和项目工作分解成较小、更易于管理的组件的过程，对所要交付的内容提供一个结构化的视图。我们根据<strong>项目范围说明书</strong>，对项目范围进行了分解，考虑到该项目较大，<strong>采用表格形式的WBS</strong>表示形式，能够反映出项目所有的工作要素。在初步完成WBS分解工作后，我们请业务专家进行指导和优化，并得到所有干系人的确认。在本项目中，我们<strong>将项目生命周期的各个阶段作为分解的第二层</strong>，<strong>将项目可交付成果，例如五大子系统，放在第三层</strong>，确保WBS符合项目的范围，必须包含也仅包含为了完成项目的可交付成果的活动，（符合100%原则，即所有下一级的元素之和必须100%的代表上一级元素。WBS的底层不但要支持项目管理计划，而且要让管理层能够监视和控制项目的进度和预算，不可分解的过细或过粗。WBS中的元素必须有人负责，而且只由一个人负责，尽管实际上可能需要多人参与，即遵循独立责任原则）。当然，WBS并非一成不变的，在完成之后仍然有可能需要对其进行修改，即滚动分解原则。基于这些原则，最终制定出WBS和WBS词典，与<strong>项目范围说明书</strong>一起经批准后，形成项目的<strong>范围基准</strong>。（497字）</p><p>五、确认范围，验收可交付成果。 </p><p>​    该过程是正式验收项目已完成的可交付成果的过程，通过验收每个可交付成果，提高最终产品获得验收的可能性。在实际过程中，确认范围不是一件容易的事，客户认为他们已经把需求说明清楚了，他们希望尽快直接验收最后产品，没必要一步步做确认。针对这个问题我与客户做了深入的沟通，说明了范围确认的重要性，也解释了范围确认后并不是不能变更了，而是能及时发现问题、提出相应的变更，而不是等到最后时刻才发现，以此消除客户方的顾虑。为了提高范围确认的效率，<strong>我们会提前做好内部质量控制，将核实的可交付成果用于范围确认，并且搭建好演示环境，直观地展示可交付成果，</strong>然后邀请客户方和监理方代表参与范围确认会议，<strong>采用大多数原则的群体决策技术，对可交付成果进行验收</strong>，签署确认书，对会议上提出的变更，在初审论证可行走变更流程，从而顺利地进入下一阶段工作。（349字）</p><p>六、控制范围，维护范围基准。</p><p>​    该过程是监督范围状态，以便管理范围基准变更的过程，是在整个项目期间保持对范围基准的维护。在项目中，变更是不可避免的，（比如说政府政策变化，项目范围的计划编制不周密详细，市场上出现了或是设计人员提出了新技术，团队发生变化，）最常见的是客户对项目的要求发生变化，我们需要<strong>根据项目管理计划、需求文件</strong>等严格做好范围控制。例如，在项目中期，住建局陈局长向我提出希望在可视化大屏子系统中<strong>增加游客互动功能</strong>，我对此召集小组成员并邀请专家进行讨论，综合判断分析得出在不影响进度的情况下可以通过赶工实现该功能，需要增加人员成本，因此我与陈局对可行的方案进行沟通，达成一致意见。然后<strong>提交变更申请</strong>，严格按照变更流程进行变更，将项目范围控制在可控范围内。</p><h2 id="三、进度（1500）"><a href="#三、进度（1500）" class="headerlink" title="三、进度（1500）"></a>三、进度（1500）</h2><p>一、规划进度管理</p><p>该过程是决定如何进行项目进度管理活动并编写进度管理计划的过程，为整个项目的进度管理提供指南和方向。在项目启动后，我们根据项目章程、项目管理计划和公司PMO发布的进度管理计划模板，多次开会讨论，并邀请行业专家进行指导，制定了一份详细的进度管理计划。在该计划中，规定了关键链法作为制定项目进度模型的方法，人天数来作为测量工期的时间单位。（175字）</p><p>二、定义活动</p><p>该过程是识别和记录为完成项目可交付成果而需采取的所有活动，主要作用是将工作包分解为活动，作为对项目工作进行进度规划、执行和监控的基础。根据进度管理计划、范围基准，我们本着谁负责谁分解的原则，对工作包进行分解，得到具体要完成的活动，例如本项目中PC端水电过户表单填写功能开发，由该工作包负责人小王进行分解，分解成网页制作、脚本编写、对接接口三个活动，给这些活动做了编码和描述，最后跟其他活动汇总成活动清单。（203字）</p><p>三、排列活动顺序</p><p>该过程是识别和记录活动之间的关系的过程，定义工作之间的逻辑顺序，以便在制约因素下获得最高的效率。有了活动清单，通过确定依赖关系和前导图法，绘制项目进度网络图。在这过程中，最关键的就是确定各个活动之间的关系，能并列则并列，不能并列的要确定活动之间前后依赖关系和约束条件。例如，二手房房产过户功能需要对接房产交易所的业务接口，既相互依赖又相互独立，因而可以并行进行，但是在单元测试这个时间点上，需做好接口对接后才能进行测试。有了合理的活动网络图，才能制定出合理的进度计划。（244字）</p><p>四、估算活动资源</p><p>该过程是估算执行各项活动所需的材料、人员、设备或用品种类和数量的过程，以便做出更准确的成本和持续时间估算。为了保证项目执行过程中各项活动都有充足的资源条件，我组织召开项目成员会议，根据进度管理计划、活动清单等，采用自下而上的估算方法，对每一层活动所需的资源进行估算，最后将所有资源进行汇总统计，得到了详细的活动资源需求和资源分解结构。（172字）</p><p>五、估算活动持续时间</p><p>该过程是根据资源估算的结果，确定完成每个活动所需时间，为制定进度计划过程提供主要输入。估算的活动资源需求，特别是所分配的资源数量和质量能否达到要求，会对活动持续时间产生显著影响。例如，大数据分析功能模块涉及到的ETL技术，参与该功能开发的其中2位团队成员经验不足，因此需要增加沟通、培训和协调的工作，因此针对这个不确定性，我们进行了三点估算，如果能快速掌握并熟练运用新技术的话需要5天，如果遇到困难的话需要12天，但根据我对他们能力的判断，最有可能是7天，最后根据公式（a+4b+c）/6计算出该活动的持续时间为7.5天，得到了活动历时估算。（254字）</p><p>六、制定进度计划</p><p>该过程是分析活动顺序、资源需求、持续时间和进度制约因素，创建项目进度模型的过程。没有一个好的进度计划，项目就不可能如期的完成。因此我们特别注重对项目进度网络图、活动资源需求、活动历时估算等内容的分析，通过关键链法确定出了总工期，绘制了项目进度甘特图和项目进度模拟正态分布图，标出95%的置信区间，得到项目进度计划，然后我邀请各干系人和专家，对项目进度计划进行了评审，从而确定了进度基准。（194字）</p><p>七、控制进度</p><p>该过程是监督项目活动状态，更新项目进度，管理进度基准变更的过程，本过程的主要作用是及时发现偏差，以便采取纠正措施，降低风险。我依据进度管理计划，要求项目组成员提交工作日报，每周召开例会，汇报工作进展；每月进行挣值分析，收集进度绩效数据，进行偏差分析和趋势分析，形成进度绩效信息，编制进度绩效报告，提交给公司领导及甲方负责人，以便他们对项目进度有充分的了解。如果实际进度情况与进度基准发生偏差时，我们会通过变更控制流程对进度基准进行变更，以保证进度基线始终对进度管理具有指导作用。（226字）</p><h2 id="四、成本（1450）"><a href="#四、成本（1450）" class="headerlink" title="四、成本（1450）"></a>四、成本（1450）</h2><p>一、规划成本管理，为如何进行成本管理活动和制定成本管理计划提供指南和方向</p><p>​    规划成本管理是决定如何进行项目成本管理活动并编写成本管理计划的过程。因此，我对此非常重视，在项目启动后，我便带领团队成员以及客户代表等人根据<strong>项目章程、项目管理计划和公司PMO发布的成本管理计划模版</strong>，多次召开<strong>会议</strong>讨论，并邀请<strong>专家进行指导</strong>， 经过多轮评审制定了成本管理计划，并由各方代表进行签字确认。在成本管理计划中，把项目成本按照<strong>是否直接归属项目</strong>划分为了直接成本和间接成本，直接成本包含项目人员的工资、设备采购费、差旅费等，间接成本包含了税金、安保、综合管理等费用。规定了项目成本的<strong>计量单位</strong>为万元，<strong>人天数</strong>作为测量工期时间单位，并决定采用<strong>挣值管理测量绩效</strong>，还规定了<strong>成本报告的格式和编制评率</strong>以及成本控制临界值为正负5%，为后续如何管理成本提供了指南。</p><p>二、估算成本，估算完成项目活动所需资金</p><p>​    估算成本是对完成项目活动所需资金进行近似估算的过程，确定完成项目所需的成本数额。在上阶段完成成本管理计划编制后，我们开始着手成本估算，我们<strong>根据成本管理计划、范围基准</strong>进行成本估算，为了<strong>识别分析成本的构成科目</strong>。我们根据公司之前的类似项目进行参考，采用<strong>类比估算</strong>的方法来确定出了完成项目所需要的资源种类，包含人力成本、差旅费，设备硬件采购成本、管理成本、应急储备等。我们根据识别出来的成本构成科目，估算出每一科目的具体成本大小。例如对于人力成本，我们根据团队中各开发人员今年的工资情况，估算出每人每天所需费用，乘以进度计划中的人工时得到了人力成本，对于设备硬件采购成本，我们采用三点估算的β分布进行计算，形成了<strong>活动成本估算</strong>。我们对成本估算结果，优化找出可替代的成本，<strong>协调各种成本之间的比例关系</strong>。例如，我们对于开发过程中的票务管理的订单跟踪功能模块业务复杂，安排了研发能力强的技术骨干成员，而在其他相对简单的开发模块中安排其他成本较低的人员。最终我们估算出项目的人力成本为 180 万；设备采购成本为 120 万元；差旅费 10 万元、管理成本 5 万元、应急储备 40 万元等。<strong>确定了活动成本估算和估算依据</strong>。</p><p>三、制定预算，确定成本基准。</p><p>​    制定预算是<strong>汇总</strong>所有单个活动或工作包的估算成本，<strong>建立成本基准</strong>的过程，可据此<strong>监控项目绩效</strong>。<strong>财务</strong>人员小陈<strong>根据活动成本估算</strong>，汇总所有单个活动的估算成本及硬件采购成本后，向我提交了项目预算报<strong>告</strong>。我根据多年项目经验判断，采购的硬件如大屏设备，摄像头等都是高度市场化的商品，价格透明，预算相对来说较为精准，但为了应对市场可能存在的价格波动，我建议小王<strong>在硬件预算</strong>中<strong>增加5%的应急储备</strong>。而<strong>人力资源成本作为不确定性较大</strong>的管理项目，可能存在人员调动，离职请假等情况发生，考虑到该预算可能无法应对各种风险，因此我们参考<strong>风险登记册</strong>，进行了详尽的储备分析，建议小王<strong>在开发预算中</strong>增加15%的应急储备。另外，<strong>为了应对未识别的未知事件</strong>，确保项目预算的切实可行，我们<strong>按10%的额度设定了管理储备</strong>。随后我邀请各干系人和专家进行<strong>评审，评审通过后确定了</strong>项目的<strong>成本基准和项目资金需求</strong>，将成本基准加上管理储备得到了<strong>项目预算</strong>。</p><p>四、控制成本，及时发现偏差并采取纠正措施</p><p>​    本过程的主要作用是<strong>及时发现偏差，以便采取纠正措施</strong>，降低风险。我们<strong>依据成本管理计划、项目资金需求和绩效数据</strong>，每两周对项目进行一次<strong>评审</strong>，以便发现项目成本基准之外的费用支出，并利用<strong>挣值分析</strong>和预测技术对成本绩效进行分析。例如在一次评审中，项目的CPI为0.98，SPI为0.97，我们紧接着在随后的一周再次进行分析，发现CPI为0.95，SPI为0.96，达到了项目成本管理计划中规定的控制临界值，按照这种情况继续发展，我们预测完成项目剩余工作的成本将严重超支。我立马召集项目组对此问题进行分析，发现导致成本超支、进度落后的原因是可视化大屏模块对接3D高德地图时存在性能卡顿问题。于是我们组织专题、请教专家，研究解决方案，发现问题出在可视化大屏的分辨率太高，需要调整优化渲染。于是我向CCB提交变更申请，在审批通过后组织实施并做好监控，在3天内解决了此问题，随后我将此情况梳理成报告，<strong>更新了成本基准和经验教训登记册</strong>，并以邮件的形式通知了相关干系人。</p><h2 id="五、质量（1400）"><a href="#五、质量（1400）" class="headerlink" title="五、质量（1400）"></a>五、质量（1400）</h2><p>一、规划质量管理，为如何进行质量管理活动和制定质量管理计划提供指南和方向</p><p>​    在项目规划阶段，我便带领全体项目组成员以及相关干系人<strong>根据项目管理计划、风险登记册、需求文件和公司PMO发布的质量管理计划模板</strong>等资料，结合公司正在实施的CMMI5、ITSS等质量管理过程域的具体要求，遵循以客户为中心、全员参与的原则，反复<strong>开会</strong>讨论，展开头脑风暴，利用<strong>标杆对照确定了质量测量指标</strong>，例如系统故障率小于4%，可用性大于99.99%。我们根据<strong>范围基准中定义的验收标准，利用项目流程图，编制出了质量核对单</strong>。随后，我邀请公司领导、客户代表和业务专家参加项目质量管理计划评审会，安排经验丰富的质量保证人员小张作为QA全程负责本项目的质保工作，对每个工作包都指定了负责人和交付物的验收标准。会上我们发现客户的个别要求与文件规定有冲突并对此进行了协商调整，会后请每个人进行了签字确认，最终得到了<strong>质量管理计划</strong>为后续的工作提供指导。为确保质量管理计划得以落实，会后，我立马召集全体团队成员强调质量意识和全员参与的重要性，要全力配合质量保证员完成质量目标，并把开会的成果以<strong>邮件</strong>的形式通知了所有干系人，阶段性成果得到了双方高层的首肯和支持。</p><p>二、管理质量，促进质量过程的改进，保证质量的正确性</p><p>在项目的执行阶段，公司安排了一名专职的质量保证人员QA，他的主要职责是<strong>质量审计</strong>，<strong>根据质量管理计划</strong>，对开展的质量活动进行结构性审查，<strong>并通过QA周报、QA里程碑报告、质量审计报告</strong>等形式向我及相关干系人提供质量保证支持。在项目中我及时收集相关<strong>工作绩效</strong>数据并全力支持QA的<strong>质量审计</strong>工作。</p><p>​    例如，QA在一次例行质量审计过程中，发现票务管理的订单跟踪相关功能模块的接口文档注释不规范未达到质量测量指标，导致接口调用错误。我立即****根据责任分配矩阵*<em><strong>，找到负责该接口开发的成员，责令其严格按照质量管理计划的要求，按标准完整的描述该接口的名称、作用、参数格式和请求方法等信息，提出变更申请。我深知磨刀不误砍柴工的道理，发现问题后请QA依据</strong></em>*过程改进计划更新了质量指导手册*<em><strong>，随后邀请资深的骨干专家对小组成员进行了三天的培训，并记录到开发规范手册中</strong></em>*更新了组织过程资产****，并在每周项目组例会增加代码评审环节，及时发现问题并解决，这样关于一致性成本的执行降低了非一致性成本发生的概率，减少了返工和失败的风险（确保了项目进度的顺利进行），促进了质量过程的改进，保证了质量的正确性。</p><p>三、做好质量控制工作，识别问题并解决，确保可交付成果满足客户的需求</p><p>​    在项目的监控阶段我****根据项目管理计划、质量测量指标、质量核对单、工作绩效数据、批准的变更请求、项目文件和可交付成果****等进行质量控制，运用多种质量工具，及时发现偏差，分析原因，采取措施，直到问题解决。</p><p>​    例如，在项目开发后期，QA提交的工作绩效数据指出BI可视化大屏中使用3D高德地图+动态效果时性能卡顿问题。我对此高度重视，立即召集相关人员<em><strong>*采用矩阵图进行分析，结合因果图回溯原因，再用帕累托图对所有原因导致的影响*</strong>*进行*</em>******排序*<em><strong>，发现并非硬件问题，代码问题占了80%以上，我们通过讨论决定采取缩放分辨率调整动画渲染这一方案。我向CCB提交了变更申请，在审批通过后，我发布了变更通知并做好监控，</strong></em>*更新了项目管理计划以及质量核对单*<em><strong>，对于每一次变更都记录在文档日志中，纳入了变更管理及配置管理系统，保证所有的变更都可追溯、有据可查，不会产生互相推责的情况。随后我又将大屏的</strong></em>*响应时间放入控制图进行评估*<em><strong>，达到了预期的要求。于是我把变更标记为“确认的变更”，并把结果通知了所有干系人，通过这样PDCA的不断循环，保证了可交付成果的质量始终控制在</strong></em>*范围****之内。</p><h2 id="六、资源（1500）"><a href="#六、资源（1500）" class="headerlink" title="六、资源（1500）"></a>六、资源（1500）</h2><p>一、规划资源管理，为如何进行资源管理活动和制定资源管理计划提供指南和方向</p><p>   规划资源管理是决定如何进行资源管理活动和制定资源管理计划的过程。在项目启动后，我便带领全体项目组成员以及相关干系人<strong>根据项目管理计划、活动资源需求</strong>，多次召开<strong>会议</strong>讨论，并邀请<strong>专家</strong>指导，明确了项目中各团队成员的角色与职责，识别出需求、开发、测试、实施、质量等多个岗位，拟组建一个由11人组成的项目团队，制定了<strong>组织结构图和人员配备管理计划</strong>，对人员的获取、退出、培训、资源日历等进行了详细的规定，例如涉及大数据等技术需要安排培训。这些内容经过多轮评审，最终<strong>编制了资源管理计划</strong>，并由各方代表签字确认，为整个项目中如何管理资源提供了指南和方向。</p><p>二、估算活动资源，确定资源分解结构</p><p>​    估算活动资源是估算项目所需团队资源的过程。我们根据<strong>活动清单</strong>，结合<strong>活动成本估算</strong>，采用<strong>自下而上估算</strong>的方法，把单个活动所需资源逐级进行汇总，最后估算出各活动所需的资源种类和数量，如开发可视化大屏需要1名高级软件开发、1名数据采集人员、1台大屏设备和不少于3枚摄像头。得到了<strong>活动资源需求</strong>后，我<strong>按人力资源、设备资源、材料资源</strong>等进行<strong>分类</strong>，确定了<strong>资源分解结构</strong>。</p><p>三、获取资源，组建项目团队</p><p>   获取资源是为开展项目活动而获取项目所需团队成员、设备、材料和其他资源的过程。我根据<strong>资源分解结构、项目进度计划</strong>对公司现有资源情况进行<strong>多标准决策分析</strong>，首先找出目前可用的资源，再根据项目的技术难度、成本和进度需求，结合人员的成本、经验、技能综合考虑，<strong>安排合适的人员到对应的岗位上去</strong>。考虑到项目中票务管理的订单跟踪相关功能模块，公司内部没有类似项目经验的开发人员，因此我委托人事部门进行<strong>招聘</strong>，以线上<strong>虚拟团队</strong>的形式邀请了某大学的一名教授作为顾问。最后，我们组建成了<strong>一支项目型团队</strong>，其中项目经理1人，开发工程师5人，实施工程师2人，测试工程师2人，技术顾问1人共11人，并<strong>记录</strong>每位成员在项目上的<strong>工作时间段</strong>，<strong>形成资源日历</strong>。</p><p>四、建设团队，改善团队氛围，打造成功高效团队。</p><p>   建设团队是促进团队成员互动，改善团队氛围，提高工作效率，<strong>以增加项目绩效</strong>的过程。我<strong>根据资源管理计划和项目人员分派</strong>，组织大家<strong>集中办公</strong>方便讨论协作。同时为了<strong>提升</strong>团队成员的<strong>技能</strong>，我安排技术组长定期给组员<strong>培训</strong>。我根据<strong>马斯洛</strong>需求理论中的社会交往需求展开<strong>团建</strong>活动增加团队友谊缓解压力，对于工作中表现好的成员给与<strong>认可和奖励。</strong>团队从形成阶段很快<strong>跨过震荡阶段进入规范阶段向发挥阶段进行</strong>，经<strong>评估团队绩效</strong>提升明显，得到了客户和公司领导的一致肯定。</p><p>五、管理团队，处理冲突，解决问题，优化项目绩效</p><p>   管理团队是跟踪团队成员工作表现，管理冲突，解决问题以优化项目绩效的过程。我<strong>根据资源管理计划、项目人员分派、工作绩效报告和问题日志</strong>，对团队成员的<strong>工作状态</strong>进行<strong>观察跟踪</strong>，一旦发现问题及时与其进行正式或非正式的<strong>沟通</strong>。例如当发现BI可视化大屏中使用3D高德地图+动态效果时性能卡顿，负责建模的小张和数据收集的小王都认为出现问题的原因不在自己。我对此高度重视，对于<strong>冲突</strong>本着不回避、公开协商的原则，在了解情况后决定采取<strong>合作解决</strong>问题的策略让他们冷静下来倾听双方意见，综合分析利弊再一起合作，最后发现问题出在分辨率太高，需要采用缩放并优化渲染这一方案，我向CCB提交了<strong>变更</strong>申请，在审批通过后，我<strong>发布了变更通知并做好监控</strong>，<strong>更新了项目管理计划以及相关文档</strong>，解决了该问题，并把此经验<strong>更新到经验教训登记册</strong>中为以后的项目提供参考。</p><p>六、控制资源，确保资源分配的合理性</p><p>​    在项目开发过程中，我根据<strong>资源管理计划、资源分解结构、工作绩效数据</strong>等定期监督资源的分配、使用和释放。在开发移动端App时，多名小组成员提倡选用Uniapp框架开发应用可以明显提高开发效率。于是我立即组织了技术专家召开会议进行<strong>备选方案分析</strong>，验证了这一提案的可行性。并结合实际情况将开发App的人员数量从5人调整到3人，节约了人力成本，加快了项目进度。随后我更新了<strong>资源管理计划和进度基准</strong>。</p><h2 id="七、沟通（1500）"><a href="#七、沟通（1500）" class="headerlink" title="七、沟通（1500）"></a>七、沟通（1500）</h2><p>一、规划沟通管理，识别最佳沟通方式</p><p>​    规划沟通管理是决定如何进行沟通管理活动和制定沟通管理计划的过程，为整个项目中如何管理沟通提供了指南和方向。主要作用是识别和记录与干系人最有效率且最有效果的沟通方式，因此，我非常重视沟通管理计划的制定。在项目启动后，我便依据<strong>项目管理计划、干系人登记册和公司PMO发布的沟通管理计划模板</strong>，多次召集团队成员<strong>开会</strong>讨论，并邀请<strong>专家指导</strong>，编制了项目<strong>沟通管理计划</strong>，并由各方代表<strong>签字</strong>确认。在沟通管理计划中，<strong>明确了通用术语表、干系人沟通需求、需要沟通的信息、负责沟通信息的人员、传递信息的技术和方法、问题升级程序</strong>等。</p><p>​    其中，在制定传递信息的技术和方法时，我们考虑到为了提高沟通的效率和效果，<strong>项目干系人之间传递信息的沟通渠道应当随着项目的进展进行调整变化</strong>，例如在项目的开始阶段，与各相关干系人采用<strong>会议、电话、访谈、引导式研讨会</strong>的沟通方式，达到<strong>交互式沟通</strong>的效果，确保得到干系人需求信息的准确度，深入挖掘客户的真实需求，以免项目过程中因需求有误而导致的返工；在项目过程中，大部分工作在有序的进行，为了保证工作效率，需要与相关干系人确定的事项以及提交的项目绩效报告等，一般<strong>以报告、邮件等推式沟通</strong>的方式进行告知，这样既节约时间，同时也确保让相关干系人对项目的情况及时知悉。</p><p>二、管理沟通，促进沟通的效率效果</p><p>​    管理沟通主要作用是促进项目干系人之间实现有效率且有效果的沟通。在制定<strong>沟通管理计划</strong>之后，我们便以此为依据，灵活的运用各种沟通方法开展项目实施。本项目涉及<strong>干系人较多，包括</strong>市局领导和各科室相关业务人员、监理方、我公司高层领导、项目管理部和项目组成员，根据<strong>沟通管理计划</strong>中明确的各干系人和其接受的信息，以及<strong>权利/利益矩阵</strong>确定的各干系人的沟通策略，我进行了如下的管理：</p><p>​    例如，客户方的旅游局局长陈局，是本项目的发起人之一，需要在项目建设过程中根据<strong>里程碑和可交付物完成情况</strong>，及时给他推送项目的进展，以获取他对我以及整个项目团队的信任；我公司的项目管理部负责刘经理，更关注项目整体的<strong>开发进展</strong>情况，和项目的总体<strong>成本花费</strong>情况，我每周都会汇报上述内容，以获取公司层面对我和项目的资源支持；项目监理孙工，更关注<strong>项目的质量</strong>，我每周都会整理汇总质量人员提交给我的质量信息，编写成质量报告发送给孙工；另外，对于项目组成员，我需要实时关注他们的动态，所以要求在钉钉上提交日报和周报，汇报已完成的工作、接下来的计划、经验分享和待解决的问题等等，加强团队之间的管理，及时发现问题，形成一种团结互助、乐于分享的团队文化，提高个人和团队工作效率，丰富公司的组织过程资产。</p><p>三、监督沟通，保证沟通的有效性。</p><p>​    监督沟通是在整个项目生命周期中对沟通进行监督和控制的过程，以确保满足项目干系人对信息的需求，本过程的主要作用是，随时确保所有沟通参与者之间的信息流动的最优化，确保信息沟通的有效性。在项目过程中，我们根据<strong>项目管理计划、工作绩效数据和问题日志</strong>，召开会议和咨询公司相关专家，每个月编制一份<strong>绩效报告</strong>，并根据项目情况及时进行变更。在实际项目中，客户方总是不断地的<strong>有新想法、新功能</strong>，希望能加入到系统中，而对于公司来说，则<strong>要把范围、成本、进度保持在可控范围</strong>内，除了用有效的手段进行范围和进度管理外，还需要我们加强和领导及客户方的沟通，努力使各方期望达到统一的标准。</p><p>​    例如，在项目中期，旅游局的陈局向我提出希望在系统可视化大屏模块中增加游客互动的功能，我们针对该功能进行变更分析，估算出该变更对工期、成本的影响，以及可能出现的风险。最后将变更申请及影响分析提交到变更控制委员会，通过开会讨论，我在会上综合分析利弊说明了该功能对于系统的重要性，且实施这一变更对成本和进度的影响在可控范围内，最终CCB决定通过该变更。随后我组织相关项目组成员实施这个变更，并在验证确认后以邮件的形式通知了所有相关干系人，阶段性成果得到了双方高层的肯定。如此，通过我合理的沟通，有效的管理干系人的需求，顺利带领团队成员完成了该项目。</p><h2 id="八、干系人（1200）"><a href="#八、干系人（1200）" class="headerlink" title="八、干系人（1200）"></a>八、干系人（1200）</h2><p>一、识别干系人，为干系人管理提供信息</p><p>   在项目的启动阶段，我立马展开干系人识别工作，<strong>根据项目章程、采购文件、事业环境因素和组织过程资产</strong>对项目的干系人进行了登记，通过分析干系人的影响力、利益列出了<strong>权利</strong>利益方格<strong>，划分为重点管理、令其满意、随时告知、监督四个类型。在本项目中，</strong>主要的干系人有：1、项目客户，也就是该市的旅游局，关系着项目成功与否的关键关系人，他主要关注该系统是否实现特定功能，是否能按时完成；2、公司主管领导，主要关注项目进度、成本支出、质量情况等绩效分析，以及项目的预测分析；3、项目监理，主要关注项目的质量。此外还有其他干系人，比如用户、项目团队成员等等，不要担心识别出的干系人多，如果某些干系人未被识别出来的话，很可能对项目带来潜在影响。最后，我们<strong>生成了干系人登记册</strong>。</p><p>二、规划干系人参与，为项目干系人管理提供指南和方向</p><p>   规划干系人管理是决定如何进行项目干系人管理活动并编写干系人管理计划的过程。在识别干系人之后，我们便<strong>根据项目管理计划、干系人登记册，事业环境因素和组织过程资产</strong>邀请各重要干系人参与，采用全员<strong>会议和专家</strong>判断的方式，对干系人的参与程度、如何沟通汇报、如何变更需求等进行分析，经过多轮评审，<strong>编制了干系人管理计划更新了干系人登记册</strong>，并由各方代表签字确认。</p><p>三、管理干系人参与，获取支持提高项目成功的机会</p><p>   管理干系人需要促进干系人合理参与到项目活动，与干系人进行沟通和协作，以满足他的需求和期望。此过程的作用是争取干系人的支持，从而提高项目成功的机会。在整个项目过程中，我<strong>根据干系人管理计划、沟通管理计划</strong>，与客户方各干系人采用<strong>会议、访谈、引导式研讨会</strong>的沟通方式，达到交互式沟通的效果，确保得到干系人需求信息的准确度，深入挖掘客户的真实需求，以免项目过程中因需求有误而导致的返工，保证工作有序的进行。例如客户方的总规划师李某，是本项目的发起人之一，需要了解在项目建设过程中的里程碑和可交付物的完成情况，我通过<strong>电话、邮件等推式沟通</strong>方法报告项目的进展，这样既节约时间，同时也确保他对项目的情况及时知悉。获得了他对我以及整个项目团队的信任。而公司高管领导更关注项目整体的开发进展和项目的总体成本花费情况，我每周都会汇报上述内容以获取领导层对项目的资源支持。</p><p>四、监督干系人参与，调整策略和计划</p><p>   控制干系人参与指的是全面监督项目干系人之间的关系，调整策略和计划，以调动干系人的参与。在此过程中，我<strong>根据项目管理计划、问题日志、工作绩效数据</strong>等信息，时刻保持对干系人管理过程中出现的问题进行有效的识别和控制。例如，在项目需求分析阶段，<strong>根据干系人管理计划和沟通管理计划</strong>，我们需要多次召集客户方代表和我方需求人员进行<strong>会议</strong>，但是由于对方的关键人物王局忙于政务，没有太多时间与我们进行业务探讨，并且客户方其他人无法从整体上进行需求的把控，因此我们改变沟通策略，先采用非正式沟通方式，如跟王局他们在用餐期间进行交流，然后经过我们梳理成初步的需求文档，以书面形式发送客户方，再约时间进行正式需求分析研讨会，之后<strong>更新了项目管理计划和需求文件</strong>。通过调整计划调动干系人参与项目，提高了客户对我们服务的满意度。</p><h2 id="九、风险（1500）"><a href="#九、风险（1500）" class="headerlink" title="九、风险（1500）"></a>九、风险（1500）</h2><p>一、规划风险管理，为如何进行风险管理活动和制定风险管理计划提供指南和方向</p><p>   规划风险管理是决定如何进行风险管理活动和制定风险管理计划的过程，在项目规划阶段，我便带领全体项目组成员及相关干系人<strong>根据项目章程、项目管理计划、干系人登记册等，反复开会讨论，展开头脑风暴</strong>，并邀请<strong>专家</strong>经过多轮<strong>评审</strong>，<strong>编制了风险管理计划</strong>，该计划把风险分为需求风险、技术风险、人力资源风险等，规定了每项活动的角色和职责，如技术风险由开发人员负责。同时规定了风险管理活动的时间安排，如每2周进行一次风险评估会议，为后续的风险管理提供了指南。</p><p>二、风险识别，发现并记录风险，反复进行</p><p>   风险识别就是发现并以书面的形式记录可能对项目产生影响的风险，它是一项需要反复、全面、综合、系统、科学进行的工作。在此过程中，我们<strong>根据风险管理计划、成本管理计划、进度管理计划、范围基准、干系人登记册等</strong>，邀请专家进行判断结合<strong>数据收集技术</strong>，识别出一些主要的风险如下：需求风险，甲方的新想法可能会频繁提出需求变更，影响到项目范围；技术风险，如团队成员对BI大屏技术的开发经验不足，对接国旅局、高德、海康等接口的及时有效性和兼容性将影响到开发进度；人力资源风险，例如团队成员离职，请假等情况发生。我将这些归纳整理后<strong>形成风险登记册</strong>，并随着项目的进展不断更新。</p><p>三、实施定性风险分析，确定风险优先级</p><p>   定性风险分析是对已识别的风险进行优化排序的方法，通过关注高优先级的风险来有效改善项目绩效。我们根据<strong>风险管理计划和风险登记册</strong>，对已识别的风险逐一进行<strong>概率和影响评估</strong>，分为很低、低、中等、高、很高五个等级，并分别赋予了不同的数值，<strong>制作了概率及影响矩阵</strong>，发现技术风险对项目的影响最大，将其优先级放在第一，需重点关注，需求风险处于中等风险需加以监督，而人力资源风险处于低风险区域只需作为观察对象放入风险登记册或分配应急储备，随后<strong>更新了风险登记册</strong>。</p><p>四、实施定量风险分析，对风险产生的影响进行量化</p><p>   定量风险分析是将风险对项目产生的影响进行量化分析的过程。我们根据<strong>风险管理计划</strong>、成本管理计划、进度管理计划和<strong>风险登记册</strong>，采用<strong>蒙特卡洛技术</strong>为每个风险建模，模拟计算出概率分布。其中旅行社ERP模块的技术风险，我们对三个方案（自主研发、外包、外聘专家）进行<strong>预期货币价值分析</strong>（EMV）和<strong>决策树分析</strong>，将机会的EMV设置为正值，风险的则表示为负值，将每个数据和它发生的概率进行相乘并求和，通过计算发现外聘专家这个决策的EMV值最高。最后，我们记录这些定量计算的结果对<strong>风险登记册再次更新</strong>。</p><p>五、规划风险应对，确定风险应对措施和方案</p><p>   规划风险应对是指为实现项目目标增加机会，降低失败影响而<strong>制定方案的过程</strong>。我们根据<strong>风险管理计划、风险登记册</strong>，对消极风险采取了回避、转移、减轻、接受等策略，对积极风险采取了开拓、分享、提高等策略。如针对技术风险，外聘专家进行指导和培训；针对需求风险，加强和客户的沟通，做好需求收集工作并严格执行变更申请流程。制定好这些措施后，我们<strong>对项目管理计划和风险登记册进行了更新</strong>。</p><p>六、实施风险应对，及时处理风险事件</p><p>​    在项目的执行阶段，我要求项目组成员严格按照风险应对措施及时的处理风险事件，例如客户方想在系统中添加游客互动功能，我根据<strong>风险登记册</strong>中记录的需求风险，本着<strong>合作/解决</strong>问题的策略组织团队成员召开讨论，综合分析利弊并一起合作，积极倾听大家意见并邀请<strong>专家进行判断</strong>认为该需求可行，得到了大家的支持响应，随后我向CCB提交了<strong>变更申请</strong>，<strong>更新了风险登记册</strong>。</p><p>七、监督风险，评估风险应对措施的有效性</p><p>   监督风险是监控风险并评估风险应对策略有效性的过程。我们根据风险管理计划中指定的风险控制频率，每2周对项目进行<strong>风险再评估</strong>，对识别出的风险进行<strong>风险审计</strong>。<strong>并根据工作绩效数据（报告）</strong>，通过偏差和趋势分析，对项目总体进行<strong>监控</strong>，如某次工作绩效报告指出BI大屏性能卡顿问题，我立马<strong>召开风险审查会</strong>讨论采取应对措施，发现需要优化渲染，于是我向CCB提交相应的变更申请，在审批通过后，我发布了变更通知并做好监控,优化<strong>更新了项目管理计划和风险登记册</strong>、并记录到<strong>经验教训登记册</strong>中为后续的项目提供参考。</p><h2 id="十、采购（1400）"><a href="#十、采购（1400）" class="headerlink" title="十、采购（1400）"></a>十、采购（1400）</h2><p>一、规划采购管理</p><p>​    规划采购管理是决定采购什么、何时采购、如何采购，并记录要求、寻找潜在供应商的过程，为整个项目中如何管理采购提供了指南和方向。因此，我非常重视采购计划的制定，在项目启动后，我们便根据项目管理计划、需求文档、活动资源需求、项目进度计划、项目成本估算、风险登记册，开始编写采购计划。首先我们结合本系统对硬件设备的要求，对项目所需硬件配置方案进行评估，汇总了机房所需设备的规格参数，确定了采购清单，例如服务器、存储设备、网络设备、机柜、不间断电源等等，并对这些商品进行了充分的市场调研。然后我们组织召开评估会，在会上通过了对设备配置方案和采购预算方案的评审，并报公司同意后采用公开招标的方式选择供应商。最后我们结合公司相关模板编制了采购计划，并编写了相关的采购文件，其中招标文件中详细说明了供应商选择标准，例如供应商应通过质量管理体系IOS9000认证，应具有网络、服务器实施资质的人员等等。</p><p>二、实施采购</p><p>​    实施采购是选择供应商、签署合同的过程。在制定好采购管理计划后，我们便根据采购计划、采购工作说明书开始实施采购。首先，我们在相关采购平台上发布了此项目机房建设硬件采购的招标公告，确定自招标公告发布之日起20天后开标。我们成立了评标委员会，由7人组成，其中包括技术专家3名，经济专家2名，我公司管理人员1名，建设方代表1名。期间有家供应商对硬件参数要求和机房现场不是很清楚，于是我组织所有投标人踏勘现场，召开投标人会议，对招标要求进行详细的说明。在开标时共有8家供应商参与投标，评标委员会按照供应商选择标准，对各个供应商进行打分，最后对综合评价得分进行汇总排序，得到前三位的供应商依次为甲公司、乙公司、丙公司。我们根据评标委员会的推荐，最终确定了排名第一的甲公司中标，作为我们此次供应商，并在规定日期内签订了采购合同。</p><p>三、控制采购</p><p>​    控制采购是管理采购关系、监督合同执行情况，并根据需要实施变更和采取纠正措施的过程。在和甲公司签订采购合同之后，我们便根据采购合同，开始定期检查合同的执行情况。我们安排了一名项目成员负责跟踪供应商，把供应商管理作为项目管理管理的一部分，把供应商执行纳入项目监控范围，发现问题当即整改，并每周将实施情况发送报告给我。在有一次例行检查中，发现实施进度有所滞后，我们通过分析绩效数据，认为该阶段工作可能会出现延期，排查原因发现近期设备到货集中，现场实施的人手不够，因此我要求供应商增加人员，以保证正常的进度。在我们严格要求下，供应商工作进度明显改善。在实施中期，建设方需要在机房摆放其他设备，因此提出了变更申请，我评估了该变更对整体机房建设的影响，与建设方代表、供应商项目经理讨论并研究出可行方案，然后经CCB审批通过后，通知供应商进行实施，并在后续工作中持续关注该变更，直至达到变更目的。</p><p>四、结束采购</p><p>​    结束采购是完结本次项目采购的过程。结束采购主要做两方面是工作：一方面是合同收尾，在收到供应商甲公司的验收通知后，我组织了建设方代表、项目团队成员按照合同规定的验收标准，逐一进行检查，例如机房内各设备摆放是否符合图纸，各个硬件设备的数量、规格、摆放位置等是否正确，并进行拍照和记录，安排技术人员对产品进行加电测试，保证设备运行正常；另一方面，我们组织相关人员对该采购活动进行了审计，对整个采购过程进行系统的审查，找出可供其他采购活动借鉴的成功经验和失败教训，将这些记录到公司的组织过程资产中，例如在规划采购时特别关注供应商选择标准，适当提高售后服务的比例，在控制采购过程中特别注意对供货商的进度、质量的监控，加强沟通，做好应急预案，把风险降到最低。（330字）</p><h2 id="十一、通用模板"><a href="#十一、通用模板" class="headerlink" title="十一、通用模板"></a>十一、通用模板</h2><p><strong>前言（550）</strong></p><p>​        为了积极响应国家旅游局发布的“旅游+互联网”行动计划，基于物联网、大数据、云平台等前沿应用实现传统景区向智慧景区升级转型的战略，某市于20xx年xx月就智慧旅游管理平台项目进行公开招标。我司属于国营企业以较高分数顺利中标，中标价为596万元，建设工期为7个月。随后公司委任我担任项目经理一职负责项目的管理实施，内容包括新建门户网站以及移动端App，具体包含景区票务管理、OA组织协同、旅行社ERP、B2C电子商务以及可视化全景大屏等多个功能模块的开发。在对需求进行分析后，我们确认该系统采用SOA架构体系，可集成嵌入式终端、移动端App和Web管理平台，数据库使用MySQL结合Java语言进行开发。在大家的共同努力下最终该项目于20xx年x月如期通过了甲方组织的验收，各项功能稳定良好，并通过各地推荐、专家评选等环节入选该省20xx年度十大优秀智慧旅游创新案例名单，促进了景区的创A加分，提高了游客的出行体验。</p><p>​    由于该项目是该市重点打造的旅游信息化项目，我方领导也希望通过本项目将公司业务延伸拓展出一个新的渠道。该项目具有客户期望值高，业务复杂，功能模块交互紧密，干系人较多等特点，必须保证项目的质量过硬、安全顺利交付。为确保实现这一目标，我严抓项目xx管理的各个过程，（并结合做好干系人沟通和范围管理等工作），本文我以该项目为例，从……几方面论述了信息系统项目的xx管理。</p><p><strong>正文</strong></p><p>​        （各个子过程…）</p><p><strong>结尾（400）</strong></p><p>​        经过我们团队的协作努力，历时7个月，本项目终于在20xx年xx月成功上线，系统运行稳定良好，顺利通过了甲方组织的验收，成功交付了一个智慧旅游管理平台系统，实现了景区管理精细化、游客服务高效化、景点畅游智能化，促进了社会主义市场经济的发展，获得了业主方的充分好评。本项目的成功得益于我成功的xx管理，在本项目的实践过程中，我最深刻的经验总结就是：计划，计划，再计划（识别，识别，再识别）。项目经理一定要把计划（风险识别）工作落实，并且项目计划的制定（风险识别）并不是一蹴而就的，而是在整个项目进展的过程中不断地进行动态调整的，要时刻关注计划是否对项目真正起到指导作用，还有就是将各种xx工具和技术，落实到实际的工作中去，反复权衡去追求xx管理的最佳方案，这样才能取得最后的成功。在后续的工作中，我将继续不断充电学习，总结经验，提升自己的业务和项目管理水平，力争为我国信息化建设做出自己的一份贡献。（385）（识别干系人，既要全面，又要细致，不单单是要识别出全部可能的干系人，还要对每个干系人的信息和对项目的影响进行充分挖掘，然后有针对性地制定管理计划；在控制干系人参与过程中，一定要灵活应变不同情况，充分结合沟通技术，寻求沟通的最佳方案，以获取干系人的满意和支持）</p><h2 id="十二、福利"><a href="#十二、福利" class="headerlink" title="十二、福利"></a>十二、福利</h2><p>​        博主加入一个高项微信群四年了，群里有大部分培训机构整理的资料，每天的学习氛围也非常浓厚，不懂的问题有人解答，最关键的是考试那天各个机构的押题会发在群里，想备考的伙计可以给俺留言。</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEO 站点优化</title>
      <link href="/2021/08/04/04.seo/"/>
      <url>/2021/08/04/04.seo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、百度收录"><a href="#一、百度收录" class="headerlink" title="一、百度收录"></a>一、百度收录</h2><blockquote><p>在这之前，<strong>需要注意：</strong></p><p><code>GitHub</code>不允许百度的<code>Spider</code>（蜘蛛）爬取<code>GitHub</code>上的内容的，所以任何部署在GitHub上的静态博客都是不能百度爬取到的！</p></blockquote><h3 id="1-1-提交站点"><a href="#1-1-提交站点" class="headerlink" title="1.1 提交站点"></a>1.1 提交站点</h3><p>刚建完站在百度上是不可能搜索到我们的网站的，我们可以先试一下：在百度上搜索 <code>site:&lt;你的域名&gt;</code>，一般是搜不到的，然后点击 <code>提交网址</code> 来先将自己的网站提交给百度。</p><p><img src="1.1.png"></p><h3 id="1-2-添加站点"><a href="#1-2-添加站点" class="headerlink" title="1.2 添加站点"></a>1.2 添加站点</h3><p>登录<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>， 只要是百度旗下的账号就可以， 登录成功之后在站点管理中点击<a href="https://ziyuan.baidu.com/site/siteadd">添加网站</a>，输入域名，按着这三步来进行。</p><p><img src="1.2.png"></p><p>第三步验证网站的时候， 验证网站所有权的方式有三种：</p><ul><li>文件验证</li><li><code>HTML</code>标签验证</li><li><code>CNAME</code>解析验证<strong>（推荐使用）</strong></li></ul><p>同理，百度的spider是爬取不到GitHub的内容的，所以<code>HTML标签验证</code>方式也是不太可取的。</p><p><img src="1.3.png"></p><h3 id="1-3-推送资源"><a href="#1-3-推送资源" class="headerlink" title="1.3 推送资源"></a>1.3 推送资源</h3><p>经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。</p><p>还是在百度资源搜索平台，找到数据引入-&gt;链接提交，可以看到向百度推送自己的内容有两个方式：</p><ol><li><p>自动提交</p><p>（分三种）</p><ul><li>主动推送</li><li>自动推送</li><li>sitemap（站点地图）</li></ul></li><li><p>手动提交</p><ul><li>即手动地将链接一次性提交给百度</li></ul></li></ol><p>一般自动提交比手动提交效果好一点，自动提交又从效率上来说：</p><p><strong>主动推送 &gt; 自动推送 &gt; sitemap</strong></p><p><strong>自动提交的三种方式</strong>：</p><ol><li><code>主动推送</code>：最为快速的提交方式。将站点当天新产出链接通过此方式推送给百度，以保证新链接可以及时被百度收录。</li><li><code>自动推送</code>：最为便捷的提交方式。将自动推送的JS代码部署在站点的每一个页面源代码中，当部署代码的页面在每次被浏览时，链接就会被自动推送给百度。可以与主动推送配合使用。</li><li><code>sitemap</code>：您可以定期将网站链接放到<code>sitemap文件</code>中，然后将<code>sitemap文件</code>提交给百度。百度会周期性的抓取检查您提交的<code>sitemap</code>，对其中的链接进行处理，但收录速度慢于主动推送。</li></ol><h4 id="1-3-1-sitemap推送"><a href="#1-3-1-sitemap推送" class="headerlink" title="1.3.1 sitemap推送"></a>1.3.1 sitemap推送</h4><p><strong>安装sitemap插件</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-sitemap --save <span class="token function">npm</span> <span class="token function">install</span> hexo-generator-baidu-sitemap --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个插件是用来生成 <code>Sitemap文件</code> 的插件，而 <code>Sitemap</code> 是用来告知搜索引擎我们的网站上有哪些可供抓取的网页的。</p><p><strong>注意一点：</strong><br><strong>hexo配置文件中的url一定要改成你的域名，这两个插件是根据你的url生成站点地图的。</strong></p><p>安装后直接执行<code>hexo cl&amp;&amp;hexo g</code>命令，然后就会在网站根目录生成<code>sitemap.xml</code>文件和<code>baidusitemap.xml文件</code>，其中<code>sitemap.xml</code>文件是搜索引擎通用的文件，<code>baidusitemap.xml</code>是百度专用的<code>sitemap</code>文件。</p><p>有<code>sitemap文件</code>之后，再将生成的<code>sitemap文件</code>提交给百度或者其他搜索引擎</p><p>百度方式：在自动提交的sitemap那里填写自己<code>sitemap文件</code>的URL地址即可</p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//你的域名/baidusitemap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交后会有状态提示等待，这里需要注意<strong>严格区分http和https：</strong></p><blockquote><p>http和https是不一样的，刚添加的站点是HTTP协议的，如果你网站开启了 <code>强制https</code>，是会报301重定向错误的，也就是百度不能抓取到你的sitemap</p><p>如果想用https，可以在<code>数据监控</code>-&gt;<code>HTTPS认证</code>进行认证</p><p>这个认证有时会很慢，可以在你的站点只留一个首页的<code>简单HTML</code>，然后再去百度认证，这样应该会快一点。</p></blockquote><p>如果是其他的搜索引擎，一般是在填写sitemap的地方，填写以下内容即可：</p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//你的域名/sitemap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-3-2-自动推送"><a href="#1-3-2-自动推送" class="headerlink" title="1.3.2 自动推送"></a>1.3.2 自动推送</h4><p>只要每个需要被百度爬取的HTML页面中加入一段JS代码即可：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> bp <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> curProtocol <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>protocol<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curProtocol <span class="token operator">===</span> <span class="token string">'https'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        bp<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'https://zz.bdstatic.com/linksubmit/push.js'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        bp<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://push.zhanzhang.baidu.com/push.js'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> s <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    s<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我所使用的matery主题可以自动给每个页面加上这段代码，只需在主题配置文件中配置：</p><pre class="line-numbers language-yml"><code class="language-yml"># 百度搜索资源平台提交链接baiduPush: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其他主题一般都有这个功能的实现，如果没有的话，想办法在每个页面加入以上JS代码即可，原理是一样。</p><h4 id="1-3-3-主动推送"><a href="#1-3-3-主动推送" class="headerlink" title="1.3.3 主动推送"></a>1.3.3 主动推送</h4><p>安装主动推送插件：<a href="https://github.com/huiwang/hexo-baidu-url-submit">hexo-baidu-url-submit</a></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-baidu-url-submit --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后打开<code>hexo配置文件</code>，在末尾加入以下配置：</p><pre class="line-numbers language-yml"><code class="language-yml"># hexo-baidu-url-submit  百度主动推送baidu_url_submit:  count: 80 # 提交最新的一个链接  host: adaichan.life # 在百度站长平台中注册的域名  token: xxxxxxx # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>密匙的获取是在百度的自动提交的主动推送那里。</p><p><img src="1.3.3.png"></p><p>再加入新的<code>deploy</code>：</p><pre class="line-numbers language-yml"><code class="language-yml">deploy:- type: baidu_url_submitter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样每次执行 <code>hexo d</code> 的时候，新的链接就会被推送了。<br>推送成功时,会有<code>deploy done!</code>终端提示。</p><p>各种不同的推送反馈字段说明<a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=2#h2_article_title12">点我</a>查看，一般来说，推送失败基本都是地址不相符造成的，我们只需对比<code>baidu_url_submit</code>在<code>public</code>中生成的<code>baidu_urls.txt</code>的地址,与自己填写在<code>host</code>字段中的地址对比看是否一样即可。</p><h2 id="二、谷歌收录"><a href="#二、谷歌收录" class="headerlink" title="二、谷歌收录"></a>二、谷歌收录</h2><p>相比于百度，google 的效率实在不能更快，貌似一天左右站点就被收录了，其实方法是和百度是一样的。</p><h3 id="2-1-具体步骤"><a href="#2-1-具体步骤" class="headerlink" title="2.1 具体步骤"></a>2.1 具体步骤</h3><ul><li>首先登录<a href="https://www.google.com/webmasters/">谷歌站长平台</a>，添加好自己的域名</li><li><code>DNS验证</code>（就是验证下网站是不是你的）就是域名解析那里添加一条TXT解析记录</li><li>然后点击验证即可</li><li>进入谷歌的<a href="https://search.google.com/search-console/">Search Console</a>，添加自己的<code>sitemap</code>地址</li><li>接下来，等就完事嘞</li></ul><h3 id="2-2-提交-robots-txt"><a href="#2-2-提交-robots-txt" class="headerlink" title="2.2 提交 robots.txt"></a>2.2 提交 robots.txt</h3><p><strong>robots.txt是干嘛的？</strong></p><p><code>robots.txt</code> 是一种存放于网站根目录下的 <code>ASCII</code> 编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。<br><code>robots.txt</code> 要放在 <code>Hexo根目录</code> 下的 <code>source</code> 文件夹中。</p><p>每个人站点目录可能不太一样，可以参考下我的 <code>robots.txt</code> 文件，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">User-agent</span><span class="token punctuation">:</span> *<span class="token key atrule">Allow</span><span class="token punctuation">:</span> /<span class="token key atrule">Allow</span><span class="token punctuation">:</span> /posts/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /about/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /archives/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /js/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /css/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /contact/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /fonts/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /friends/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /libs/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /medias/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /page/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /tags/<span class="token key atrule">Disallow</span><span class="token punctuation">:</span> /categories/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多关于 <code>robots.txt</code> 的写法参见 <a href="https://blog.csdn.net/fanghua_vip/article/details/79535639">https://blog.csdn.net/fanghua_vip/article/details/79535639</a></p><p>编写完以上内容再重新部署一下，然后到百度资源平台的<code>数据监控</code>-&gt;<code>Robots</code>点击<code>检测并更新</code> 看能不能检测到。<br>同样注意：刚添加的站点没有进行 <code>HTTPS认证</code>，直接检测有可能会报301错误。</p><h3 id="2-3-配置-Nofollow"><a href="#2-3-配置-Nofollow" class="headerlink" title="2.3 配置 Nofollow"></a>2.3 配置 Nofollow</h3><ul><li>nofollow 是HTML页面中 <code>a标签</code> 的 属性值。</li><li>这个属性的作用是：告诉搜索引擎的爬虫不要追踪该链接，为了对抗博客垃圾留言信息</li></ul><h2 id="三、URL-优化"><a href="#三、URL-优化" class="headerlink" title="三、URL 优化"></a>三、URL 优化</h2><p>一般来说，SEO搜索引擎优化认为，网站的最佳结构是 <strong>用户从首页点击三次就可以到达任何一个页面</strong>，但是我们使用<code>Hexo</code>编译的站点结构的<code>URL</code>是：<code>域名/年/月/日/文章标题</code>四层的结构，这样的<code>URL</code>结构很不利于<code>SEO</code>，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章的<code>URL</code></p><h3 id="3-1-方案一"><a href="#3-1-方案一" class="headerlink" title="3.1 方案一"></a>3.1 方案一</h3><p>直接改成<code>域名/文章标题</code>的形式，在<code>Hexo配置文件</code>中修改<code>permalink</code>如下：</p><pre class="line-numbers language-yml"><code class="language-yml"># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://adaichan.liferoot: /permalink: :title.htmlpermalink_defaults:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这个方式有个不好的地方：</strong></p><p>直接以<code>文章的标题</code>作为URL，而我们所写的文章的标题一般都是中文，但是URL只能用字母数字和标点符号表示，所以中文的URL只能被转义成一堆符号，而且还特别长。</p><h3 id="3-2-方案二"><a href="#3-2-方案二" class="headerlink" title="3.2 方案二"></a>3.2 方案二</h3><p>安装固定链接插件：<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a></p><p>插件作用：自动为每篇文章生成一串数字作每篇文章的URI地址。每篇文章的<code>Front-matter</code>中会自动增加一个配置项：<code>abbrlink: xxxxx</code>，该项的值就是当前文章的URI地址。</p><ol><li><p>Hexo根目录执行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>Hexo配置文件</code>末尾加入以下配置：</p><pre class="line-numbers language-yml"><code class="language-yml"># hexo-abbrlink config 、固定文章地址插件abbrlink:  alg: crc16  #算法选项：crc16、crc32，区别见之前的文章，这里默认为crc16丨crc32比crc16复杂一点，长一点  rep: dec    #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Hexo配置文件</code>中修改<code>permalink</code>如下：</p><pre class="line-numbers language-yml"><code class="language-yml"># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://adaichan.liferoot: /permalink: posts/:abbrlink.htmlpermalink_defaults:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>这样站点结构就变成了：<code>域名/posts/xxx.html</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 配置分享</title>
      <link href="/2021/06/28/03.vscode/"/>
      <url>/2021/06/28/03.vscode/</url>
      
        <content type="html"><![CDATA[<h2 id="一、VSCode-介绍"><a href="#一、VSCode-介绍" class="headerlink" title="一、VSCode 介绍"></a>一、VSCode 介绍</h2><h3 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h3><p>VSCode 全称 Visual Studio Code，是一款开源、免费、跨平台、高性能、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得相当 nice。</p><p><strong>尤雨溪</strong>大大这样评价 VSCode：</p><p><img src="1.1.png"></p><p>有一点你可能会感到惊讶：VSCode 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的客户端开发框架 <code>Electron</code>）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：</p><blockquote><p><strong>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</strong>。</p></blockquote><p>Jeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。</p><p>如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VSCode 作为「<strong>主力开发工具</strong>」。这款软件是为前端童鞋量身定制的。</p><p>如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VSCode 作为「<strong>代码编辑器</strong>」来使用，纵享丝滑。</p><p>甚至是一些写文档、写作的同学，也经常把 VSCode 作为 Markdown <strong>写作工具</strong>，毫无违和感。</p><p>退而求其次，即便你不属于以上任何范畴，你还可以把 VSCode 当作最简单的<strong>文本编辑器</strong>来使用。</p><h3 id="1-2-IDE-与编辑器的对比"><a href="#1-2-IDE-与编辑器的对比" class="headerlink" title="1.2 IDE 与编辑器的对比"></a>1.2 IDE 与编辑器的对比</h3><ul><li><strong>IDE</strong>（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。</li><li><strong>编辑器</strong>：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。</li></ul><p>需要注意的是，VSCode 的定位是<strong>编辑器</strong>，而非 IDE ，但 VSCode 又比一般的编辑器的功能要丰富许多。可以这样理解：VSCode 的体量是介于编辑器和 IDE 之间。</p><h3 id="1-3-VSCode-特点"><a href="#1-3-VSCode-特点" class="headerlink" title="1.3 VSCode 特点"></a>1.3 VSCode 特点</h3><ul><li>VSCode 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验，比如代码的智能提示、语法检查、图形化的调试工具、插件扩展、版本管理等。</li><li>跨平台支持 MacOS、Windows 和 Linux 等多个平台。</li><li>VSCode 的源代码以 MIT 协议开源。</li><li>支持第三方插件，功能强大，生态系统完善。</li><li>VSCode 自带了 TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。当然，其他的语言，你可以安装相应的<strong>扩展包</strong>插件，也会有智能提示。</li></ul><h3 id="1-4-前端利器之争：VSCode-与-WebStorm"><a href="#1-4-前端利器之争：VSCode-与-WebStorm" class="headerlink" title="1.4 前端利器之争：VSCode 与 WebStorm"></a>1.4 前端利器之争：VSCode 与 WebStorm</h3><p>前端小白最喜欢问的一个问题是：哪个编辑器 / IDE 好用？是 VSCode 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比：</p><ul><li><strong>哪个更酷</strong>：显然 VSCode 更酷。</li><li><strong>内存占用情况</strong>：根据我的观察，VSCode 是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用，使用起来是不会有任何卡顿的感觉的。相比之下，IntelliJ IDEA 不仅非常占内存，而且还非常卡顿。如果你想换个既轻量级、又不占内存的编辑器，最好还是使用「Sublime Text」编辑器。</li><li><strong>使用比例</strong>：当然是 VSCode 更胜一筹。先不说别的，就拿数据说话，绝大部分前端童鞋都在用 VSCode，妥妥的。</li></ul><h2 id="二、VSCode-快捷键"><a href="#二、VSCode-快捷键" class="headerlink" title="二、VSCode 快捷键"></a>二、VSCode 快捷键</h2><p>以下都是常用的快捷键，而加粗部分的快捷键，使用频率则非常之高。</p><p>大部分工具，掌握 20% 的技能，可以应对 80% 的工作。但我想说的是：那从来都不是同样的 20%，每个人都会用到不同的功能，掌握下面这些<strong>高频核心快捷键</strong>，足矣。</p><h3 id="2-1-工作区"><a href="#2-1-工作区" class="headerlink" title="2.1 工作区"></a>2.1 工作区</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>Cmd + Shift + P</strong></td><td align="center"><strong>Ctrl + Shift + P</strong>，F1</td><td align="center">显示命令面板</td><td align="center"></td></tr><tr><td align="center"><strong>Cmd + B</strong></td><td align="center"><strong>Ctrl + B</strong></td><td align="center">显示/隐藏侧边栏</td><td align="center">很实用</td></tr><tr><td align="center"><code>Cmd + \</code></td><td align="center"><code>Ctrl + \</code></td><td align="center"><strong>创建多个编辑器</strong></td><td align="center">【重要】抄代码利器</td></tr><tr><td align="center"><strong>Cmd + 1、2</strong></td><td align="center"><strong>Ctrl + 1、2</strong></td><td align="center">聚焦到第 1、第 2 个编辑器</td><td align="center">同上重要</td></tr><tr><td align="center"><strong>cmd +/-</strong></td><td align="center"><strong>ctrl +/-</strong></td><td align="center">将工作区放大/缩小（包括代码字体、左侧导航栏）</td><td align="center">在投影仪场景经常用到</td></tr><tr><td align="center">Cmd + J</td><td align="center">Ctrl + J</td><td align="center">显示/隐藏控制台</td><td align="center"></td></tr><tr><td align="center"><strong>Cmd + Shift + N</strong></td><td align="center"><strong>Ctrl + Shift + N</strong></td><td align="center">重新开一个软件的窗口</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + Shift + W</td><td align="center">Ctrl + Shift + W</td><td align="center">关闭软件的当前窗口</td><td align="center"></td></tr><tr><td align="center">Cmd + N</td><td align="center">Ctrl + N</td><td align="center">新建文件</td><td align="center"></td></tr><tr><td align="center">Cmd + W</td><td align="center">Ctrl + W</td><td align="center">关闭当前文件</td><td align="center"></td></tr></tbody></table><h3 id="2-2-跳转"><a href="#2-2-跳转" class="headerlink" title="2.2 跳转"></a>2.2 跳转</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Cmd + `</td><td align="center">没有</td><td align="center">在同一个软件的<strong>多个工作区</strong>之间切换</td><td align="center">使用很频繁</td></tr><tr><td align="center"><strong>Cmd + Option + 左右方向键</strong></td><td align="center">Ctrl + Pagedown/Pageup</td><td align="center">在已经打开的<strong>多个文件</strong>之间进行切换</td><td align="center">非常实用</td></tr><tr><td align="center">Ctrl + Tab</td><td align="center">Ctrl + Tab</td><td align="center">在已经打开的多个文件之间进行跳转</td><td align="center">不如上面的快捷键快</td></tr><tr><td align="center">Cmd + Shift + O</td><td align="center">Ctrl + shift + O</td><td align="center">在当前文件的各种<strong>方法之间</strong>进行跳转</td><td align="center"></td></tr><tr><td align="center">Ctrl + G</td><td align="center">Ctrl + G</td><td align="center">跳转到指定行</td><td align="center"></td></tr><tr><td align="center"><code>Cmd+Shift+\</code></td><td align="center"><code>Ctrl+Shift+\</code></td><td align="center">跳转到匹配的括号</td><td align="center"></td></tr></tbody></table><h3 id="2-3-光标移动"><a href="#2-3-光标移动" class="headerlink" title="2.3 光标移动"></a>2.3 光标移动</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">方向键</td><td align="center">方向键</td><td align="center">在<strong>单个字符</strong>之间移动光标</td><td align="center">大家都知道</td></tr><tr><td align="center"><strong>option + 左右方向键</strong></td><td align="center"><strong>Ctrl + 左右方向键</strong></td><td align="center">在<strong>单词</strong>之间移动光标</td><td align="center">很常用</td></tr><tr><td align="center"><strong>Cmd + 左右方向键</strong></td><td align="center"><strong>Fn + 左右方向键</strong></td><td align="center">在<strong>整行</strong>之间移动光标</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + ←</td><td align="center">Fn + ←（或 Win + ←）</td><td align="center">将光标定位到当前行的最左侧</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + →</td><td align="center">Fn + →（或 Win + →）</td><td align="center">将光标定位到当前行的最右侧</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + ↑</td><td align="center">Ctrl + Home</td><td align="center">将光标定位到文章的第一行</td><td align="center"></td></tr><tr><td align="center">Cmd + ↓</td><td align="center">Ctrl + End</td><td align="center">将光标定位到文章的最后一行</td><td align="center"></td></tr><tr><td align="center">Cmd + Shift + \</td><td align="center"></td><td align="center">在<strong>代码块</strong>之间移动光标</td><td align="center"></td></tr></tbody></table><h3 id="2-4-编辑"><a href="#2-4-编辑" class="headerlink" title="2.4 编辑"></a>2.4 编辑</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>Cmd + Enter</strong></td><td align="center"><strong>Ctrl + Enter</strong></td><td align="center">在当前行的下方新增一行，然后跳至该行</td><td align="center">即使光标不在行尾，也能快速向下插入一行</td></tr><tr><td align="center">Cmd+Shift+Enter</td><td align="center">Ctrl+Shift+Enter</td><td align="center">在当前行的上方新增一行，然后跳至该行</td><td align="center">即使光标不在行尾，也能快速向上插入一行</td></tr><tr><td align="center"><strong>Option + ↑</strong></td><td align="center"><strong>Alt + ↑</strong></td><td align="center">将代码向上移动</td><td align="center">很常用</td></tr><tr><td align="center"><strong>Option + ↓</strong></td><td align="center"><strong>Alt + ↓</strong></td><td align="center">将代码向下移动</td><td align="center">很常用</td></tr><tr><td align="center">Option + Shift + ↑</td><td align="center">Alt + Shift + ↑</td><td align="center">将代码向上复制</td><td align="center"></td></tr><tr><td align="center"><strong>Option + Shift + ↓</strong></td><td align="center"><strong>Alt + Shift + ↓</strong></td><td align="center">将代码向下复制</td><td align="center">写重复代码的利器</td></tr></tbody></table><h3 id="2-5-多光标编辑"><a href="#2-5-多光标编辑" class="headerlink" title="2.5 多光标编辑"></a>2.5 多光标编辑</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>Cmd + Option + 上下键</strong></td><td align="center"><strong>Ctrl + Alt + 上下键</strong></td><td align="center">在连续的多列上，同时出现光标</td><td align="center"></td></tr><tr><td align="center"><strong>Option + 鼠标点击任意位置</strong></td><td align="center"><strong>Alt + 鼠标点击任意位置</strong></td><td align="center">在任意位置，同时出现光标</td><td align="center"></td></tr><tr><td align="center">Option + Shift + 鼠标拖动</td><td align="center">Alt + Shift + 鼠标拖动</td><td align="center">在选中区域的每一行末尾，出现光标</td><td align="center"></td></tr><tr><td align="center">Cmd + Shift + L</td><td align="center">Ctrl + Shift + L</td><td align="center">在选中文本的所有相同内容处，出现光标</td><td align="center"></td></tr></tbody></table><h3 id="2-6-其他多光标编辑"><a href="#2-6-其他多光标编辑" class="headerlink" title="2.6 其他多光标编辑"></a>2.6 其他多光标编辑</h3><ul><li>选中某个文本，然后反复按住快捷键「 <strong>Cmd + D</strong> 」键（windows 用户是按住「<strong>Ctrl + D</strong>」键）， 即可将全文中相同的词逐一加入选择。</li><li>选中一堆文本后，按住「<strong>Option + Shift + i</strong>」键（windows 用户是按住「<strong>Alt + Shift + I</strong>」键），既可在<strong>每一行的末尾</strong>都创建一个光标。</li></ul><h3 id="2-7-删除"><a href="#2-7-删除" class="headerlink" title="2.7 删除"></a>2.7 删除</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Cmd + shift + K</td><td align="center">Ctrl + Shift + K</td><td align="center">删除整行</td><td align="center">「Cmd + X」的作用是剪切，但也可以删除整行</td></tr><tr><td align="center"><strong>option + Backspace</strong></td><td align="center"><strong>Ctrl + Backspace</strong></td><td align="center">删除光标之前的一个单词</td><td align="center">英文有效，很常用</td></tr><tr><td align="center">option + delete</td><td align="center">Ctrl + delete</td><td align="center">删除光标之后的一个单词</td><td align="center"></td></tr><tr><td align="center"><strong>Cmd + Backspace</strong></td><td align="center"></td><td align="center">删除光标之前的整行内容</td><td align="center">很常用</td></tr><tr><td align="center">Cmd + delete</td><td align="center"></td><td align="center">删除光标之后的整行内容</td><td align="center"></td></tr></tbody></table><blockquote><p>备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。</p></blockquote><h3 id="2-8-编程语言相关"><a href="#2-8-编程语言相关" class="headerlink" title="2.8 编程语言相关"></a>2.8 编程语言相关</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Cmd + /</td><td align="center">Ctrl + /</td><td align="center">添加单行注释</td><td align="center">很常用</td></tr><tr><td align="center"><strong>Option + Shift + F</strong></td><td align="center">Alt + shift + F</td><td align="center">代码格式化</td><td align="center">很常用</td></tr><tr><td align="center">F2</td><td align="center">F2</td><td align="center">以重构的方式进行<strong>重命名</strong></td><td align="center">改代码备</td></tr><tr><td align="center">Ctrl + J</td><td align="center"></td><td align="center">将多行代码合并为一行</td><td align="center">Win 用户可在命令面板搜索”合并行“</td></tr><tr><td align="center">Cmd +</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Cmd + U</td><td align="center">Ctrl + U</td><td align="center">将光标的移动回退到上一个位置</td><td align="center">撤销光标的移动和选择</td></tr></tbody></table><h3 id="2-9-搜索相关"><a href="#2-9-搜索相关" class="headerlink" title="2.9 搜索相关"></a>2.9 搜索相关</h3><table><thead><tr><th align="center">Mac 快捷键</th><th align="center">Win 快捷键</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>Cmd + Shift + F</strong></td><td align="center"><strong>Ctrl + Shift +F</strong></td><td align="center">全局搜索代码</td><td align="center">很常用</td></tr><tr><td align="center"><strong>Cmd + P</strong></td><td align="center"><strong>Ctrl + P</strong></td><td align="center">在当前的项目工程里，<strong>全局</strong>搜索文件名</td><td align="center"></td></tr><tr><td align="center">Cmd + F</td><td align="center">Ctrl + F</td><td align="center">在当前文件中搜索代码，光标在搜索框里</td><td align="center"></td></tr><tr><td align="center"><strong>Cmd + G</strong></td><td align="center"><strong>F3</strong></td><td align="center">在当前文件中搜索代码，光标仍停留在编辑器里</td><td align="center">很巧妙</td></tr></tbody></table><h3 id="2-10-自定义快捷键"><a href="#2-10-自定义快捷键" class="headerlink" title="2.10 自定义快捷键"></a>2.10 自定义快捷键</h3><p>按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。</p><p>当然，你也可以选择菜单栏「偏好设置 –&gt; 键盘快捷方式」，进入快捷键的设置：</p><p><img src="2.10.png"></p><h3 id="2-11-快捷键列表"><a href="#2-11-快捷键列表" class="headerlink" title="2.11 快捷键列表"></a>2.11 快捷键列表</h3><p>你可以点击 VSCode 左下角的齿轮按钮，效果如下：</p><p><img src="2.11.1.png"></p><p>上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了：</p><p><img src="2.11.2.png"></p><h3 id="2-12-快捷键参考链接"><a href="#2-12-快捷键参考链接" class="headerlink" title="2.12 快捷键参考链接"></a>2.12 快捷键参考链接</h3><ul><li>快捷键速查表[官方]：<a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf</a></li></ul><h2 id="三、命令面板"><a href="#三、命令面板" class="headerlink" title="三、命令面板"></a>三、命令面板</h2><p>Mac 用户按住快捷键 <code>Cmd+Shift+P</code> （Windows 用户按住快捷键<code>Ctrl+Shift+P</code>），可以打开命令面板。效果如下：</p><p><img src="3.1.png"></p><p>如果们需要修改一些设置项，可以通过「命令面板」来操作，效率会更高。这里列举一些。</p><p><strong>设置字体大小</strong></p><p>在命令面板输入“字体”，可以进行字体的设置，效果如下：</p><p><img src="3.2.png"></p><p>当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。</p><p><strong>快捷键设置</strong></p><p>在命令面板输入“快捷键”，就可以进入快捷键的设置。</p><p><strong>大小写转换</strong></p><p>选中文本后，在命令面板中输入<code>transfrom</code>，就可以修改文本的大小写了。</p><p><img src="3.3.png"></p><p><strong>使用命令行启动 VS Code</strong></p><p>（1）输入快捷键「Cmd + Shift + P 」，选择<code>install code command</code>：</p><p><img src="3.4.png"></p><p>（2）使用命令行：</p><ul><li><code>code</code>命令：启动 VSCode 软件</li><li><code>code pathName/fileName</code>命令：通过 VSCode 打开指定目录/指定文件</li></ul><h2 id="四、私人订制-VSCode"><a href="#四、私人订制-VSCode" class="headerlink" title="四、私人订制 VSCode"></a>四、私人订制 VSCode</h2><h3 id="4-1-VSCode-设置为中文语言"><a href="#4-1-VSCode-设置为中文语言" class="headerlink" title="4.1 VSCode 设置为中文语言"></a>4.1 VSCode 设置为中文语言</h3><p>Mac 用户按住快捷键 <code>Cmd+Shift+P</code> （Windows 用户按住快捷键<code>Ctrl+Shift+P</code>），打开命令面板。</p><p>在命令面板中，输入<code>Configure Display Language</code>，选择<code>Install additional languages</code>，然后安装插件<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>即可。</p><p>或者，我们可以直接安装插件<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>，是一样的。</p><p>安装完成后，重启 VSCode。</p><h3 id="4-2-面包屑（Breadcrumb）"><a href="#4-2-面包屑（Breadcrumb）" class="headerlink" title="4.2 面包屑（Breadcrumb）"></a>4.2 面包屑（Breadcrumb）</h3><p>打开 VSCode 的设置项，选择「用户设置 -&gt; 工作台 -&gt; 导航路径」，如下图所示：</p><p><img src="4.2.1.png"></p><p>上图中，将红框部分打钩即可。</p><p>设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：</p><p><img src="4.2.2.png"></p><p>有了这个面包屑导航，我们可以在任意目录、任意文件之间随意跳转。</p><h3 id="4-3-左右显示多个编辑器窗口（抄代码利器）"><a href="#4-3-左右显示多个编辑器窗口（抄代码利器）" class="headerlink" title="4.3 左右显示多个编辑器窗口（抄代码利器）"></a>4.3 左右显示多个编辑器窗口（抄代码利器）</h3><p>Mac 用户按住快捷键 <code>Cmd + \</code>， Windows 用户按住快捷键<code>Ctrl + \</code>，即可同时打开多个编辑器窗口，效果如下：</p><p><img src="4.3.gif"></p><p>按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口。随时随地，想切就切。</p><p>学会了这一招，以后再抄代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。</p><h3 id="4-4-是否显示代码的行号"><a href="#4-4-是否显示代码的行号" class="headerlink" title="4.4 是否显示代码的行号"></a>4.4 是否显示代码的行号</h3><p>VSCode 默认显示代码的行号。你可以在设置项里搜索 <code>editor.lineNumbers</code>修改设置，配置项如下：</p><p><img src="4.4.png"></p><p>我建议保留这个设置项，无需修改。</p><h3 id="4-5-右侧是否显示代码的缩略图"><a href="#4-5-右侧是否显示代码的缩略图" class="headerlink" title="4.5 右侧是否显示代码的缩略图"></a>4.5 右侧是否显示代码的缩略图</h3><p>VSCode 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 <code>editor.minimap</code>进行设置，配置项如下：</p><p><img src="4.5.png"></p><h3 id="4-6-将当前行代码高亮显示（更改光标所在行的背景色）"><a href="#4-6-将当前行代码高亮显示（更改光标所在行的背景色）" class="headerlink" title="4.6 将当前行代码高亮显示（更改光标所在行的背景色）"></a>4.6 将当前行代码高亮显示（更改光标所在行的背景色）</h3><p>当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想<strong>高亮显示</strong>当前行的代码，需要设置两步：</p><p>（1）在设置项里搜索<code>editor.renderLineHighlight</code>，将选项值设置为<code>all</code>或者<code>line</code>。</p><p>（2）在设置项里增加如下内容：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"workbench.colorCustomizations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.lineHighlightBackground"</span><span class="token operator">:</span> <span class="token string">"#00000090"</span><span class="token punctuation">,</span>    <span class="token property">"editor.lineHighlightBorder"</span><span class="token operator">:</span> <span class="token string">"#ffffff30"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。</p><h3 id="4-7-改完代码后立即自动保存"><a href="#4-7-改完代码后立即自动保存" class="headerlink" title="4.7 改完代码后立即自动保存"></a>4.7 改完代码后立即自动保存</h3><p><strong>方式一</strong>：</p><p>改完代码后，默认不会自动保存。你可以在设置项里搜索<code>files.autoSave</code>，修改配置项如下：</p><p><img src="4.7.png"></p><p>上图中，我们将配置项修改为<code>onFocusChange</code>之后，那么，当光标离开该文件后，这个文件就会自动保存了。<strong>非常方便</strong>。</p><p><strong>方式二</strong>：</p><p>当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。</p><h3 id="4-8-保存代码后，是否立即格式化"><a href="#4-8-保存代码后，是否立即格式化" class="headerlink" title="4.8 保存代码后，是否立即格式化"></a>4.8 保存代码后，是否立即格式化</h3><p>保存代码后，默认<strong>不会立即</strong>进行代码的格式化。你可以在设置项里搜索<code>editor.formatOnSave</code>查看该配置项：</p><p><img src="4.8.png"></p><p>我觉得这个配置项保持默认就好，不用打钩。</p><h3 id="4-9-空格-or-制表符"><a href="#4-9-空格-or-制表符" class="headerlink" title="4.9 空格 or 制表符"></a>4.9 空格 or 制表符</h3><p>VSCode 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。</p><p>常见的设置项如下：</p><ul><li><strong>editor.detectIndentation</strong>：自动检测（默认开启）。截图如下：</li></ul><p><img src="4.9.1.png"></p><ul><li><strong>editor.insertSpaces</strong>：按 Tab 键时插入空格（默认）。截图如下：</li></ul><p><img src="4.9.2.png"></p><ul><li><strong>editor.tabSize</strong>：一个制表符默认等于四个空格。截图如下：</li></ul><p><img src="4.9.3.png"></p><h3 id="4-10-新建文件后的默认文件类型"><a href="#4-10-新建文件后的默认文件类型" class="headerlink" title="4.10 新建文件后的默认文件类型"></a>4.10 新建文件后的默认文件类型</h3><p>当我们按下快捷键「Cmd + N」新建文件时，VSCode 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。</p><p>如果你想修改默认的文件类型，可以在设置项里搜索<code>files.defaultLanguage</code>，设置项如下：</p><p><img src="4.10.png"></p><p>上图中的红框部分，填入你期望的默认文件类型。我填的是<code>html</code>类型，你也可以填写成 <code>javascript</code> 或者 <code>markdown</code>，或者其他的语言类型。</p><h3 id="4-11-删除文件时，是否弹出确认框"><a href="#4-11-删除文件时，是否弹出确认框" class="headerlink" title="4.11 删除文件时，是否弹出确认框"></a>4.11 删除文件时，是否弹出确认框</h3><p>当我们在 VSCode 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索<code>xplorer.confirmDelete</code>。截图如下：</p><p><img src="4.11.png"></p><p>我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一不小心删了呢？</p><blockquote><p>接下来，我们来讲一些更高级的配置。</p></blockquote><h3 id="4-12-文件对比"><a href="#4-12-文件对比" class="headerlink" title="4.12 文件对比"></a>4.12 文件对比</h3><p>VSCode 默认支持<strong>对比两个文件的内容</strong>。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：</p><p><img src="4.12.1.png"></p><p>VSCode 自带的对比功能并不够强大，我们可以安装插件<code>compareit</code>，进行更丰富的对比。比如说，安装完插件<code>compareit</code>之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：</p><p><img src="4.12.2.png"></p><h3 id="4-13-查找某个函数在哪些地方被调用了"><a href="#4-13-查找某个函数在哪些地方被调用了" class="headerlink" title="4.13 查找某个函数在哪些地方被调用了"></a>4.13 查找某个函数在哪些地方被调用了</h3><p>比如我已经在<code>a.js</code>文件里调用了 <code>foo()</code>函数。那么，如果我想知道<code>foo()</code>函数在其他文件中是否也被调用了，该怎么做呢？</p><p>做法如下：在 <code>a.js</code> 文件里，选中<code>foo()</code>函数（或者将光标放置在<code>foo()</code>函数上），然后按住快捷键「Shift + F12」，就能看到 <code>foo()</code>函数在哪些地方被调用了，比较实用。</p><h3 id="4-14-鼠标操作"><a href="#4-14-鼠标操作" class="headerlink" title="4.14 鼠标操作"></a>4.14 鼠标操作</h3><ul><li>在当前行的位置，鼠标三击，可以选中当前行。</li><li>用鼠标单击文件的<strong>行号</strong>，可以选中当前行。</li><li>在某个<strong>行号</strong>的位置，<strong>上下移动鼠标，可以选中多行</strong>。</li></ul><h3 id="4-15-重构"><a href="#4-15-重构" class="headerlink" title="4.15 重构"></a>4.15 重构</h3><p>重构分很多种，我们来举几个例子。</p><p><strong>命名重构</strong>：</p><p>当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。</p><p><strong>方法重构</strong>：</p><p>选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。</p><h3 id="4-16-在当前文件中搜索"><a href="#4-16-在当前文件中搜索" class="headerlink" title="4.16 在当前文件中搜索"></a>4.16 在当前文件中搜索</h3><p>在上面的快捷键列表中，我们已经知道如下快捷键：</p><ul><li>Cmd + F（Win 用户是 Ctrl + F）：在当前文件中搜索，光标在搜索框里</li><li>Cmd + G（Win 用户是 F3）：在当前文件中搜索，光标仍停留在编辑器里</li></ul><p>另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：</p><p><img src="4.16.1.png"></p><p>上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。</p><p>「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 <code>editor.find.autoFindInSelection</code>，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以<strong>自动</strong>只在这些内容里进行查找。该设置项如下图所示：</p><p><img src="4.16.2.png"></p><h3 id="4-17-全局搜索"><a href="#4-17-全局搜索" class="headerlink" title="4.17 全局搜索"></a>4.17 全局搜索</h3><p>在上面的快捷键列表中，我们已经知道如下快捷键：</p><ul><li>Cmd + Shift + F（Win 用户是 Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下：</li></ul><p><img src="4.17.png"></p><p>上图中，你可以点击红框部分，展开更多的配置项。</p><h3 id="4-18-Git-版本管理"><a href="#4-18-Git-版本管理" class="headerlink" title="4.18 Git 版本管理"></a>4.18 Git 版本管理</h3><p>VSCode 自带了 Git 版本管理，如下图所示：</p><p><img src="4.18.png"></p><p>上图中，我们可以在这里进行常见的 Git 命令操作。如果你还不熟悉 <strong>Git 版本管理</strong>，先去补补课吧。</p><p>与此同时，我建议安装插件<code>GitLens</code>，它是 VSCode 中我最推荐的一个插件，简直是 Git 神器，码农必备。</p><h3 id="4-19-将工作区放大-缩小"><a href="#4-19-将工作区放大-缩小" class="headerlink" title="4.19 将工作区放大/缩小"></a>4.19 将工作区放大/缩小</h3><p>我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。</p><p>如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「**cmd +/-**」。windows 用户是按下「ctrl +/-」</p><p><strong>当我们在投影仪上给别人演示代码的时候，这一招十分管用</strong>。</p><p>如果你想恢复默认的工作区大小，可以在命令面板输入<code>重置缩放</code>（英文是<code>reset zoom</code>）</p><h3 id="4-20-创建多层子文件夹"><a href="#4-20-创建多层子文件夹" class="headerlink" title="4.20 创建多层子文件夹"></a>4.20 创建多层子文件夹</h3><p>我们可以在新建文件夹的时候，如果直接输入<code>aa/bb/cc</code>，比如：</p><p><img src="4.20.1.png"></p><p>那么，就可以创建多层子文件夹，效果如下：</p><p><img src="4.20.2.png"></p><h3 id="4-21-vscode-文件夹的作用"><a href="#4-21-vscode-文件夹的作用" class="headerlink" title="4.21 .vscode 文件夹的作用"></a>4.21 <code>.vscode</code> 文件夹的作用</h3><p>为了统一团队的 vscode 配置，我们可以在项目的根目录下建立<code>.vscode</code>目录，在里面放置一些配置内容，比如：</p><ul><li><code>settings.json</code>：工作空间设置、代码格式化配置、插件配置。</li><li><code>sftp.json</code>：ftp 文件传输的配置。</li></ul><p><code>.vscode</code>目录里的配置只针对当前项目范围内生效。将<code>.vscode</code>提交到代码仓库，大家统一配置时，会非常方便。</p><h3 id="4-22-自带终端"><a href="#4-22-自带终端" class="headerlink" title="4.22 自带终端"></a>4.22 自带终端</h3><p>我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 <strong>item2</strong>。</p><h3 id="4-23-Markdown-语法支持"><a href="#4-23-Markdown-语法支持" class="headerlink" title="4.23 Markdown 语法支持"></a>4.23 Markdown 语法支持</h3><p>VSCode 自带 markdown 语法高亮。也就是说，如果你是用 Markdown 格式写文章，则完全可以用 VSCode 进行写作。</p><p>写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：</p><p><img src="4.23.png"></p><p>我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。</p><p>你也可以在控制面板输入<code>Markdown: 打开预览</code>，直接全屏预览 markdown 文件。</p><h3 id="4-24-Emmet-in-VSCode"><a href="#4-24-Emmet-in-VSCode" class="headerlink" title="4.24 Emmet in VSCode"></a>4.24 Emmet in VSCode</h3><p><code>Emmet</code>可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。</p><p>举个例子，我们在编辑器中输入缩写代码：<code>ul&gt;li*4</code> ，然后按下 Tab 键，即可得到如下代码片段：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>VS Code 默认支持 Emmet。更多 Emmet 语法规则，请自行查阅。</p><h3 id="4-25-修改字体，使用「Fira-Code」字体"><a href="#4-25-修改字体，使用「Fira-Code」字体" class="headerlink" title="4.25 修改字体，使用「Fira Code」字体"></a>4.25 修改字体，使用「Fira Code」字体</h3><p>这款字体很漂亮，很适合用来写代码：</p><p><img src="4.25.png"></p><p>安装步骤如下：</p><p>（1）进入 <a href="https://github.com/tonsky/FiraCode">https://github.com/tonsky/FiraCode</a> 网站，下载并安装「Fira Code」字体。</p><p>（2）打开 VS Code 的「设置」，搜索<code>font</code>，修改相关配置为如下内容：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"editor.fontFamily"</span><span class="token operator">:</span> <span class="token string">"'Fira Code',Menlo, Monaco, 'Courier New', monospace"</span><span class="token punctuation">,</span> // 设置字体显示<span class="token property">"editor.fontLigatures"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> // 控制是否启用字体连字，<span class="token boolean">true</span>启用，<span class="token boolean">false</span>不启用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上方的第二行配置，取决于个人习惯，我是直接设置为<code>"editor.fontLigatures": null</code>，因为我不太习惯连字。</p><h3 id="4-26-代码格式化：Prettier"><a href="#4-26-代码格式化：Prettier" class="headerlink" title="4.26 代码格式化：Prettier"></a>4.26 代码格式化：Prettier</h3><p>我们可以使用 <code>Prettier</code>进行代码格式化，会让代码的展示更加美观。步骤如下：</p><p>（1）安装插件 <code>Prettier</code>。</p><p>（2）在项目的根路径下，新建文件<code>.prettierrc</code>，并在文件中添加如下内容：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"printWidth"</span><span class="token operator">:</span> <span class="token number">150</span><span class="token punctuation">,</span>  <span class="token property">"tabWidth"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token property">"semi"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"singleQuote"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"trailingComma"</span><span class="token operator">:</span> <span class="token string">"es5"</span><span class="token punctuation">,</span>  <span class="token property">"tslintIntegration"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"insertSpaceBeforeFunctionParenthesis"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的内容，是我自己的配置，你可以参考。</p><p>更多配置，可以参考官方文档：<a href="https://prettier.io/docs/en/options.html">https://prettier.io/docs/en/options.html</a></p><h3 id="4-27-文件传输：sftp"><a href="#4-27-文件传输：sftp" class="headerlink" title="4.27 文件传输：sftp"></a>4.27 文件传输：sftp</h3><p>如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装<code>sftp</code>这个插件，很好用。在公司会经常用到。</p><p>步骤如下：</p><p>（1）安装插件<code>sftp</code>。</p><p>（2）配置 <code>sftp.json</code>文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入<code>sftp:config</code>，回车，当前工程的<code>.vscode</code>文件夹下就会自动生成一个<code>sftp.json</code>文件，我们需要在这个文件里配置的内容可以是：</p><ul><li><code>host</code>：服务器的 IP 地址</li><li><code>username</code>：用户名</li><li><code>privateKeyPath</code>：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）</li><li><code>remotePath</code>：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录</li><li><code>ignore</code>：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号</li></ul><p>举例如下：(注意，其中的注释需要去掉)</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"192.168.xxx.xxx"</span><span class="token punctuation">,</span> //服务器ip  <span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span> //端口，sftp模式是<span class="token number">22</span>  <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> //用户名  <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> //密码  <span class="token property">"protocol"</span><span class="token operator">:</span> <span class="token string">"sftp"</span><span class="token punctuation">,</span> //模式  <span class="token property">"agent"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"privateKeyPath"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"passphrase"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>  <span class="token property">"passive"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"interactiveAuth"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"remotePath"</span><span class="token operator">:</span> <span class="token string">"/root/node/build/"</span><span class="token punctuation">,</span> //服务器上的文件地址  <span class="token property">"context"</span><span class="token operator">:</span> <span class="token string">"./server/build"</span><span class="token punctuation">,</span> //本地的文件地址  <span class="token property">"uploadOnSave"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> //监听保存并上传  <span class="token property">"syncMode"</span><span class="token operator">:</span> <span class="token string">"update"</span><span class="token punctuation">,</span>  <span class="token property">"watcher"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    //监听外部文件    <span class="token property">"files"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> //外部文件的绝对路径    <span class="token property">"autoUpload"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token property">"autoDelete"</span><span class="token operator">:</span> <span class="token boolean">false</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"ignore"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    //忽略项    <span class="token string">"**/.vscode/**"</span><span class="token punctuation">,</span>    <span class="token string">"**/.git/**"</span><span class="token punctuation">,</span>    <span class="token string">"**/.DS_Store"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）在 VS Code 的当前文件里，选择「右键 -&gt; upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 <code>host</code> 中配置的服务器 ip）。</p><p>我们还可以选择「右键 -&gt; Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比。</p><h3 id="4-28-自定义代码颜色"><a href="#4-28-自定义代码颜色" class="headerlink" title="4.28 自定义代码颜色"></a>4.28 自定义代码颜色</h3><blockquote><p>进入 VSCode ，按 F1 ，搜索 <strong>Developer: Inspect Editor Tokens and Scopes</strong> ，并点击</p></blockquote><p><img src="4.28.1.png"></p><p>鼠标移到需要换颜色的代码上单击，将 foreground 对应的第一行作用域复制下来：</p><p><img src="4.28.2.png"></p><p>打开 <code>settings.json</code> 文件，我的配置可以参考一下：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"files.autoSave"</span><span class="token operator">:</span> <span class="token string">"afterDelay"</span><span class="token punctuation">,</span>  <span class="token property">"less.compile"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"compress"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> // <span class="token boolean">true</span> => remove surplus whitespace    <span class="token property">"sourceMap"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> // <span class="token boolean">true</span> => generate source maps (.css.map files<span class="token punctuation">)</span>    <span class="token property">"out"</span><span class="token operator">:</span> <span class="token boolean">true</span> // <span class="token boolean">false</span> => DON'T output .css files (overridable per-file<span class="token punctuation">,</span> see below<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"editor.tabSize"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token property">"vetur.validation.template"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"eslint.enable"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"window.zoomLevel"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token property">"files.associations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"*.cjson"</span><span class="token operator">:</span> <span class="token string">"jsonc"</span><span class="token punctuation">,</span>    <span class="token property">"*.wxss"</span><span class="token operator">:</span> <span class="token string">"css"</span><span class="token punctuation">,</span>    <span class="token property">"*.wxs"</span><span class="token operator">:</span> <span class="token string">"javascript"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"emmet.includeLanguages"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"wxml"</span><span class="token operator">:</span> <span class="token string">"html"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"minapp-vscode.disableAutoConfig"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"[javascript]"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"vscode.typescript-language-features"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"[vue]"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"esbenp.prettier-vscode"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"editor.tokenColorCustomizations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"comments"</span><span class="token operator">:</span> <span class="token string">"#00ff00"</span><span class="token punctuation">,</span> // 注释的斜杠    <span class="token property">"keywords"</span><span class="token operator">:</span> <span class="token string">"#dd8dd8"</span><span class="token punctuation">,</span> // 关键字    <span class="token property">"variables"</span><span class="token operator">:</span> <span class="token string">"#00ffff"</span><span class="token punctuation">,</span> // 变量名    <span class="token property">"strings"</span><span class="token operator">:</span> <span class="token string">"#bbffaa"</span><span class="token punctuation">,</span> // 字符串    <span class="token property">"functions"</span><span class="token operator">:</span> <span class="token string">"#ffff00"</span><span class="token punctuation">,</span> // 函数名    <span class="token property">"numbers"</span><span class="token operator">:</span> <span class="token string">"#DD8066"</span><span class="token punctuation">,</span> // 数字    <span class="token property">"textMateRules"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Comment"</span><span class="token punctuation">,</span> // 注释内容        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"comment"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#00ff00"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"[VSCODE-CUSTOM] PHP Punctuation Variable Definition"</span><span class="token punctuation">,</span>        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"punctuation.definition.variable.php"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#dd6f6f"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span> // 字符串        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"string"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#bbffaa"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"HTML:Tags"</span><span class="token punctuation">,</span> // 标签尖括号        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token string">"meta.tag"</span><span class="token punctuation">,</span>          <span class="token string">"punctuation.definition.tag.html"</span><span class="token punctuation">,</span>          <span class="token string">"punctuation.definition.tag.begin.html"</span><span class="token punctuation">,</span>          <span class="token string">"punctuation.definition.tag.end.html"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#66bfad"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"HTML:Tag Names"</span><span class="token punctuation">,</span> // 标签名        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"entity.name.tag"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#ee6c66"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"HTML: Attribute Names"</span><span class="token punctuation">,</span> // 标签内属性名        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token string">"meta.tag entity.other.attribute-name"</span><span class="token punctuation">,</span>          <span class="token string">"entity.other.attribute-name.html"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">"italic"</span><span class="token punctuation">,</span> // 斜体          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#ffff00"</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Operator"</span><span class="token punctuation">,</span> // 关键字        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"keyword.operator"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#ad8dda"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"property"</span><span class="token punctuation">,</span> // 普通对象中的属性        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"meta.object-literal.key.js"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#04fdf1"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"prototype"</span><span class="token punctuation">,</span> // 原型对象        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"support.variable.property.js"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#04fdf1"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"!important"</span><span class="token punctuation">,</span> // CSS的!important        <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"keyword.other.important.css"</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"foreground"</span><span class="token operator">:</span> <span class="token string">"#f00"</span><span class="token punctuation">,</span>          <span class="token property">"fontStyle"</span><span class="token operator">:</span> <span class="token string">""</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"workbench.colorCustomizations"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.selectionBackground"</span><span class="token operator">:</span> <span class="token string">"#3390ff"</span> // 选中高亮的颜色  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"[jsonc]"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"esbenp.prettier-vscode"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"workbench.colorTheme"</span><span class="token operator">:</span> <span class="token string">"Ayu Mirage"</span><span class="token punctuation">,</span>  <span class="token property">"workbench.iconTheme"</span><span class="token operator">:</span> <span class="token string">"vscode-icons"</span><span class="token punctuation">,</span>  <span class="token property">"editor.fontSize"</span><span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">,</span>  <span class="token property">"[html]"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"editor.defaultFormatter"</span><span class="token operator">:</span> <span class="token string">"esbenp.prettier-vscode"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、VSCode-插件推荐"><a href="#五、VSCode-插件推荐" class="headerlink" title="五、VSCode 插件推荐"></a>五、VSCode 插件推荐</h2><p>VSCode 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。我来列举几个常见的插件，这些插件都很实用。注意：<strong>顺序越靠前，越实用</strong>。</p><h3 id="5-0-LeetCode-【荐】"><a href="#5-0-LeetCode-【荐】" class="headerlink" title="5.0 LeetCode 【荐】"></a>5.0 LeetCode 【荐】</h3><p>这个插件可以直接在 VSCode 中练习算法并提交到官网账号下，美中不足的是不能像在官网一样看到题解答案。</p><h3 id="5-1-GitLens-【荐】"><a href="#5-1-GitLens-【荐】" class="headerlink" title="5.1 GitLens 【荐】"></a>5.1 GitLens 【荐】</h3><p>强烈建议安装<code>GitLens</code>，在协作开发中，它是最不可或缺的一个插件。</p><p>GitLens 在 Git 管理上有很多强大的功能，比如：</p><ul><li>将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。</li><li>查看某个 commit 的代码改动记录</li><li>查看不同的分支</li><li>可以将两个 commit 进行代码对比</li><li>甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招。</li></ul><h3 id="5-2-Git-History"><a href="#5-2-Git-History" class="headerlink" title="5.2 Git History"></a>5.2 Git History</h3><p>有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。</p><h3 id="5-3-Live-Server-【荐】"><a href="#5-3-Live-Server-【荐】" class="headerlink" title="5.3 Live Server 【荐】"></a>5.3 Live Server 【荐】</h3><p>在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。</p><p>使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。</p><h3 id="5-4-Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#5-4-Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="5.4 Chinese (Simplified) Language Pack for Visual Studio Code"></a>5.4 Chinese (Simplified) Language Pack for Visual Studio Code</h3><p>让软件显示为简体中文语言。</p><h3 id="5-5-Bracket-Pair-Colorizer-2：突出显示成对的括号【荐】"><a href="#5-5-Bracket-Pair-Colorizer-2：突出显示成对的括号【荐】" class="headerlink" title="5.5 Bracket Pair Colorizer 2：突出显示成对的括号【荐】"></a>5.5 Bracket Pair Colorizer 2：突出显示成对的括号【荐】</h3><p><code>Bracket Pair Colorizer 2</code>插件：以不同颜色显示成对的括号，并用连线标注括号范围。简称<strong>彩虹括号</strong>。</p><p>另外，还有个<code>Rainbow Brackets</code>插件，也可突出显示成对的括号。</p><h3 id="5-6-sftp：文件传输-【荐】"><a href="#5-6-sftp：文件传输-【荐】" class="headerlink" title="5.6 sftp：文件传输 【荐】"></a>5.6 sftp：文件传输 【荐】</h3><p>如果你需要将本地文件通过 ftp 的形式上传到局域网服务器，可以安装<code>sftp</code>这个插件。</p><p>详细配置已经在上面讲过。</p><h3 id="5-7-highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】"><a href="#5-7-highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】" class="headerlink" title="5.7 highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】"></a>5.7 highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】</h3><p>VSCode 自带的高亮显示，实在是不够显眼。用插件支持一下吧。</p><p>所用了这个插件之后，VS Code 自带的高亮就可以关掉了：</p><p>在用户设置里添加<code>"editor.selectionHighlight": false</code>即可。</p><p>参考链接：<a href="https://blog.csdn.net/palmer_kai/article/details/79548164">vscode 选中后相同内容高亮插件推荐</a></p><h3 id="5-8-vscode-icons"><a href="#5-8-vscode-icons" class="headerlink" title="5.8 vscode-icons"></a>5.8 vscode-icons</h3><p>vscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。</p><h3 id="5-9-Project-Manager"><a href="#5-9-Project-Manager" class="headerlink" title="5.9 Project Manager"></a>5.9 Project Manager</h3><p>工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。</p><h3 id="5-10-TODO-Highlight"><a href="#5-10-TODO-Highlight" class="headerlink" title="5.10 TODO Highlight"></a>5.10 TODO Highlight</h3><p>写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写<code>TODO</code>，而不是小写的<code>todo</code>）</p><pre><code>//TODO:这里有个bug，我一会儿再收拾你</code></pre><p>或者：</p><pre><code>//FIXME:我也不知道为啥， but it works only that way.</code></pre><p>安装了插件 <code>TODO Highlight</code>之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。</p><h3 id="5-11-WakaTime-【荐】"><a href="#5-11-WakaTime-【荐】" class="headerlink" title="5.11 WakaTime 【荐】"></a>5.11 WakaTime 【荐】</h3><p>统计在 VS Code 里写代码的时间。统计效果如下：</p><p><img src="5.11.png"></p><h3 id="5-12-Markdown-Preview-Github-Styling-【荐】"><a href="#5-12-Markdown-Preview-Github-Styling-【荐】" class="headerlink" title="5.12 Markdown Preview Github Styling 【荐】"></a>5.12 Markdown Preview Github Styling 【荐】</h3><p>以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果：</p><p><img src="5.12.png"></p><h3 id="5-13-Settings-Sync【荐】"><a href="#5-13-Settings-Sync【荐】" class="headerlink" title="5.13 Settings Sync【荐】"></a>5.13 Settings Sync【荐】</h3><ul><li>地址：<a href="https://github.com/shanalikhan/code-settings-sync">https://github.com/shanalikhan/code-settings-sync</a></li><li>作用：多台设备之间，同步 VS Code 配置。通过登录 GitHub 账号来使用这个同步工具。</li></ul><p>同步的详细操作已在上面讲过。</p><h3 id="5-14-Vetur"><a href="#5-14-Vetur" class="headerlink" title="5.14 Vetur"></a>5.14 Vetur</h3><p>Vue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VSCode 官方钦定 Vue 插件。</p><h3 id="5-15-ES7-React-Redux-GraphQL-React-Native-snippets"><a href="#5-15-ES7-React-Redux-GraphQL-React-Native-snippets" class="headerlink" title="5.15 ES7 React/Redux/GraphQL/React-Native snippets"></a>5.15 ES7 React/Redux/GraphQL/React-Native snippets</h3><p>React/Redux/react-router 的语法智能提示。</p><h3 id="5-16-minapp：小程序支持"><a href="#5-16-minapp：小程序支持" class="headerlink" title="5.16 minapp：小程序支持"></a>5.16 minapp：小程序支持</h3><p>小程序开发必备插件。</p><h3 id="5-17-Prettier：代码格式化"><a href="#5-17-Prettier：代码格式化" class="headerlink" title="5.17 Prettier：代码格式化"></a>5.17 Prettier：代码格式化</h3><p>Prettier 是一个代码格式化工具，只关注格式化，但不具备校验功能。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高。</p><h3 id="5-18-ESLint：代码格式校验"><a href="#5-18-ESLint：代码格式校验" class="headerlink" title="5.18 ESLint：代码格式校验"></a>5.18 ESLint：代码格式校验</h3><p>日常开发中，建议用 Prettier 做代码格式化，相比 Beautify 好不少，然后用 eslint 做校验。</p><h3 id="5-19-Search-node-modules-【荐】"><a href="#5-19-Search-node-modules-【荐】" class="headerlink" title="5.19 Search node_modules 【荐】"></a>5.19 Search node_modules 【荐】</h3><p><code>node_modules</code>模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 <code>Search node_modules</code> 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 <code>node_modules</code>，在弹出的选项中选择 <code>Search node_modules</code>，即可搜索 node_modules 里的模块。</p><h3 id="5-20-javascript-console-utils：快速打印-log-日志【荐】"><a href="#5-20-javascript-console-utils：快速打印-log-日志【荐】" class="headerlink" title="5.20 javascript console utils：快速打印 log 日志【荐】"></a>5.20 javascript console utils：快速打印 log 日志【荐】</h3><p>安装好这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 <code>console.log()</code>。简直是日志党福音。</p><p>当我们选中某个变量 <code>name</code>，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 <code>console.log(name)</code>。</p><p>其他的同类插件还有：Turbo Console Log。</p><p>不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。</p><ul><li>打日志，这是最简单、便捷的方式，略显低级，一般新手或资深程序员偷懒时会用。</li><li>断点调试，在前端、Java、PHP、iOS 开发时非常常用，通过断点调试可以很直观地跟踪代码执行逻辑、调用栈、变量等，是非常实用的技巧。</li><li>测试驱动开发，在写代码之前先写测试。与第二的断点调试刚好相反，大部分人不是很习惯这种方式，但在国外开发者或者敏捷爱好者看来，这是最高效的开发方式，在保证代码质量、重构等方面非常有帮助，是现代编程开发必不可少的一部分。</li></ul><h3 id="5-21-Code-Spell-Checker：单词拼写错误检查"><a href="#5-21-Code-Spell-Checker：单词拼写错误检查" class="headerlink" title="5.21 Code Spell Checker：单词拼写错误检查"></a>5.21 Code Spell Checker：单词拼写错误检查</h3><p>这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish.</p><h3 id="5-22-Local-History-【荐】"><a href="#5-22-Local-History-【荐】" class="headerlink" title="5.22 Local History 【荐】"></a>5.22 Local History 【荐】</h3><p>维护文件的本地历史记录，强烈建议安装。代码意外丢失时，有时可以救命。</p><p><img src="5.22.png"></p><h3 id="5-23-Polacode-2020-【荐】"><a href="#5-23-Polacode-2020-【荐】" class="headerlink" title="5.23 Polacode-2020 【荐】"></a>5.23 Polacode-2020 【荐】</h3><p>可以把代码保存成美观的图片，主题不同，代码配色方案也不同，也可以自己设置边框颜色、大小、阴影。</p><p>有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。</p><h3 id="5-24-Image-Preview-【荐】"><a href="#5-24-Image-Preview-【荐】" class="headerlink" title="5.24 Image Preview 【荐】"></a>5.24 Image Preview 【荐】</h3><p>图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。</p><h3 id="5-25-Auto-Close-Tag、Auto-Rename-Tag"><a href="#5-25-Auto-Close-Tag、Auto-Rename-Tag" class="headerlink" title="5.25 Auto Close Tag、Auto Rename Tag"></a>5.25 Auto Close Tag、Auto Rename Tag</h3><p>自动闭合标签、自动对标签重命名。</p><h3 id="5-26-CSS-Peek"><a href="#5-26-CSS-Peek" class="headerlink" title="5.26 CSS Peek"></a>5.26 CSS Peek</h3><p>增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。</p><h3 id="5-27-Vue-CSS-Peek"><a href="#5-27-Vue-CSS-Peek" class="headerlink" title="5.27 Vue CSS Peek"></a>5.27 Vue CSS Peek</h3><p>CSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。</p><h3 id="5-28-Live-Share：实时编码分享"><a href="#5-28-Live-Share：实时编码分享" class="headerlink" title="5.28 Live Share：实时编码分享"></a>5.28 Live Share：实时编码分享</h3><p><code>Live Share</code>这个神奇的插件是由微软官方出品，它的作用是：<strong>实时编码分享</strong>。也就是说，它可以实现你和你的小伙伴一起写代码。这绝对就是<strong>结对编程</strong>的神器啊。</p><p>安装方式：</p><p>打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：</p><p><img src="5.28.1.png"></p><p>上图中，点击红框部分，登录后就可以分享你的工作空间了。</p><h3 id="5-29-Import-Cost"><a href="#5-29-Import-Cost" class="headerlink" title="5.29 Import Cost"></a>5.29 Import Cost</h3><p>在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。<code>Import Cost</code>插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。</p><h3 id="5-30-常见主题插件"><a href="#5-30-常见主题插件" class="headerlink" title="5.30 常见主题插件"></a>5.30 常见主题插件</h3><p>给你的 VSCode 换个皮肤吧，免费的那种：</p><ul><li><p>Dracula Theme</p></li><li><p>Material Theme</p></li><li><p>Nebula Theme</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme">One Dark Pro</a></p></li><li><p>One Monokai Theme</p></li><li><p>Monokai Pro</p></li><li><p>Ayu</p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=akarlsten.vscode-snazzy-akarlsten">Snazzy Plus</a></p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=alexanderte.dainty-vscode">Dainty</a></p></li><li><p><code>SynthWave '84</code></p></li><li><p>GitHub Plus Theme：白色主题</p></li><li><p>Horizon Theme：红色主题</p></li></ul><h2 id="六、VSCode-云同步"><a href="#六、VSCode-云同步" class="headerlink" title="六、VSCode 云同步"></a>六、VSCode 云同步</h2><p>VSCode 支持将配置云同步，当我们换个电脑时，即可将日常配置登录 GitHub 后同步到本地。</p><p>我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。</p><p><strong>将自己本地的配置云同步到 GitHub</strong>：</p><p>（1）安装插件 <code>settings-sync</code>。</p><p>（2）安装完插件后，在插件里使用 GitHub 账号登录。</p><p>（3）登录后在 VSCode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。</p><p>（4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。</p><p><strong>换另外一个电脑时，从云端同步配置到本地</strong>：</p><p>（1）当我们换另外一台电脑时，可以先在 VSCode 中安装 <code>settings-sync</code> 插件。</p><p>（2）安装完插件后，在插件里使用 GitHub 账号登录。</p><p>（3）登录之后，插件的界面上，会自动出现之前的同步记录：</p><p><img src="6.1.png"></p><p>上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：</p><p><img src="6.2.png"></p><p>如果你远程的配置没有成功同步到本地，那可能是网络的问题需要用 Clash 或 v2rayN 等 VPN，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。</p><p><strong>使用其他人的配置</strong>：</p><p>如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：</p><p>（1）安装插件 <code>settings-sync</code>。</p><p>（2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，选择「下载配置」</p><p>（3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 填坑之 error 整理</title>
      <link href="/2021/04/12/02.git/"/>
      <url>/2021/04/12/02.git/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Git-环境配置"><a href="#一、Git-环境配置" class="headerlink" title="一、Git 环境配置"></a>一、Git 环境配置</h2><p>下载安装流程就不一一赘述了，安装好之后在命令行输入 <code>git</code> 回车或鼠标右键界面空白处查看是否出现 <code>Git GUI Here</code> <code>Git Bash Here</code> 检查是否安装成功。</p><p>Git 安装好后再去 GitHub 上注册一个账号，注册好后，点击 <code>Git Bash</code>，用账号进行环境配置：</p><p><strong>配置用户名</strong></p><p><code>git config --global user.name "xxx" </code></p><p><strong>配置邮箱</strong></p><p><code>git config --global user.email "xxx@xxx.com"</code></p><p><strong>生成ssh</strong><br><code>ssh-keygen -t rsa</code></p><p>然后连敲三次回车键，结束后去系统盘目录下（一般在 C:\Users\你的用户名.ssh）(mac: /Users/用户/.ssh）查看是否有 <strong>ssh</strong> 文件夹生成，此文件夹中两个文件：<code>id_rsa</code> <code>id_rsa.pub</code></p><p>将ssh文件夹中的公钥（ id_rsa.pub）添加到 GitHub 管理平台中（貌似这样后面每次推送代码就不用重输账号密码了），在 GitHub 个人账户的设置中找到如下界面：</p><p><img src="1.1.png"></p><p><strong>Title</strong> 随便起一个，将公钥（ <strong>id_rsa.pub</strong>）文件中内容复制粘贴到 <strong>key</strong> 中，然后点击 <strong>Ass SSH key</strong> 添加成功。</p><p>在 <code>Git Bash</code> 中输入 <code>ssh -T git@github.com</code> 回车，若出现以下提示就说明配置好啦：</p><p><img src="1.2.png"></p><h2 id="二、Git-与-SVN"><a href="#二、Git-与-SVN" class="headerlink" title="二、Git 与 SVN"></a>二、Git 与 SVN</h2><h3 id="2-1-集中式-SVN"><a href="#2-1-集中式-SVN" class="headerlink" title="2.1 集中式(SVN)"></a>2.1 集中式(SVN)</h3><pre><code>SVN 因为每次存入的都是差异，需要的硬盘空间会相对的小一点，可是回滚的速度会很慢。优点: 代码存放在单一的服务器上，便于项目的管理。缺点: 服务器宕机：代码得不到保障。服务器炸了：整个项目的历史记录都会丢失。</code></pre><h3 id="2-2-分布式-Git"><a href="#2-2-分布式-Git" class="headerlink" title="2.2 分布式(Git)"></a>2.2 分布式(Git)</h3><pre><code>Git 每次存入的是项目的完整快照 需要的硬盘空间会相对大一点。Git 团队对代码做了极致压缩，最终需要的实际空间比 SVN 多不了太多，可是 Git 的回滚速度极快。</code></pre><h2 id="三、Git-命令"><a href="#三、Git-命令" class="headerlink" title="三、Git 命令"></a>三、Git 命令</h2><h3 id="3-1-底层命令（可跳过不实用）"><a href="#3-1-底层命令（可跳过不实用）" class="headerlink" title="3.1 底层命令（可跳过不实用）"></a>3.1 底层命令（可跳过不实用）</h3><pre><code>git对象git hash-object -w fileUrl: 生成一个key(hash值):val(压缩后的文件内容)键值对存到 .git/objectstree对象git update-index --add --cacheinfo 100644 hash test.txt: 往暂存区添加一条记录(让git对象对应上文件名)存到 .git/indexgit write-tree: 生成树对象存到 .git/objectscommit对象echo 'first commit' | git commit-tree treehash: 生成一个提交对象存到 .git/objects对以上对象的查询git cat-file -p hash: 拿对应对象的内容git cat-file -t hash: 拿对应对象的类型</code></pre><h3 id="3-2-查看暂存区"><a href="#3-2-查看暂存区" class="headerlink" title="3.2 查看暂存区"></a>3.2 查看暂存区</h3><pre><code>git ls-files -s</code></pre><h3 id="3-3-高层命令"><a href="#3-3-高层命令" class="headerlink" title="3.3 高层命令"></a>3.3 高层命令</h3><p><strong>查看 Git 版本</strong></p><pre><code>git --version</code></pre><p><strong>初始化配置</strong></p><pre><code>git config --global user.name "xxx"git config --global user.email xxx@xxx.com    git config --list</code></pre><p><strong>初始化仓库</strong></p><pre><code>git init</code></pre><p><strong>C (新增)</strong></p><pre><code>在工作目录中新增文件git status 查看文件的状态git add . 将修改添加到暂存区git commit -m "msg" 将暂存区提交到版本库</code></pre><p><strong>U(修改)</strong></p><pre><code>在工作目录中修改文件git status 查看文件的状态git add . 将修改添加到暂存区git commit -m "msg" 将暂存区提交到版本库</code></pre><p><strong>D(删除 &amp; 重命名)</strong></p><pre><code>git rm 要删除的文件git mv 原文件名 新文件名：将工作目录中的文件进行重命名,再将修改添加到暂存区。git rm 文件名：删除工作目录中对应的文件，再将修改添加到暂存区</code></pre><p><strong>R(查询)</strong></p><pre><code>git status: 查看工作目录中文件的状态(已跟踪(已提交 已暂存 已修改) 未跟踪)git diff: 查看未暂存的修改git diff --cache: 查看未提交的暂存git log --oneline: 查看提交记录</code></pre><h2 id="四、分支"><a href="#四、分支" class="headerlink" title="四、分支"></a>四、分支</h2><p><strong>分支的本质其实就是一个提交对象！</strong>所有的分支都会有机会被HEAD所引用(HEAD一个时刻只会指向一个分支)，当我们有新的提交时HEAD会携带当前持有的分支往前移动。<br><strong>HEAD：</strong><br>是一个指针，默认指向master分支，切换分支时其实就是让HEAD指向不同分支。<br>每次有新提交时，HEAD都会带着当前指向的分支一起往前移。</p><p><strong>分支命令：</strong></p><pre><code>git log --oneline --decorate --graph --all: 查看整个项目的分支图  git branch: 查看分支列表git branch -v: 查看分支指向的最新的提交git branch name: 基于当前分支创建新的分支git branch --orphan name: 不基于当前分支创建新的分支（分支间不相互关联）git branch name commithash: 在指定的提交对象上创建新的分支git checkout name: 切换分支git branch -d name: 删除空的分支 删除已经被合并的分支git branch -D name: 强制删除分支 创建分支: git branch branchname切换分支: git checkout  branchname创建&amp;切换分支: git checkout -b branchname版本穿梭(时光机): git branch branchname commitHash  普通删除分支: git branch -d branchname强制删除分支: git branch -D branchname合并分支: git merge branchname快进合并 --&gt; 不会产生冲突典型合并 --&gt; 有机会产生冲突解决冲突 --&gt; 打开冲突的文件进行修改 add commit </code></pre><pre><code>查看分支列表: git branch查看合并到当前分支的分支列表: git branch --merged一旦出现在这个列表中就应该删除查看没有合并到当前分支的分支列表: git branch&nbsp;--no-merged一旦出现在这个列表中就应该观察一下是否需要合并</code></pre><p><strong>分支的注意点：</strong></p><pre><code>在切换的时候一定要保证当前分支是干净的!动三个地方：HEAD、暂存区、工作目录    允许切换分支:         分支上所有的内容 处于已提交状态            (避免)分支上的内容是初始化创建 处于未跟踪状态        (避免)分支上的内容是初始化创建 第一次处于已暂存状态    不允许切分支:         分支上所有的内容处于 已修改状态或第二次以后的已暂存状态           在分支上的工作做到一半时 如果有切换分支的需求, 我们应该将现有的工作存储起来    git stash: 会将当前分支上的工作推到一个栈中    分支切换 进行其他工作 完成其他工作后 切回原分支    git stash apply: 将栈顶的工作内容还原 但不让任何内容出栈     git stash drop: 取出栈顶的工作内容后 就应该将其删除(出栈)    git stash pop: git stash apply +  git stash drop     git stash list: 查看存储</code></pre><p><strong>撤销操作：</strong></p><pre><code>工作区    撤销工作目录的修改: git checkout -- filename暂存区    撤销暂存区的修改: git reset HEAD  filename版本库    撤销提交: git commit --amend</code></pre><p><strong>reset：</strong></p><pre><code>git log、git reflog: HEAD有变化，git reflog就会记录下来。git reset --soft commithash 用commithash的内容重置HEAD内容。git reset [--mixed] commithash 用commithash的内容重置HEAD内容，重置暂存区。git reset --hard commithash 用commithash的内容重置HEAD内容，重置暂存区，重置工作目录。</code></pre><p><strong>路径 reset：</strong></p><pre><code>所有的路径reset都要省略第一步!第一步是重置HEAD内容，HEAD本质指向一个分支，分支的本质是一个提交对象，提交对象指向一个树对象，树对象又很有可能指向多个git对象，一个git对象代表一个文件，HEAD可以代表一系列文件的状态。git reset HEAD filename 动了暂存区git reset [--mixed] commithash filename 用commithash中filename的内容重置暂存区</code></pre><p><strong>checkout 深入理解：</strong></p><pre><code>git checkout brancname 跟 git reset --hard commithash特别像    共同点        都需要重置 HEAD 暂存区 工作目录    区别        checkout 对工作目录是安全的 reset --hard是强制覆盖        checkout 动HEAD时不会带着分支走而是切换分支        reset --hard 是带着分支走        checkout + 路径      git checkout commithash filename 重置暂存区、工作目录      git checkout -- filename 重置工作目录     </code></pre><h2 id="五、Eslint-结合-Git"><a href="#五、Eslint-结合-Git" class="headerlink" title="五、Eslint 结合 Git"></a>五、Eslint 结合 Git</h2><h3 id="5-1-Eslint"><a href="#5-1-Eslint" class="headerlink" title="5.1 Eslint"></a>5.1 Eslint</h3><pre><code>js代码的检查工具下载: npm i eslint -D使用:    生成配置文件: npx eslint --init    检查js文件: npx eslint 目录名    命中的规则:        字符串必须使用单引号        语句结尾不能有分号        文件的最后必须要有换行</code></pre><h2 id="六、协作"><a href="#六、协作" class="headerlink" title="六、协作"></a>六、协作</h2><h3 id="6-1-推送、拉取"><a href="#6-1-推送、拉取" class="headerlink" title="6.1 推送、拉取"></a>6.1 推送、拉取</h3><pre><code>正常的数据推送和拉取步骤：    1. 确保本地分支已经跟踪了远程跟踪分支    2. 拉取数据: git pull + 指定分支    3. 推送数据: git push + 指定分支    一个本地分支怎么去跟踪一个远程跟踪分支：    1. 当克隆的时候会自动生成一个master本地分支(已经跟踪了对应的远程跟踪分支)    2. 在新建其他分支时可以指定想要跟踪的远程跟踪分支，本地没有分支：            git checkout -b 本地分支名 远程跟踪分支名            git checkout --track 远程跟踪分支名(remote/分支名)    3. 将一个已经存在的本地分支改成一个跟踪分支，本地已经创建了分支：               git branch -u 远程跟踪分支名(remote/分支名) </code></pre><h3 id="6-2-团队协作"><a href="#6-2-团队协作" class="headerlink" title="6.2 团队协作"></a>6.2 团队协作</h3><pre><code>1. 仓库负责人初始化远程仓库：   一定要初始化一个空的仓库，在github或gitlab等平台上操作2. 仓库负责人创建本地仓库：    git remote 别名 仓库地址(https)    git init 将源码复制进来，修改用户名，修改邮箱    git add    git commit 3. 仓库负责人推送本地仓库到远程仓库：    清理Windows凭据    git push 别名 分支(输入用户名，密码，推完之后会附带生成远程跟踪分支)4. 仓库负责人邀请成员&amp;成员接受邀请，在github上操作5. 成员克隆远程仓库：   git clone 仓库地址(在本地生成.git文件 默认为远程仓库配了别名 orgin)   只有在克隆的时候，本地分支master和远程跟踪分支别名/master是有同步关系的6. 成员将本地分支和远程分支进行关联：   git remote add upstreamMaster git@xxx... // 配别名，关联master分支   git checkout branchName // 切换到要开发的分支   git fetch upstreamMaster xxxbranchName // 关联xxxbranchName分支   git merge upstreamMaster/xxxbranchName // 关联xxxbranchName分支   写代码   git pull 某分支 + git add . + git commit -m "[xxx]:msg" + git push 某分支7. 在gitlab或其他平台合并代码，在Jenkins或k8s等其他容器云平台构建即可8. 某个版本稳定后需要打标签封版，版本号的命名规范还请自行百度   查询版本：   git tag // 列出已有标签，了解当前的版本状态   git show &lt;tag_name&gt; // 查看特定标签信息：git show v1.0   git checkout -b &lt;branch_name&gt; &lt;tag_name&gt; // 检出特定标签   新增版本：   git tag &lt;tag_name&gt; &lt;commit_sha&gt; // 创建轻量标签：git tag v1.0 23a5df4   git tag -a &lt;tag_name&gt; -m "标签说明" &lt;commit_sha&gt; // 创建标签说明：git tag -a v1.0 -m "发布版本 1.0" 23a5df4   git push origin &lt;tag_name&gt; // 推送标签到远程仓库   git push origin --tags // 一次性推送所有标签   删除版本：   git tag -d &lt;tag_name&gt; // 删除某个标签   git push origin :refs/tags/&lt;tag_name&gt; // 推送删除后的标签到远程仓库</code></pre><h2 id="七、Error-Resolve"><a href="#七、Error-Resolve" class="headerlink" title="七、Error Resolve"></a>七、Error Resolve</h2><h3 id="7-1-conflict-代码冲突"><a href="#7-1-conflict-代码冲突" class="headerlink" title="7.1 conflict 代码冲突"></a>7.1 conflict 代码冲突</h3><p>多人协作开发、多分支开发时最容易出现的就是提交代码前拉取新代码冒出 conflict 冲突提示，其实只要事先约定好开发规范就能避免，其关键就是把一个稳定的分支版本作为基线，如经过测试后没问题的分支，其他的功能开发分支基于这个分支来进行拉取提交。</p><p>万一发生了冲突就用这三条指令：</p><pre><code>git stash // 把工作区的修改提交到栈区，把工作区有冲突的修改先隐藏保存git pull // 拉取指定的远程分支上的代码并合并到本地分支git stash pop // 把第一步保存在栈区的冲突部分合并到最新的工作空间中</code></pre><p>这时本地工作区会显示具体的冲突文件，如果是自己的冲突就自己处理后 add + commit 提交上去，如果是同事的冲突就呼叫他们处理即可。</p><h3 id="7-2-non-fast-forward"><a href="#7-2-non-fast-forward" class="headerlink" title="7.2 non-fast-forward"></a>7.2 non-fast-forward</h3><p><strong>问题描述：</strong><code>git push origin login</code> 报错。</p><p><strong>原因：</strong>远程库与本地库不一致导致。比如别人上传到远程仓库后，你没有及时的同步（拉取）到本地，但是你同时又添加了一些内容（提交），以致于你在提交时，它会检测到你之前从远程仓库拉取的时候的仓库状态和现在的不一样。于是，它为了安全起见拒绝了你的提交（然后就报了这个错误）。</p><p><strong>解决方案一：</strong>先合并之前的历史，再进行提交——提倡使用。</p><p>（1）先把 <strong>Git</strong> 的东西 <strong>fetch</strong> 到你本地然后 <strong>merge</strong> 后再 <strong>push</strong> 。</p><pre><code>$ git fetch origin login$ git merge origin FETCH_HEAD</code></pre><p>这2句命令等价于：<code>$ git pull origin login</code>，但是使用 <code>git fetch + git merge</code> 更加安全 </p><p>（2）重定基，可以使历史更加统一，提交历史趋向于一条直线。</p><pre><code>git pull --rebase origin login 意为先取消commit记录，临时保存为补丁之后同步远程库到本地，最后合并补丁到本地库之中</code></pre><p>补充：它们间的关系：</p><pre><code>git pull = git fetch + git merge FETCH_HEAD git pull --rebase =  git fetch + git rebase FETCH_HEAD</code></pre><p>接着输入 <code>git status</code> 可能会报错：</p><p><img src="7.1.png"></p><p>提示 amend 或 continue，amend会继续报错，而continue则会提交本地修改完成修复：</p><pre><code>git rebase --continuegit push origin login（查看GitHub上login分支没问题了）</code></pre><p><strong>解决方案二：</strong>放弃之前的历史，<strong>强推</strong>（用强覆盖方式用你本地的代码替代 Git 仓库内的内容）——谨慎使用。</p><pre><code>$ git push -f  或 $ git push --force</code></pre><blockquote><p>官方文档提示：This flag disables these checks, and can cause the remote repository to lose commits; use it with care.（即：此标志禁用这些检查，并可能导致远程存储库丢失提交；小心使用。）</p></blockquote><h3 id="7-3-failed-to-push-some-refs-to-‘https-github-com-…"><a href="#7-3-failed-to-push-some-refs-to-‘https-github-com-…" class="headerlink" title="7.3 failed to push some refs to ‘https://github.com/…"></a>7.3 failed to push some refs to ‘<a href="https://github.com/">https://github.com/</a>…</h3><p><strong>问题描述：</strong>在 git bash 中键入 $ git push origin master 提交时出现。</p><p><strong>原因：</strong>远程库与本地库不一致导致，在 hint 中也有提示把远程库同步到本地库即可。</p><p><strong>解决方案：</strong></p><pre><code>git pull --rebase origin master</code></pre><p>该命令的意思是把远程库中的更新合并到（pull = fetch + merge）本地库中，–-rebase 的作用是取消掉本地库中刚刚的 commit，并把它们对接到更新后的版本库之中。</p><h3 id="7-4-…-you-have-unmerged-files"><a href="#7-4-…-you-have-unmerged-files" class="headerlink" title="7.4 … you have unmerged files"></a>7.4 … you have unmerged files</h3><p><strong>问题描述：</strong>将本地代码提交到 GitHub 后某些组件插件或其他文件夹丢失。</p><p><strong>原因：</strong>使用 Git 时，没有提前 <code>git pull</code>，就把自己本地修改的文件 <code>git add</code>、<code>git commit</code>，就会出现 “ … you have unmerged files.” 的 error。</p><p><strong>解决方案：</strong></p><pre><code>git reflog：复制以前分支的 hashgit reset --hard hash：回溯之前版本</code></pre><p>然后重新提交：</p><pre><code>git statusgit add . git commit -m "msg"</code></pre><p><code>git push origin 分支</code> 可能会出现报错：<code>non-fast-forward</code> ,参考上述解决方案。</p><h3 id="7-5-删除-node-modules"><a href="#7-5-删除-node-modules" class="headerlink" title="7.5 删除 node_modules"></a>7.5 删除 node_modules</h3><p><strong>场景：</strong>需要删掉整个项目，或某些操作导致各种包依赖环境相互冲突报错又忘记该具体卸载哪个包时。</p><p><strong>问题描述：</strong>清空 node_modules 文件夹时由于文件数量大，左上角系统不停计算剩余文件的进度条导致删除缓慢。</p><p><strong>解决方案：在node_modules所在当前目录下执行</strong></p><pre><code>rm -rf node_modules</code></pre><h3 id="7-6-error-setting-certificate-verify-locations"><a href="#7-6-error-setting-certificate-verify-locations" class="headerlink" title="7.6 error setting certificate verify locations"></a>7.6 error setting certificate verify locations</h3><p><strong>问题描述：</strong>执行 <code>git push origin master</code> 命令时出错:</p><pre><code>fatal: unable to access ‘https://github.com/…/’: error setting certificate verify locations:CAfile: D:/Git/Git/mingw64/ssl/certs/ca-bundle.crtCApath: none</code></pre><p><strong>解决方案：</strong></p><p>（1）<code>git config –system http.sslcainfo “C:\Program Files (x86)\git\bin\curl-ca-bundle.crt”</code></p><p>（2）<code>git config –system http.sslverify false</code></p><p>（3）顺着报错信息在文件树里找，发现：<strong>D:/Git/mingw64/libexec 没有 ssl 目录</strong>。但在 <strong>D:\Git\mingw64</strong> 目录下有 <strong>ssl/certs/ca-bundle.crt</strong> 这个路径。将 <strong>ssl 目录</strong> 复制到 <strong>D:/Git/mingw64/libexec</strong> 下即可。</p><h3 id="7-7-Git-Bash-Here-失效"><a href="#7-7-Git-Bash-Here-失效" class="headerlink" title="7.7 Git Bash Here 失效"></a>7.7 Git Bash Here 失效</h3><p><strong>问题描述：</strong>在某个文件夹下右键选择 <code>git bash/gui here</code> ，结果显示 <strong>“找不到应用程序”</strong>，这是 Git 相关的文件路径变更导致的。</p><p><strong>解决方案：</strong></p><p>（1）<strong>win + R</strong> 打开命令行窗口，输入 <strong>regedit</strong> 打开注册表。</p><p>（2）根据路径查找 [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\git_shell\command] 和[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\git_shell\command] 。</p><p>将其数值数据里面的路径修改为现在的 <strong>git bash.exe</strong> 的路径：</p><p><img src="7.6.1.png"></p><p>将其 <strong>git_shell</strong> 改为 <strong>git_gui</strong> ，找到两个路径，将其数值数据里面的路径修改为现在的 <strong>git gui.exe</strong> 的路径<br>关闭注册表，接着在文件夹右键选择 <strong>git bash/gui here</strong> ，发现可以打开，完成。</p><p>然后你会发现<strong>新问题</strong>：git clone 不好用，<strong>解决：</strong>在 Git 安装包下，找到 <strong>gitconfig</strong> 文件修改里边的路径信息</p><p><img src="7.6.2.png"></p><p><img src="7.6.3.png"></p><p>这里改好就好了，记住安装完 Git <strong>不要随便移动路径</strong>，因为注册表中的信息不会改变。</p><h3 id="7-8-管理小程序"><a href="#7-8-管理小程序" class="headerlink" title="7.8 管理小程序"></a>7.8 管理小程序</h3><p>和管理日常项目流程如出一撤，具体如何用 Git 管理小程序就不一一赘述了，有需要可以看这篇：<a href="https://blog.csdn.net/qq_36672905/article/details/82887102">微信小程序如何使用Git实现版本管理</a></p><p>说下遇到的问题：<code>push</code> 远程仓库提示 <code>error invalid authentication scheme</code></p><p><strong>解决方案：</strong>在微信小程序的设置里面配置仓库设置中的网络认证，认证选择用户名和密码，然后填写好你创建远程仓库时候设置的用户名和密码。</p><p><img src="7.7.png"></p><h3 id="7-9-问题征集"><a href="#7-9-问题征集" class="headerlink" title="7.9 问题征集"></a>7.9 问题征集</h3><p>到此为止关于 Git 相关的知识就整理完毕了，阿呆暂时只遇到了这些问题，以后出现新问题我会及时整理更新，诸君有其他的疑问也欢迎在评论区留言哦。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
            <tag> ESLint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 使用详解（附图文）</title>
      <link href="/2020/12/28/01.markdown/"/>
      <url>/2020/12/28/01.markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        一般首页会有个 <strong>README.md</strong> 说明文件，可以使用以下命令生成：</p><pre><code>git add README.md</code></pre><h2 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h2><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">加粗</td><td align="center">Ctrl + B</td></tr><tr><td align="center">斜体</td><td align="center">Ctrl + I</td></tr><tr><td align="center">引用</td><td align="center">Ctrl + Q</td></tr><tr><td align="center">插入链接</td><td align="center">Ctrl + L</td></tr><tr><td align="center">插入代码</td><td align="center">Ctrl + K</td></tr><tr><td align="center">插入图片</td><td align="center">Ctrl + G</td></tr><tr><td align="center">提升标题</td><td align="center">Ctrl + H</td></tr><tr><td align="center">有序列表</td><td align="center">Ctrl + O</td></tr><tr><td align="center">无序列表</td><td align="center">Ctrl + U</td></tr><tr><td align="center">横线</td><td align="center">Ctrl + R</td></tr><tr><td align="center">撤销</td><td align="center">Ctrl + Z</td></tr><tr><td align="center">重做</td><td align="center">Ctrl + Y</td></tr></tbody></table><h2 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h2><h3 id="2-1-字体斜体、粗体、删除线"><a href="#2-1-字体斜体、粗体、删除线" class="headerlink" title="2.1 字体斜体、粗体、删除线"></a>2.1 字体斜体、粗体、删除线</h3><p>*斜体* =&gt; <em>斜体</em>、_斜体_ =&gt; _斜体_、**加粗** =&gt; <strong>加粗</strong>、***倾斜加粗*** =&gt; <em><strong>倾斜加粗</strong></em>、~~ 删除线~~ =&gt; <del>删除线</del></p><p><img src="font.png"></p><h3 id="2-2-分级标题"><a href="#2-2-分级标题" class="headerlink" title="2.2 分级标题"></a>2.2 分级标题</h3><p><strong>写法1：</strong><br># 一级标题、## 二级标题、### 三级标题、#### 四级标题、##### 五级标题、###### 六级标题</p><p><img src="title_01.png"></p><p><strong>写法2：</strong><br>一级标题：在一级标题下一行加一个或多个“=”；二级标题：在二级标题下一行加一个或多个“-”</p><p><img src="title_02.png"></p><h3 id="2-3-链接"><a href="#2-3-链接" class="headerlink" title="2.3 链接"></a>2.3 链接</h3><p>（1）普通链接：将链接地址用 &lt; &gt; 包起来：</p><p><img src="link.png"></p><p>（2）插入图片链接： ![图片描述](图片url)（图片描述可省略）<br>（3）参考链接：[关键字](链接地址 “添加一个标题（可选）”)</p><blockquote><p>注意：配合 Hexo 使用可能会遇到这种情况，本地编辑器上的图片 url 使用相对路径可以显示，但 hexo g + hexo s 打包后失效。</p><p>建议：暂时缘由不明，研究发现将 xxx.md 对应所有图片放在文件夹 xxx 中（取名一致），且处于同一层目录下即可。</p></blockquote><h3 id="2-4-分割线"><a href="#2-4-分割线" class="headerlink" title="2.4 分割线"></a>2.4 分割线</h3><p>在一行中用三个以上的星号(*)、减号(-)或底线(_)生成分隔线，行内不能有其他东西。也可以在星号或减号中间插入空格。</p><p><img src="cross_line.png"></p><h3 id="2-5-代码块"><a href="#2-5-代码块" class="headerlink" title="2.5 代码块"></a>2.5 代码块</h3><p><strong>写法1：</strong><br>缩进4个空格或一个制表符（Tab）<br><strong>写法2：</strong><br>（1）用英文的单反引号（在 Esc 键下方，和 ~ 同一个键）包裹代码，多行代码需要在代码块上一行和下一行使用三个单反引号包裹，同时可在第一行反引号后面，输入代码块所使用的语言，实现代码高亮。</p><p><img src="code_block_01.png"></p><p>（2）在代码块中， &amp; 、 &lt; 和 &gt; 会被 Markdown 自动转成 HTML 实体，示例：</p><p><img src="code_block_02.png"></p><h3 id="2-6-引用"><a href="#2-6-引用" class="headerlink" title="2.6 引用"></a>2.6 引用</h3><p>（1）在被引用的文本前加 &gt; 号和一个空格，只输入了一个 &gt; 号会产生一个空白的引用：</p><p><img src="quote_01.png"></p><p>（2）引用嵌套使用：</p><p><img src="quote_02.png"></p><p>（3）引用内也可加其他 Markdown 语法，包括标题、列表、代码块等这里不一一演示。</p><h3 id="2-7-列表"><a href="#2-7-列表" class="headerlink" title="2.7 列表"></a>2.7 列表</h3><p>（1）无序列表：使用 *，+，- 符号表示无序列表，符号后面<strong>一腚要有个空格</strong>。</p><p><img src="list_01.png"></p><p>（2）有序列表：使用数字和一个英文点号表示有序列表，点号后面<strong>一腚要有个空格</strong>。</p><p><img src="list_02.png"></p><p>（3）二者同时使用：</p><p><img src="list_03.png"></p><p>（4）列表内也可加入其他 Markdown 语法，包括标题、引用、代码块等这里不一一演示。</p><blockquote><p><strong>注意：</strong></p><ol><li>加粗效果不能直接用于列表标题里面，但是可以嵌套在列表里面混合使用。</li><li>列表中包含代码块（前面加2个 Tab 或者8个空格，并且需要空一行，否则不显示）。</li><li>数字后接英文点，会无意中生成列表，如2020.12.04日期，有时会被误认为列表。解决：在每个点前面加上 \ 即可。</li></ol></blockquote><h3 id="2-8-表格"><a href="#2-8-表格" class="headerlink" title="2.8 表格"></a>2.8 表格</h3><p>（1）多的不说直接上图：</p><p><img src="table_01.png"></p><p>（2）指定对齐方式：英文冒号在英文减号左侧表示左对齐，右侧则右对齐，两边都有表示居中。</p><p><img src="table_02.png"></p><h2 id="三、常用技巧"><a href="#三、常用技巧" class="headerlink" title="三、常用技巧"></a>三、常用技巧</h2><h3 id="3-1-换行"><a href="#3-1-换行" class="headerlink" title="3.1 换行"></a>3.1 换行</h3><p>（1）连续两个以上空格 + 回车<br>（2）使用 HTML 换行标签</p><h3 id="3-2-缩进字符"><a href="#3-2-缩进字符" class="headerlink" title="3.2 缩进字符"></a>3.2 缩进字符</h3><p>不断行的空白格或半角的空格或全角的空格：</p><p><img src="indent.png"></p><h3 id="3-3-特殊符号"><a href="#3-3-特殊符号" class="headerlink" title="3.3 特殊符号"></a>3.3 特殊符号</h3><p>（1）对于 Markdown 中的语法符号，前面加反斜杠 \ 即可显示符号本身：</p><p><img src="symbol_01.png"></p><p>（2）其他特殊字符：</p><p><img src="symbol_02.png"></p><p>（3）<a href="https://unicode-table.com/">字符对应的 Unicode</a></p><h3 id="3-4-脚注"><a href="#3-4-脚注" class="headerlink" title="3.4 脚注"></a>3.4 脚注</h3><p>在需要添加脚注的文本后加上[^注脚名字]，然后在文本的任意位置(一般在最后)添加对应脚注：</p><p><img src="footnote.png"></p><blockquote><p><strong>注意：</strong><br>脚注自动被搬运到最后面，请到文章末尾查看，脚注后方的链接可以直接跳转回到加注位置。</p></blockquote><h3 id="3-5-表情速查表"><a href="#3-5-表情速查表" class="headerlink" title="3.5 表情速查表"></a>3.5 表情速查表</h3><p>详情参考：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">表情语法大全</a> ，花里胡哨的一大堆…</p><h2 id="四、高阶用法"><a href="#四、高阶用法" class="headerlink" title="四、高阶用法"></a>四、高阶用法</h2><h3 id="4-1-Latex-数学公式"><a href="#4-1-Latex-数学公式" class="headerlink" title="4.1 Latex 数学公式"></a>4.1 Latex 数学公式</h3><p>（1）行内公式：使用两个”$”符号引用公式<br>（2）行间公式：使用两对“$$”符号引用公式<br>详情参考：<a href="https://www.mohu.org/info/symbols/symbols.htm">Latex数学符号</a></p><h3 id="4-2-流程图"><a href="#4-2-流程图" class="headerlink" title="4.2 流程图"></a>4.2 流程图</h3><p>不建议用 Markdown 做各种图，仅作了解：</p><p><img src="flow_chart.png"></p><h3 id="4-3-Todo-列表"><a href="#4-3-Todo-列表" class="headerlink" title="4.3 Todo 列表"></a>4.3 Todo 列表</h3><p><img src="todo_list.png"></p><h3 id="4-4-序号图"><a href="#4-4-序号图" class="headerlink" title="4.4 序号图"></a>4.4 序号图</h3><p><img src="order_list.png"></p><h3 id="4-5-甘特图"><a href="#4-5-甘特图" class="headerlink" title="4.5 甘特图"></a>4.5 甘特图</h3><p><img src="gantt_chart.png"></p><h2 id="五、Markdown-工具"><a href="#五、Markdown-工具" class="headerlink" title="五、Markdown 工具"></a>五、Markdown 工具</h2><p>太多了太多了，这里只推荐两个顶呱呱的：<strong>Typora</strong> 和 <strong>MarkdownPad</strong>，我用的 <strong>Typora</strong> 。</p><p>Typora 的设计理念很 cool，是真正的<strong>即时预览型编辑器</strong>，不同于左右两个窗口，追求<strong>极致的简洁</strong>，它将「写字」和「预览」合体了。可切换到“源代码模式”，Typora 可进行多种文档格式转换如 Word。流畅度、反应速度很快，适合辣些<strong>手速快</strong>的<strong>ds</strong>（大神）贵族。有需要的伙计可以在官网下载后按需破解白嫖 (⊙x⊙;)</p><p><img src="typora.png"></p><p>MarkdownPad 被很多人称赞为 Windows 下最好用的 Markdown 编辑器之二，功能之强大自然不必解释：</p><p><img src="markdownpad.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 搭建教程</title>
      <link href="/2020/12/04/00.website/"/>
      <url>/2020/12/04/00.website/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如今知识分享的平台和论坛有很多，像知乎、掘金、Stack Overflow、CSDN、博客园、思否还有简书等等，很多问题上面都有答案并且<strong>方便收藏</strong>，然鹅它们不够<strong>个性化</strong>，作为一个喜欢折腾的边缘人思量一番撅腚再弄个自己的無名小站，兜兜转转最后还是选择了 Hexo + <a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a> 这套架子来搭建。</p><h2 id="一、安装-Git、Node-js、Hexo"><a href="#一、安装-Git、Node-js、Hexo" class="headerlink" title="一、安装 Git、Node.js、Hexo"></a>一、安装 Git、Node.js、Hexo</h2><h3 id="1-1-安装-Git"><a href="#1-1-安装-Git" class="headerlink" title="1.1 安装 Git"></a>1.1 安装 Git</h3><p>为了把本地文件上传到 GitHub，需要用到分布式版本控制工具 <strong>Git</strong>，不得不说 <strong>Linus Torvalds</strong> YYDS，基于 Git 之后又有了全球最大的同性交友平台 GitHub，由三个旧金山的年轻人在2008年4月创办，正如每个伟大的传奇都开始于一场冒险，Tom 在这篇文章 <a href="http://tom.preston-werner.com/2008/10/18/how-i-turned-down-300k.html">我如何辞掉微软30万年薪邀约，创办GitHub</a> 中谈到：当我老去，回顾一生，我想说，”哇，那是一场冒险“；而不是，“哇，我真的很安稳“。</p><p><strong>Windows下载：</strong>到 Git 官网上下载，安装时选项默认，只不过最后一步添加路径时要选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开 Git 了。之后，就可以直接右键空白处使用<code>git bash</code>来敲命令行了。</p><p><strong>linux 下载：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>安装完成后在命令提示符中输入<code>git --version</code>来查看一下版本验证是否安装成功。<br>对了，记得 <a href="https://blog.csdn.net/huangqqdy/article/details/83032408">配置环境变量</a></p></blockquote><h3 id="1-2-安装-Node-js-或-NVM"><a href="#1-2-安装-Node-js-或-NVM" class="headerlink" title="1.2 安装 Node.js 或 NVM"></a>1.2 安装 Node.js 或 NVM</h3><p>Hexo 是基于Node.js 的，需要官网安装 Node.js，然后配置好环境变量，方法和 Git 一样，这里就不一一赘述了。（PS：强烈建议先装 NVM 再用 NVM 安装 Node，可能失效的链接如下： <a href="https://blog.csdn.net/sjp991012/article/details/134426007">NVM 安装</a>）</p><p>安装完后，打开命令行，输入：<code>node -v</code>和<code>npm -v</code>检查是否安装成功。</p><h3 id="1-3-添加阿里的镜像源加速下载"><a href="#1-3-添加阿里的镜像源加速下载" class="headerlink" title="1.3 添加阿里的镜像源加速下载"></a>1.3 添加阿里的镜像源加速下载</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-安装-Hexo"><a href="#1-4-安装-Hexo" class="headerlink" title="1.4 安装 Hexo"></a>1.4 安装 Hexo</h3><p>Git 和 Node.js 安装好后，就可以去安装 Hexo 了，你可以先创建一个文件夹比如叫 Blog，用来存放自己的博客文件。</p><p>在该目录下右键空白处点击 <code>Git Bash Here</code> 定位到该目录下，然后输入命令 <code>npm install -g hexo-cli</code> 安装 <code>Hexo</code>。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完毕后输入 <code>hexo -v</code> 验证是否安装成功，接下来初始化一下 Hexo，输入 <code>hexo init</code> 初始化文件夹。</p><pre class="line-numbers language-bash"><code class="language-bash">hexo init Blog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接着输入 <code>npm install</code> 安装必备的组件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> Blog // 进入这个MyBlog文件夹<span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>新建完成后，指定文件夹 Blog 目录下有：</p><ul><li><code>node_modules:</code> 依赖包</li><li><code>public：</code>存放生成的页面</li><li><code>scaffolds：</code>生成文章的一些模板</li><li><code>source：</code>用来存放你的文章</li><li><code>themes：</code>主题</li><li><code>_config.yml:</code> 博客的配置文件</li></ul><p>如此这般把本地的网站配置完毕后，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器</p><pre class="line-numbers language-bash"><code class="language-bash">hexo ghexo server<span class="token punctuation">(</span>或者简写:hexo s）<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在浏览器中打开<a href="http://localhost:4000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%95%A6%EF%BC%81">http://localhost:4000/，就可以看到我们的博客网站啦！</a></p><p>按<code>Ctrl + C</code>关闭本地服务器</p><h2 id="二、GitHub-创建个人仓库"><a href="#二、GitHub-创建个人仓库" class="headerlink" title="二、GitHub 创建个人仓库"></a>二、GitHub 创建个人仓库</h2><p>接下来需要去注册一个<code>GitHub</code>账号，用来存放我们的网站。然后打开<a href="https://github.com/%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%60New">https://github.com/，新建一个仓库`New</a> repository<code> 输入自己的项目名，后面一定要加</code>.github.io<code>后缀，</code>README`初始化也要勾上。</p><h2 id="三、生成-SSH-添加到-GitHub"><a href="#三、生成-SSH-添加到-GitHub" class="headerlink" title="三、生成 SSH 添加到 GitHub"></a>三、生成 SSH 添加到 GitHub</h2><p><strong>生成<code>SSH</code>添加到<code>GitHub</code>，连接<code>Github</code>与本地。</strong><br>右键空白打开<code>git bash</code>，接着输入下面命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"yourname"</span><span class="token function">git</span> config --global user.email <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里的<code>yourname</code>输入你的<code>GitHub</code>用户名，<code>youremail</code>输入你<code>GitHub</code>的邮箱。</p><p>然后创建<code>SSH</code>,一路回车（三、四次来着）</p><blockquote><p><code>ssh</code>，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在<code>GitHub</code>上，这样当你链接<code>GitHub</code>自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过<code>git</code>上传你的文件到<code>GitHub</code>上。</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"youremail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时它会告诉你已经生成了<code>.ssh</code>的文件夹。在你的电脑中找到这个文件夹。或者<code>git bash</code>中输入：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>准备将输出的内容复制到 GitHub 中进行保存：</p><p>打开<a href="http://github.com/">GitHub</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取个，把<code>id_rsa.pub</code>里面的信息复制进去。<br>在<code>git bash</code>输入<code>ssh -T git@github.com</code>，如果出现你的用户名，辣就成功了。</p><h2 id="四、将-Hexo-部署到-GitHub"><a href="#四、将-Hexo-部署到-GitHub" class="headerlink" title="四、将 Hexo 部署到 GitHub"></a>四、将 Hexo 部署到 GitHub</h2><p>这一步，我们就可以将<code>Hexo</code>和<code>GitHub</code>关联起来，也就是将<code>Hexo</code>生成的文章部署到<code>GitHub</code>上，打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这你可以修改与博客配置相关的各种信息。</p><p>修改最后一行的配置：</p><pre class="line-numbers language-yml"><code class="language-yml">deploy:  type: git  repository: https://github.com/adaichan/adaichan.github.io  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>repository </code>修改为你自己的 <code>github</code> 项目地址即可，就是部署时告诉工具，将生成网页通过 <code>git</code> 方式上传到你对应的链接仓库中。</p><p>这个时候需要先安装 <code>deploy-git</code> ，即部署命令，这样你才能用命令部署到 <code>GitHub</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后依次进行：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中 <code>hexo clean</code> 清除了你之前生成的东西， <code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code> 缩写 ，<code>hexo deploy</code> 部署文章，可以用 <code>hexo d</code> 缩写。</p><blockquote><p>注意<code>deploy</code>时可能要你输入<code>username</code>和<code>password</code></p></blockquote><h2 id="五、设置个人域名"><a href="#五、设置个人域名" class="headerlink" title="五、设置个人域名"></a>五、设置个人域名</h2><p>目前你的个人网站的地址是<code>yourname.github.io</code>，如果不喜欢该网址，这就需要你设置个人域名了，就是需要<strong>花点银子</strong>。</p><blockquote><p><strong>不过，这一步不是必要的，如果目前还不想买域名可以先跳过，继续看后面的，以后想买域名了在还看这块</strong></p></blockquote><p>首先你得购买一个专属域名，<code>xx</code>云都能买，看个人喜好。以腾讯云为例，腾讯云官网购买，然后实名认证后进入腾讯云控制台，点云解析进去，找到你刚买的域名，点进去添加两条解析记录，然后打开你的<code>github</code>博客项目，点击<code>settings</code>，拉到下面<code>Custom domain</code>处，填上你自己的域名，保存。</p><p>这时候你的项目根目录应该会出现一个名为<code>CNAME</code>的文件了。如果没有的话，打开你本地博客<code>/source</code>目录，我的是<code>D:\Blog\source</code>，新建<code>CNAME</code>文件，注意没有后缀。然后在里面写上你的域名，保存。最后运行<code>hexo g</code>、<code>hexo d</code>上传到<code>GitHub</code>。</p><p>过不了多久，再打开你的浏览器，输入你自己的专属域名，就可以看到搭建的网站啦！</p><h2 id="六、写文章、发布文章（G-S-D）"><a href="#六、写文章、发布文章（G-S-D）" class="headerlink" title="六、写文章、发布文章（G.S.D）"></a>六、写文章、发布文章（G.S.D）</h2><p>首先在博客根目录下右键打开<code>git bash</code>，安装一个扩展：<code>npm i hexo-deployer-git</code></p><p>然后输入：<code>hexo new post "article title"</code>，新建一篇文章</p><p>打开 <code>D:\Blog\source\_posts</code> 的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件。</p><p>你可以会直接下载一个 <strong>Typora</strong> 编辑器，在里面编写 Markdown 文件，可以实时预览。编写完 Markdown 文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到<code>Github</code>上。这时打开你的线上网址就能看到新发布的文章啦！（PS：Github 访问速度比较慢，可以参考前几步将网站同时多站点部署到国内的Coding、码云等各个托管平台）</p><h2 id="七、吐槽"><a href="#七、吐槽" class="headerlink" title="七、吐槽"></a>七、吐槽</h2><p>到这一个比较简陋的个人博客小站基本上就搭建完了，写得不算详细，主要其它的优化部分一言难尽，各种诸如环境和依赖包的兼容，配置语法的更新，三方插件失效或冲突等大坑小坑bug层出不穷，不是只言片语扯得清的（建议无视上面教程直接把我的网站项目全部 Ctrl+CV 跑起来后在里面把部分信息修改成自己的可以少走弯路）。若想实现一些花里胡哨的功能少不了大量的鼓捣折腾，<strong>不可能一蹴而就</strong>，毕竟我这也只是刚从未开化状态进入社会主义初级阶段，未来有空再来添砖加瓦。需要个性化定制主题可以参考 <a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a> ，相信会符合诸君口味，在这里致敬 <strong>闪烁之狐</strong> 的开源 ^o^</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
